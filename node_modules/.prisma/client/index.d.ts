
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Grade
 * 
 */
export type Grade = $Result.DefaultSelection<Prisma.$GradePayload>
/**
 * Model Centre
 * 
 */
export type Centre = $Result.DefaultSelection<Prisma.$CentrePayload>
/**
 * Model Personnel
 * 
 */
export type Personnel = $Result.DefaultSelection<Prisma.$PersonnelPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model PersonnelRole
 * 
 */
export type PersonnelRole = $Result.DefaultSelection<Prisma.$PersonnelRolePayload>
/**
 * Model TypeCompetence
 * 
 */
export type TypeCompetence = $Result.DefaultSelection<Prisma.$TypeCompetencePayload>
/**
 * Model PersonnelCompetence
 * 
 */
export type PersonnelCompetence = $Result.DefaultSelection<Prisma.$PersonnelCompetencePayload>
/**
 * Model AptitudeMedicale
 * 
 */
export type AptitudeMedicale = $Result.DefaultSelection<Prisma.$AptitudeMedicalePayload>
/**
 * Model TypeFMPA
 * 
 */
export type TypeFMPA = $Result.DefaultSelection<Prisma.$TypeFMPAPayload>
/**
 * Model SessionFMPA
 * 
 */
export type SessionFMPA = $Result.DefaultSelection<Prisma.$SessionFMPAPayload>
/**
 * Model SessionFMPAFormateur
 * 
 */
export type SessionFMPAFormateur = $Result.DefaultSelection<Prisma.$SessionFMPAFormateurPayload>
/**
 * Model InscriptionFMPA
 * 
 */
export type InscriptionFMPA = $Result.DefaultSelection<Prisma.$InscriptionFMPAPayload>
/**
 * Model SignatureFMPA
 * 
 */
export type SignatureFMPA = $Result.DefaultSelection<Prisma.$SignatureFMPAPayload>
/**
 * Model CategorieMateriel
 * 
 */
export type CategorieMateriel = $Result.DefaultSelection<Prisma.$CategorieMaterielPayload>
/**
 * Model Materiel
 * 
 */
export type Materiel = $Result.DefaultSelection<Prisma.$MaterielPayload>
/**
 * Model IncidentMateriel
 * 
 */
export type IncidentMateriel = $Result.DefaultSelection<Prisma.$IncidentMaterielPayload>
/**
 * Model EPI
 * 
 */
export type EPI = $Result.DefaultSelection<Prisma.$EPIPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model ConversationParticipant
 * 
 */
export type ConversationParticipant = $Result.DefaultSelection<Prisma.$ConversationParticipantPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model MessageLu
 * 
 */
export type MessageLu = $Result.DefaultSelection<Prisma.$MessageLuPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Evenement
 * 
 */
export type Evenement = $Result.DefaultSelection<Prisma.$EvenementPayload>
/**
 * Model EvenementParticipant
 * 
 */
export type EvenementParticipant = $Result.DefaultSelection<Prisma.$EvenementParticipantPayload>
/**
 * Model ExportTTA
 * 
 */
export type ExportTTA = $Result.DefaultSelection<Prisma.$ExportTTAPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Categorie: {
  SPV: 'SPV',
  SPP: 'SPP',
  PATS: 'PATS'
};

export type Categorie = (typeof Categorie)[keyof typeof Categorie]


export const TypeCentre: {
  CIS: 'CIS',
  CSP: 'CSP',
  CS: 'CS',
  CPI: 'CPI'
};

export type TypeCentre = (typeof TypeCentre)[keyof typeof TypeCentre]


export const Sexe: {
  M: 'M',
  F: 'F'
};

export type Sexe = (typeof Sexe)[keyof typeof Sexe]


export const StatutPersonnel: {
  ACTIF: 'ACTIF',
  SUSPENDU: 'SUSPENDU',
  RETRAITE: 'RETRAITE',
  MUTATION: 'MUTATION',
  DEMISSION: 'DEMISSION'
};

export type StatutPersonnel = (typeof StatutPersonnel)[keyof typeof StatutPersonnel]


export const StatutAptitude: {
  APTE: 'APTE',
  APTE_RESTRICTIONS: 'APTE_RESTRICTIONS',
  INAPTE_TEMPORAIRE: 'INAPTE_TEMPORAIRE',
  INAPTE_DEFINITIF: 'INAPTE_DEFINITIF'
};

export type StatutAptitude = (typeof StatutAptitude)[keyof typeof StatutAptitude]


export const StatutSession: {
  PLANIFIE: 'PLANIFIE',
  CONFIRME: 'CONFIRME',
  EN_COURS: 'EN_COURS',
  TERMINE: 'TERMINE',
  ANNULE: 'ANNULE'
};

export type StatutSession = (typeof StatutSession)[keyof typeof StatutSession]


export const StatutInscription: {
  INSCRIT: 'INSCRIT',
  CONFIRME: 'CONFIRME',
  PRESENT: 'PRESENT',
  ABSENT_JUSTIFIE: 'ABSENT_JUSTIFIE',
  ABSENT_NON_JUSTIFIE: 'ABSENT_NON_JUSTIFIE',
  ANNULE: 'ANNULE'
};

export type StatutInscription = (typeof StatutInscription)[keyof typeof StatutInscription]


export const EtatMateriel: {
  OPERATIONNEL: 'OPERATIONNEL',
  MAINTENANCE: 'MAINTENANCE',
  REPARATION: 'REPARATION',
  REFORME: 'REFORME',
  PERDU: 'PERDU'
};

export type EtatMateriel = (typeof EtatMateriel)[keyof typeof EtatMateriel]


export const TypeIncident: {
  PANNE: 'PANNE',
  CASSE: 'CASSE',
  USURE: 'USURE',
  PERTE: 'PERTE',
  VOL: 'VOL',
  AUTRE: 'AUTRE'
};

export type TypeIncident = (typeof TypeIncident)[keyof typeof TypeIncident]


export const GraviteIncident: {
  MINEURE: 'MINEURE',
  MAJEURE: 'MAJEURE',
  CRITIQUE: 'CRITIQUE'
};

export type GraviteIncident = (typeof GraviteIncident)[keyof typeof GraviteIncident]


export const StatutIncident: {
  SIGNALE: 'SIGNALE',
  PRIS_EN_COMPTE: 'PRIS_EN_COMPTE',
  EN_TRAITEMENT: 'EN_TRAITEMENT',
  RESOLU: 'RESOLU',
  ABANDONNE: 'ABANDONNE'
};

export type StatutIncident = (typeof StatutIncident)[keyof typeof StatutIncident]


export const EtatEPI: {
  NEUF: 'NEUF',
  BON: 'BON',
  USE: 'USE',
  REFORME: 'REFORME'
};

export type EtatEPI = (typeof EtatEPI)[keyof typeof EtatEPI]


export const TypeConversation: {
  DIRECT: 'DIRECT',
  GROUPE: 'GROUPE',
  BROADCAST: 'BROADCAST'
};

export type TypeConversation = (typeof TypeConversation)[keyof typeof TypeConversation]


export const RoleConversation: {
  MEMBRE: 'MEMBRE',
  ADMIN: 'ADMIN'
};

export type RoleConversation = (typeof RoleConversation)[keyof typeof RoleConversation]


export const TypeMessage: {
  TEXTE: 'TEXTE',
  FICHIER: 'FICHIER',
  IMAGE: 'IMAGE',
  SYSTEM: 'SYSTEM'
};

export type TypeMessage = (typeof TypeMessage)[keyof typeof TypeMessage]


export const NiveauNotification: {
  INFO: 'INFO',
  WARNING: 'WARNING',
  URGENT: 'URGENT',
  CRITIQUE: 'CRITIQUE'
};

export type NiveauNotification = (typeof NiveauNotification)[keyof typeof NiveauNotification]


export const VisibiliteEvenement: {
  PUBLIC: 'PUBLIC',
  CENTRE: 'CENTRE',
  PRIVE: 'PRIVE'
};

export type VisibiliteEvenement = (typeof VisibiliteEvenement)[keyof typeof VisibiliteEvenement]


export const StatutInvitation: {
  INVITE: 'INVITE',
  ACCEPTE: 'ACCEPTE',
  DECLINE: 'DECLINE',
  TENTATIVE: 'TENTATIVE'
};

export type StatutInvitation = (typeof StatutInvitation)[keyof typeof StatutInvitation]


export const FormatExport: {
  CSV: 'CSV',
  EXCEL: 'EXCEL',
  TXT: 'TXT'
};

export type FormatExport = (typeof FormatExport)[keyof typeof FormatExport]


export const StatutExport: {
  GENERE: 'GENERE',
  VALIDE: 'VALIDE',
  TRANSMIS: 'TRANSMIS',
  TRAITE: 'TRAITE',
  ERREUR: 'ERREUR'
};

export type StatutExport = (typeof StatutExport)[keyof typeof StatutExport]

}

export type Categorie = $Enums.Categorie

export const Categorie: typeof $Enums.Categorie

export type TypeCentre = $Enums.TypeCentre

export const TypeCentre: typeof $Enums.TypeCentre

export type Sexe = $Enums.Sexe

export const Sexe: typeof $Enums.Sexe

export type StatutPersonnel = $Enums.StatutPersonnel

export const StatutPersonnel: typeof $Enums.StatutPersonnel

export type StatutAptitude = $Enums.StatutAptitude

export const StatutAptitude: typeof $Enums.StatutAptitude

export type StatutSession = $Enums.StatutSession

export const StatutSession: typeof $Enums.StatutSession

export type StatutInscription = $Enums.StatutInscription

export const StatutInscription: typeof $Enums.StatutInscription

export type EtatMateriel = $Enums.EtatMateriel

export const EtatMateriel: typeof $Enums.EtatMateriel

export type TypeIncident = $Enums.TypeIncident

export const TypeIncident: typeof $Enums.TypeIncident

export type GraviteIncident = $Enums.GraviteIncident

export const GraviteIncident: typeof $Enums.GraviteIncident

export type StatutIncident = $Enums.StatutIncident

export const StatutIncident: typeof $Enums.StatutIncident

export type EtatEPI = $Enums.EtatEPI

export const EtatEPI: typeof $Enums.EtatEPI

export type TypeConversation = $Enums.TypeConversation

export const TypeConversation: typeof $Enums.TypeConversation

export type RoleConversation = $Enums.RoleConversation

export const RoleConversation: typeof $Enums.RoleConversation

export type TypeMessage = $Enums.TypeMessage

export const TypeMessage: typeof $Enums.TypeMessage

export type NiveauNotification = $Enums.NiveauNotification

export const NiveauNotification: typeof $Enums.NiveauNotification

export type VisibiliteEvenement = $Enums.VisibiliteEvenement

export const VisibiliteEvenement: typeof $Enums.VisibiliteEvenement

export type StatutInvitation = $Enums.StatutInvitation

export const StatutInvitation: typeof $Enums.StatutInvitation

export type FormatExport = $Enums.FormatExport

export const FormatExport: typeof $Enums.FormatExport

export type StatutExport = $Enums.StatutExport

export const StatutExport: typeof $Enums.StatutExport

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Grades
 * const grades = await prisma.grade.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Grades
   * const grades = await prisma.grade.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.grade`: Exposes CRUD operations for the **Grade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades
    * const grades = await prisma.grade.findMany()
    * ```
    */
  get grade(): Prisma.GradeDelegate<ExtArgs>;

  /**
   * `prisma.centre`: Exposes CRUD operations for the **Centre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Centres
    * const centres = await prisma.centre.findMany()
    * ```
    */
  get centre(): Prisma.CentreDelegate<ExtArgs>;

  /**
   * `prisma.personnel`: Exposes CRUD operations for the **Personnel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personnel
    * const personnel = await prisma.personnel.findMany()
    * ```
    */
  get personnel(): Prisma.PersonnelDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.personnelRole`: Exposes CRUD operations for the **PersonnelRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonnelRoles
    * const personnelRoles = await prisma.personnelRole.findMany()
    * ```
    */
  get personnelRole(): Prisma.PersonnelRoleDelegate<ExtArgs>;

  /**
   * `prisma.typeCompetence`: Exposes CRUD operations for the **TypeCompetence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypeCompetences
    * const typeCompetences = await prisma.typeCompetence.findMany()
    * ```
    */
  get typeCompetence(): Prisma.TypeCompetenceDelegate<ExtArgs>;

  /**
   * `prisma.personnelCompetence`: Exposes CRUD operations for the **PersonnelCompetence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonnelCompetences
    * const personnelCompetences = await prisma.personnelCompetence.findMany()
    * ```
    */
  get personnelCompetence(): Prisma.PersonnelCompetenceDelegate<ExtArgs>;

  /**
   * `prisma.aptitudeMedicale`: Exposes CRUD operations for the **AptitudeMedicale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AptitudeMedicales
    * const aptitudeMedicales = await prisma.aptitudeMedicale.findMany()
    * ```
    */
  get aptitudeMedicale(): Prisma.AptitudeMedicaleDelegate<ExtArgs>;

  /**
   * `prisma.typeFMPA`: Exposes CRUD operations for the **TypeFMPA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypeFMPAS
    * const typeFMPAS = await prisma.typeFMPA.findMany()
    * ```
    */
  get typeFMPA(): Prisma.TypeFMPADelegate<ExtArgs>;

  /**
   * `prisma.sessionFMPA`: Exposes CRUD operations for the **SessionFMPA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionFMPAS
    * const sessionFMPAS = await prisma.sessionFMPA.findMany()
    * ```
    */
  get sessionFMPA(): Prisma.SessionFMPADelegate<ExtArgs>;

  /**
   * `prisma.sessionFMPAFormateur`: Exposes CRUD operations for the **SessionFMPAFormateur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionFMPAFormateurs
    * const sessionFMPAFormateurs = await prisma.sessionFMPAFormateur.findMany()
    * ```
    */
  get sessionFMPAFormateur(): Prisma.SessionFMPAFormateurDelegate<ExtArgs>;

  /**
   * `prisma.inscriptionFMPA`: Exposes CRUD operations for the **InscriptionFMPA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InscriptionFMPAS
    * const inscriptionFMPAS = await prisma.inscriptionFMPA.findMany()
    * ```
    */
  get inscriptionFMPA(): Prisma.InscriptionFMPADelegate<ExtArgs>;

  /**
   * `prisma.signatureFMPA`: Exposes CRUD operations for the **SignatureFMPA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SignatureFMPAS
    * const signatureFMPAS = await prisma.signatureFMPA.findMany()
    * ```
    */
  get signatureFMPA(): Prisma.SignatureFMPADelegate<ExtArgs>;

  /**
   * `prisma.categorieMateriel`: Exposes CRUD operations for the **CategorieMateriel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategorieMateriels
    * const categorieMateriels = await prisma.categorieMateriel.findMany()
    * ```
    */
  get categorieMateriel(): Prisma.CategorieMaterielDelegate<ExtArgs>;

  /**
   * `prisma.materiel`: Exposes CRUD operations for the **Materiel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materiels
    * const materiels = await prisma.materiel.findMany()
    * ```
    */
  get materiel(): Prisma.MaterielDelegate<ExtArgs>;

  /**
   * `prisma.incidentMateriel`: Exposes CRUD operations for the **IncidentMateriel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncidentMateriels
    * const incidentMateriels = await prisma.incidentMateriel.findMany()
    * ```
    */
  get incidentMateriel(): Prisma.IncidentMaterielDelegate<ExtArgs>;

  /**
   * `prisma.ePI`: Exposes CRUD operations for the **EPI** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EPIS
    * const ePIS = await prisma.ePI.findMany()
    * ```
    */
  get ePI(): Prisma.EPIDelegate<ExtArgs>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs>;

  /**
   * `prisma.conversationParticipant`: Exposes CRUD operations for the **ConversationParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationParticipants
    * const conversationParticipants = await prisma.conversationParticipant.findMany()
    * ```
    */
  get conversationParticipant(): Prisma.ConversationParticipantDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.messageLu`: Exposes CRUD operations for the **MessageLu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageLus
    * const messageLus = await prisma.messageLu.findMany()
    * ```
    */
  get messageLu(): Prisma.MessageLuDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.evenement`: Exposes CRUD operations for the **Evenement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evenements
    * const evenements = await prisma.evenement.findMany()
    * ```
    */
  get evenement(): Prisma.EvenementDelegate<ExtArgs>;

  /**
   * `prisma.evenementParticipant`: Exposes CRUD operations for the **EvenementParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvenementParticipants
    * const evenementParticipants = await prisma.evenementParticipant.findMany()
    * ```
    */
  get evenementParticipant(): Prisma.EvenementParticipantDelegate<ExtArgs>;

  /**
   * `prisma.exportTTA`: Exposes CRUD operations for the **ExportTTA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExportTTAS
    * const exportTTAS = await prisma.exportTTA.findMany()
    * ```
    */
  get exportTTA(): Prisma.ExportTTADelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Grade: 'Grade',
    Centre: 'Centre',
    Personnel: 'Personnel',
    Role: 'Role',
    PersonnelRole: 'PersonnelRole',
    TypeCompetence: 'TypeCompetence',
    PersonnelCompetence: 'PersonnelCompetence',
    AptitudeMedicale: 'AptitudeMedicale',
    TypeFMPA: 'TypeFMPA',
    SessionFMPA: 'SessionFMPA',
    SessionFMPAFormateur: 'SessionFMPAFormateur',
    InscriptionFMPA: 'InscriptionFMPA',
    SignatureFMPA: 'SignatureFMPA',
    CategorieMateriel: 'CategorieMateriel',
    Materiel: 'Materiel',
    IncidentMateriel: 'IncidentMateriel',
    EPI: 'EPI',
    Conversation: 'Conversation',
    ConversationParticipant: 'ConversationParticipant',
    Message: 'Message',
    MessageLu: 'MessageLu',
    Notification: 'Notification',
    Evenement: 'Evenement',
    EvenementParticipant: 'EvenementParticipant',
    ExportTTA: 'ExportTTA',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "grade" | "centre" | "personnel" | "role" | "personnelRole" | "typeCompetence" | "personnelCompetence" | "aptitudeMedicale" | "typeFMPA" | "sessionFMPA" | "sessionFMPAFormateur" | "inscriptionFMPA" | "signatureFMPA" | "categorieMateriel" | "materiel" | "incidentMateriel" | "ePI" | "conversation" | "conversationParticipant" | "message" | "messageLu" | "notification" | "evenement" | "evenementParticipant" | "exportTTA" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Grade: {
        payload: Prisma.$GradePayload<ExtArgs>
        fields: Prisma.GradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findFirst: {
            args: Prisma.GradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findMany: {
            args: Prisma.GradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          create: {
            args: Prisma.GradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          createMany: {
            args: Prisma.GradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          delete: {
            args: Prisma.GradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          update: {
            args: Prisma.GradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          deleteMany: {
            args: Prisma.GradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          aggregate: {
            args: Prisma.GradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrade>
          }
          groupBy: {
            args: Prisma.GradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeCountArgs<ExtArgs>
            result: $Utils.Optional<GradeCountAggregateOutputType> | number
          }
        }
      }
      Centre: {
        payload: Prisma.$CentrePayload<ExtArgs>
        fields: Prisma.CentreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CentreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CentreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>
          }
          findFirst: {
            args: Prisma.CentreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CentreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>
          }
          findMany: {
            args: Prisma.CentreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>[]
          }
          create: {
            args: Prisma.CentreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>
          }
          createMany: {
            args: Prisma.CentreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CentreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>[]
          }
          delete: {
            args: Prisma.CentreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>
          }
          update: {
            args: Prisma.CentreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>
          }
          deleteMany: {
            args: Prisma.CentreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CentreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CentreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>
          }
          aggregate: {
            args: Prisma.CentreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCentre>
          }
          groupBy: {
            args: Prisma.CentreGroupByArgs<ExtArgs>
            result: $Utils.Optional<CentreGroupByOutputType>[]
          }
          count: {
            args: Prisma.CentreCountArgs<ExtArgs>
            result: $Utils.Optional<CentreCountAggregateOutputType> | number
          }
        }
      }
      Personnel: {
        payload: Prisma.$PersonnelPayload<ExtArgs>
        fields: Prisma.PersonnelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonnelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonnelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>
          }
          findFirst: {
            args: Prisma.PersonnelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonnelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>
          }
          findMany: {
            args: Prisma.PersonnelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>[]
          }
          create: {
            args: Prisma.PersonnelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>
          }
          createMany: {
            args: Prisma.PersonnelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonnelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>[]
          }
          delete: {
            args: Prisma.PersonnelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>
          }
          update: {
            args: Prisma.PersonnelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>
          }
          deleteMany: {
            args: Prisma.PersonnelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonnelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonnelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelPayload>
          }
          aggregate: {
            args: Prisma.PersonnelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonnel>
          }
          groupBy: {
            args: Prisma.PersonnelGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonnelGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonnelCountArgs<ExtArgs>
            result: $Utils.Optional<PersonnelCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      PersonnelRole: {
        payload: Prisma.$PersonnelRolePayload<ExtArgs>
        fields: Prisma.PersonnelRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonnelRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonnelRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelRolePayload>
          }
          findFirst: {
            args: Prisma.PersonnelRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonnelRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelRolePayload>
          }
          findMany: {
            args: Prisma.PersonnelRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelRolePayload>[]
          }
          create: {
            args: Prisma.PersonnelRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelRolePayload>
          }
          createMany: {
            args: Prisma.PersonnelRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonnelRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelRolePayload>[]
          }
          delete: {
            args: Prisma.PersonnelRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelRolePayload>
          }
          update: {
            args: Prisma.PersonnelRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelRolePayload>
          }
          deleteMany: {
            args: Prisma.PersonnelRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonnelRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonnelRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelRolePayload>
          }
          aggregate: {
            args: Prisma.PersonnelRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonnelRole>
          }
          groupBy: {
            args: Prisma.PersonnelRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonnelRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonnelRoleCountArgs<ExtArgs>
            result: $Utils.Optional<PersonnelRoleCountAggregateOutputType> | number
          }
        }
      }
      TypeCompetence: {
        payload: Prisma.$TypeCompetencePayload<ExtArgs>
        fields: Prisma.TypeCompetenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TypeCompetenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeCompetencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypeCompetenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeCompetencePayload>
          }
          findFirst: {
            args: Prisma.TypeCompetenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeCompetencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypeCompetenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeCompetencePayload>
          }
          findMany: {
            args: Prisma.TypeCompetenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeCompetencePayload>[]
          }
          create: {
            args: Prisma.TypeCompetenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeCompetencePayload>
          }
          createMany: {
            args: Prisma.TypeCompetenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TypeCompetenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeCompetencePayload>[]
          }
          delete: {
            args: Prisma.TypeCompetenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeCompetencePayload>
          }
          update: {
            args: Prisma.TypeCompetenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeCompetencePayload>
          }
          deleteMany: {
            args: Prisma.TypeCompetenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TypeCompetenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TypeCompetenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeCompetencePayload>
          }
          aggregate: {
            args: Prisma.TypeCompetenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTypeCompetence>
          }
          groupBy: {
            args: Prisma.TypeCompetenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TypeCompetenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypeCompetenceCountArgs<ExtArgs>
            result: $Utils.Optional<TypeCompetenceCountAggregateOutputType> | number
          }
        }
      }
      PersonnelCompetence: {
        payload: Prisma.$PersonnelCompetencePayload<ExtArgs>
        fields: Prisma.PersonnelCompetenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonnelCompetenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelCompetencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonnelCompetenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelCompetencePayload>
          }
          findFirst: {
            args: Prisma.PersonnelCompetenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelCompetencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonnelCompetenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelCompetencePayload>
          }
          findMany: {
            args: Prisma.PersonnelCompetenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelCompetencePayload>[]
          }
          create: {
            args: Prisma.PersonnelCompetenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelCompetencePayload>
          }
          createMany: {
            args: Prisma.PersonnelCompetenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonnelCompetenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelCompetencePayload>[]
          }
          delete: {
            args: Prisma.PersonnelCompetenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelCompetencePayload>
          }
          update: {
            args: Prisma.PersonnelCompetenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelCompetencePayload>
          }
          deleteMany: {
            args: Prisma.PersonnelCompetenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonnelCompetenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonnelCompetenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonnelCompetencePayload>
          }
          aggregate: {
            args: Prisma.PersonnelCompetenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonnelCompetence>
          }
          groupBy: {
            args: Prisma.PersonnelCompetenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonnelCompetenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonnelCompetenceCountArgs<ExtArgs>
            result: $Utils.Optional<PersonnelCompetenceCountAggregateOutputType> | number
          }
        }
      }
      AptitudeMedicale: {
        payload: Prisma.$AptitudeMedicalePayload<ExtArgs>
        fields: Prisma.AptitudeMedicaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AptitudeMedicaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AptitudeMedicalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AptitudeMedicaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AptitudeMedicalePayload>
          }
          findFirst: {
            args: Prisma.AptitudeMedicaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AptitudeMedicalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AptitudeMedicaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AptitudeMedicalePayload>
          }
          findMany: {
            args: Prisma.AptitudeMedicaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AptitudeMedicalePayload>[]
          }
          create: {
            args: Prisma.AptitudeMedicaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AptitudeMedicalePayload>
          }
          createMany: {
            args: Prisma.AptitudeMedicaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AptitudeMedicaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AptitudeMedicalePayload>[]
          }
          delete: {
            args: Prisma.AptitudeMedicaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AptitudeMedicalePayload>
          }
          update: {
            args: Prisma.AptitudeMedicaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AptitudeMedicalePayload>
          }
          deleteMany: {
            args: Prisma.AptitudeMedicaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AptitudeMedicaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AptitudeMedicaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AptitudeMedicalePayload>
          }
          aggregate: {
            args: Prisma.AptitudeMedicaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAptitudeMedicale>
          }
          groupBy: {
            args: Prisma.AptitudeMedicaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AptitudeMedicaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AptitudeMedicaleCountArgs<ExtArgs>
            result: $Utils.Optional<AptitudeMedicaleCountAggregateOutputType> | number
          }
        }
      }
      TypeFMPA: {
        payload: Prisma.$TypeFMPAPayload<ExtArgs>
        fields: Prisma.TypeFMPAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TypeFMPAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeFMPAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypeFMPAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeFMPAPayload>
          }
          findFirst: {
            args: Prisma.TypeFMPAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeFMPAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypeFMPAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeFMPAPayload>
          }
          findMany: {
            args: Prisma.TypeFMPAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeFMPAPayload>[]
          }
          create: {
            args: Prisma.TypeFMPACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeFMPAPayload>
          }
          createMany: {
            args: Prisma.TypeFMPACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TypeFMPACreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeFMPAPayload>[]
          }
          delete: {
            args: Prisma.TypeFMPADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeFMPAPayload>
          }
          update: {
            args: Prisma.TypeFMPAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeFMPAPayload>
          }
          deleteMany: {
            args: Prisma.TypeFMPADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TypeFMPAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TypeFMPAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeFMPAPayload>
          }
          aggregate: {
            args: Prisma.TypeFMPAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTypeFMPA>
          }
          groupBy: {
            args: Prisma.TypeFMPAGroupByArgs<ExtArgs>
            result: $Utils.Optional<TypeFMPAGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypeFMPACountArgs<ExtArgs>
            result: $Utils.Optional<TypeFMPACountAggregateOutputType> | number
          }
        }
      }
      SessionFMPA: {
        payload: Prisma.$SessionFMPAPayload<ExtArgs>
        fields: Prisma.SessionFMPAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFMPAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFMPAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAPayload>
          }
          findFirst: {
            args: Prisma.SessionFMPAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFMPAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAPayload>
          }
          findMany: {
            args: Prisma.SessionFMPAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAPayload>[]
          }
          create: {
            args: Prisma.SessionFMPACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAPayload>
          }
          createMany: {
            args: Prisma.SessionFMPACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionFMPACreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAPayload>[]
          }
          delete: {
            args: Prisma.SessionFMPADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAPayload>
          }
          update: {
            args: Prisma.SessionFMPAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAPayload>
          }
          deleteMany: {
            args: Prisma.SessionFMPADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionFMPAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionFMPAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAPayload>
          }
          aggregate: {
            args: Prisma.SessionFMPAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionFMPA>
          }
          groupBy: {
            args: Prisma.SessionFMPAGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionFMPAGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionFMPACountArgs<ExtArgs>
            result: $Utils.Optional<SessionFMPACountAggregateOutputType> | number
          }
        }
      }
      SessionFMPAFormateur: {
        payload: Prisma.$SessionFMPAFormateurPayload<ExtArgs>
        fields: Prisma.SessionFMPAFormateurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFMPAFormateurFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAFormateurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFMPAFormateurFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAFormateurPayload>
          }
          findFirst: {
            args: Prisma.SessionFMPAFormateurFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAFormateurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFMPAFormateurFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAFormateurPayload>
          }
          findMany: {
            args: Prisma.SessionFMPAFormateurFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAFormateurPayload>[]
          }
          create: {
            args: Prisma.SessionFMPAFormateurCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAFormateurPayload>
          }
          createMany: {
            args: Prisma.SessionFMPAFormateurCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionFMPAFormateurCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAFormateurPayload>[]
          }
          delete: {
            args: Prisma.SessionFMPAFormateurDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAFormateurPayload>
          }
          update: {
            args: Prisma.SessionFMPAFormateurUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAFormateurPayload>
          }
          deleteMany: {
            args: Prisma.SessionFMPAFormateurDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionFMPAFormateurUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionFMPAFormateurUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionFMPAFormateurPayload>
          }
          aggregate: {
            args: Prisma.SessionFMPAFormateurAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionFMPAFormateur>
          }
          groupBy: {
            args: Prisma.SessionFMPAFormateurGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionFMPAFormateurGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionFMPAFormateurCountArgs<ExtArgs>
            result: $Utils.Optional<SessionFMPAFormateurCountAggregateOutputType> | number
          }
        }
      }
      InscriptionFMPA: {
        payload: Prisma.$InscriptionFMPAPayload<ExtArgs>
        fields: Prisma.InscriptionFMPAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InscriptionFMPAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscriptionFMPAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InscriptionFMPAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscriptionFMPAPayload>
          }
          findFirst: {
            args: Prisma.InscriptionFMPAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscriptionFMPAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InscriptionFMPAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscriptionFMPAPayload>
          }
          findMany: {
            args: Prisma.InscriptionFMPAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscriptionFMPAPayload>[]
          }
          create: {
            args: Prisma.InscriptionFMPACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscriptionFMPAPayload>
          }
          createMany: {
            args: Prisma.InscriptionFMPACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InscriptionFMPACreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscriptionFMPAPayload>[]
          }
          delete: {
            args: Prisma.InscriptionFMPADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscriptionFMPAPayload>
          }
          update: {
            args: Prisma.InscriptionFMPAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscriptionFMPAPayload>
          }
          deleteMany: {
            args: Prisma.InscriptionFMPADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InscriptionFMPAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InscriptionFMPAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InscriptionFMPAPayload>
          }
          aggregate: {
            args: Prisma.InscriptionFMPAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInscriptionFMPA>
          }
          groupBy: {
            args: Prisma.InscriptionFMPAGroupByArgs<ExtArgs>
            result: $Utils.Optional<InscriptionFMPAGroupByOutputType>[]
          }
          count: {
            args: Prisma.InscriptionFMPACountArgs<ExtArgs>
            result: $Utils.Optional<InscriptionFMPACountAggregateOutputType> | number
          }
        }
      }
      SignatureFMPA: {
        payload: Prisma.$SignatureFMPAPayload<ExtArgs>
        fields: Prisma.SignatureFMPAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SignatureFMPAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignatureFMPAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SignatureFMPAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignatureFMPAPayload>
          }
          findFirst: {
            args: Prisma.SignatureFMPAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignatureFMPAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SignatureFMPAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignatureFMPAPayload>
          }
          findMany: {
            args: Prisma.SignatureFMPAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignatureFMPAPayload>[]
          }
          create: {
            args: Prisma.SignatureFMPACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignatureFMPAPayload>
          }
          createMany: {
            args: Prisma.SignatureFMPACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SignatureFMPACreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignatureFMPAPayload>[]
          }
          delete: {
            args: Prisma.SignatureFMPADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignatureFMPAPayload>
          }
          update: {
            args: Prisma.SignatureFMPAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignatureFMPAPayload>
          }
          deleteMany: {
            args: Prisma.SignatureFMPADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SignatureFMPAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SignatureFMPAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignatureFMPAPayload>
          }
          aggregate: {
            args: Prisma.SignatureFMPAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignatureFMPA>
          }
          groupBy: {
            args: Prisma.SignatureFMPAGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignatureFMPAGroupByOutputType>[]
          }
          count: {
            args: Prisma.SignatureFMPACountArgs<ExtArgs>
            result: $Utils.Optional<SignatureFMPACountAggregateOutputType> | number
          }
        }
      }
      CategorieMateriel: {
        payload: Prisma.$CategorieMaterielPayload<ExtArgs>
        fields: Prisma.CategorieMaterielFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategorieMaterielFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorieMaterielPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategorieMaterielFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorieMaterielPayload>
          }
          findFirst: {
            args: Prisma.CategorieMaterielFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorieMaterielPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategorieMaterielFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorieMaterielPayload>
          }
          findMany: {
            args: Prisma.CategorieMaterielFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorieMaterielPayload>[]
          }
          create: {
            args: Prisma.CategorieMaterielCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorieMaterielPayload>
          }
          createMany: {
            args: Prisma.CategorieMaterielCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategorieMaterielCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorieMaterielPayload>[]
          }
          delete: {
            args: Prisma.CategorieMaterielDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorieMaterielPayload>
          }
          update: {
            args: Prisma.CategorieMaterielUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorieMaterielPayload>
          }
          deleteMany: {
            args: Prisma.CategorieMaterielDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategorieMaterielUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategorieMaterielUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategorieMaterielPayload>
          }
          aggregate: {
            args: Prisma.CategorieMaterielAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategorieMateriel>
          }
          groupBy: {
            args: Prisma.CategorieMaterielGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategorieMaterielGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategorieMaterielCountArgs<ExtArgs>
            result: $Utils.Optional<CategorieMaterielCountAggregateOutputType> | number
          }
        }
      }
      Materiel: {
        payload: Prisma.$MaterielPayload<ExtArgs>
        fields: Prisma.MaterielFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterielFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterielFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>
          }
          findFirst: {
            args: Prisma.MaterielFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterielFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>
          }
          findMany: {
            args: Prisma.MaterielFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>[]
          }
          create: {
            args: Prisma.MaterielCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>
          }
          createMany: {
            args: Prisma.MaterielCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterielCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>[]
          }
          delete: {
            args: Prisma.MaterielDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>
          }
          update: {
            args: Prisma.MaterielUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>
          }
          deleteMany: {
            args: Prisma.MaterielDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterielUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaterielUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterielPayload>
          }
          aggregate: {
            args: Prisma.MaterielAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMateriel>
          }
          groupBy: {
            args: Prisma.MaterielGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterielGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterielCountArgs<ExtArgs>
            result: $Utils.Optional<MaterielCountAggregateOutputType> | number
          }
        }
      }
      IncidentMateriel: {
        payload: Prisma.$IncidentMaterielPayload<ExtArgs>
        fields: Prisma.IncidentMaterielFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentMaterielFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentMaterielPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentMaterielFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentMaterielPayload>
          }
          findFirst: {
            args: Prisma.IncidentMaterielFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentMaterielPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentMaterielFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentMaterielPayload>
          }
          findMany: {
            args: Prisma.IncidentMaterielFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentMaterielPayload>[]
          }
          create: {
            args: Prisma.IncidentMaterielCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentMaterielPayload>
          }
          createMany: {
            args: Prisma.IncidentMaterielCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncidentMaterielCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentMaterielPayload>[]
          }
          delete: {
            args: Prisma.IncidentMaterielDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentMaterielPayload>
          }
          update: {
            args: Prisma.IncidentMaterielUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentMaterielPayload>
          }
          deleteMany: {
            args: Prisma.IncidentMaterielDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentMaterielUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncidentMaterielUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentMaterielPayload>
          }
          aggregate: {
            args: Prisma.IncidentMaterielAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncidentMateriel>
          }
          groupBy: {
            args: Prisma.IncidentMaterielGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentMaterielGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentMaterielCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentMaterielCountAggregateOutputType> | number
          }
        }
      }
      EPI: {
        payload: Prisma.$EPIPayload<ExtArgs>
        fields: Prisma.EPIFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EPIFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPIPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EPIFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPIPayload>
          }
          findFirst: {
            args: Prisma.EPIFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPIPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EPIFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPIPayload>
          }
          findMany: {
            args: Prisma.EPIFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPIPayload>[]
          }
          create: {
            args: Prisma.EPICreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPIPayload>
          }
          createMany: {
            args: Prisma.EPICreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EPICreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPIPayload>[]
          }
          delete: {
            args: Prisma.EPIDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPIPayload>
          }
          update: {
            args: Prisma.EPIUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPIPayload>
          }
          deleteMany: {
            args: Prisma.EPIDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EPIUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EPIUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPIPayload>
          }
          aggregate: {
            args: Prisma.EPIAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEPI>
          }
          groupBy: {
            args: Prisma.EPIGroupByArgs<ExtArgs>
            result: $Utils.Optional<EPIGroupByOutputType>[]
          }
          count: {
            args: Prisma.EPICountArgs<ExtArgs>
            result: $Utils.Optional<EPICountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      ConversationParticipant: {
        payload: Prisma.$ConversationParticipantPayload<ExtArgs>
        fields: Prisma.ConversationParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findFirst: {
            args: Prisma.ConversationParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findMany: {
            args: Prisma.ConversationParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          create: {
            args: Prisma.ConversationParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          createMany: {
            args: Prisma.ConversationParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          delete: {
            args: Prisma.ConversationParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          update: {
            args: Prisma.ConversationParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ConversationParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          aggregate: {
            args: Prisma.ConversationParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationParticipant>
          }
          groupBy: {
            args: Prisma.ConversationParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      MessageLu: {
        payload: Prisma.$MessageLuPayload<ExtArgs>
        fields: Prisma.MessageLuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageLuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageLuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLuPayload>
          }
          findFirst: {
            args: Prisma.MessageLuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageLuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLuPayload>
          }
          findMany: {
            args: Prisma.MessageLuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLuPayload>[]
          }
          create: {
            args: Prisma.MessageLuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLuPayload>
          }
          createMany: {
            args: Prisma.MessageLuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageLuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLuPayload>[]
          }
          delete: {
            args: Prisma.MessageLuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLuPayload>
          }
          update: {
            args: Prisma.MessageLuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLuPayload>
          }
          deleteMany: {
            args: Prisma.MessageLuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageLuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageLuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLuPayload>
          }
          aggregate: {
            args: Prisma.MessageLuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageLu>
          }
          groupBy: {
            args: Prisma.MessageLuGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageLuGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageLuCountArgs<ExtArgs>
            result: $Utils.Optional<MessageLuCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Evenement: {
        payload: Prisma.$EvenementPayload<ExtArgs>
        fields: Prisma.EvenementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvenementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvenementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>
          }
          findFirst: {
            args: Prisma.EvenementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvenementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>
          }
          findMany: {
            args: Prisma.EvenementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>[]
          }
          create: {
            args: Prisma.EvenementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>
          }
          createMany: {
            args: Prisma.EvenementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvenementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>[]
          }
          delete: {
            args: Prisma.EvenementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>
          }
          update: {
            args: Prisma.EvenementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>
          }
          deleteMany: {
            args: Prisma.EvenementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvenementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvenementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementPayload>
          }
          aggregate: {
            args: Prisma.EvenementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvenement>
          }
          groupBy: {
            args: Prisma.EvenementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvenementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvenementCountArgs<ExtArgs>
            result: $Utils.Optional<EvenementCountAggregateOutputType> | number
          }
        }
      }
      EvenementParticipant: {
        payload: Prisma.$EvenementParticipantPayload<ExtArgs>
        fields: Prisma.EvenementParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvenementParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvenementParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementParticipantPayload>
          }
          findFirst: {
            args: Prisma.EvenementParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvenementParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementParticipantPayload>
          }
          findMany: {
            args: Prisma.EvenementParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementParticipantPayload>[]
          }
          create: {
            args: Prisma.EvenementParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementParticipantPayload>
          }
          createMany: {
            args: Prisma.EvenementParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvenementParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementParticipantPayload>[]
          }
          delete: {
            args: Prisma.EvenementParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementParticipantPayload>
          }
          update: {
            args: Prisma.EvenementParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementParticipantPayload>
          }
          deleteMany: {
            args: Prisma.EvenementParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvenementParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvenementParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementParticipantPayload>
          }
          aggregate: {
            args: Prisma.EvenementParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvenementParticipant>
          }
          groupBy: {
            args: Prisma.EvenementParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvenementParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvenementParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<EvenementParticipantCountAggregateOutputType> | number
          }
        }
      }
      ExportTTA: {
        payload: Prisma.$ExportTTAPayload<ExtArgs>
        fields: Prisma.ExportTTAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExportTTAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTTAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExportTTAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTTAPayload>
          }
          findFirst: {
            args: Prisma.ExportTTAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTTAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExportTTAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTTAPayload>
          }
          findMany: {
            args: Prisma.ExportTTAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTTAPayload>[]
          }
          create: {
            args: Prisma.ExportTTACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTTAPayload>
          }
          createMany: {
            args: Prisma.ExportTTACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExportTTACreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTTAPayload>[]
          }
          delete: {
            args: Prisma.ExportTTADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTTAPayload>
          }
          update: {
            args: Prisma.ExportTTAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTTAPayload>
          }
          deleteMany: {
            args: Prisma.ExportTTADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExportTTAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExportTTAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportTTAPayload>
          }
          aggregate: {
            args: Prisma.ExportTTAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExportTTA>
          }
          groupBy: {
            args: Prisma.ExportTTAGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExportTTAGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExportTTACountArgs<ExtArgs>
            result: $Utils.Optional<ExportTTACountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type GradeCountOutputType
   */

  export type GradeCountOutputType = {
    personnels: number
  }

  export type GradeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnels?: boolean | GradeCountOutputTypeCountPersonnelsArgs
  }

  // Custom InputTypes
  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCountOutputType
     */
    select?: GradeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeCountPersonnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnelWhereInput
  }


  /**
   * Count Type CentreCountOutputType
   */

  export type CentreCountOutputType = {
    personnels: number
    sessions: number
    materiels: number
    evenements: number
    exportsTTA: number
  }

  export type CentreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnels?: boolean | CentreCountOutputTypeCountPersonnelsArgs
    sessions?: boolean | CentreCountOutputTypeCountSessionsArgs
    materiels?: boolean | CentreCountOutputTypeCountMaterielsArgs
    evenements?: boolean | CentreCountOutputTypeCountEvenementsArgs
    exportsTTA?: boolean | CentreCountOutputTypeCountExportsTTAArgs
  }

  // Custom InputTypes
  /**
   * CentreCountOutputType without action
   */
  export type CentreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreCountOutputType
     */
    select?: CentreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CentreCountOutputType without action
   */
  export type CentreCountOutputTypeCountPersonnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnelWhereInput
  }

  /**
   * CentreCountOutputType without action
   */
  export type CentreCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionFMPAWhereInput
  }

  /**
   * CentreCountOutputType without action
   */
  export type CentreCountOutputTypeCountMaterielsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterielWhereInput
  }

  /**
   * CentreCountOutputType without action
   */
  export type CentreCountOutputTypeCountEvenementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvenementWhereInput
  }

  /**
   * CentreCountOutputType without action
   */
  export type CentreCountOutputTypeCountExportsTTAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportTTAWhereInput
  }


  /**
   * Count Type PersonnelCountOutputType
   */

  export type PersonnelCountOutputType = {
    personnelRoles: number
    competences: number
    aptitudesMedicales: number
    inscriptionsFMPA: number
    sessionsFMPAFormateur: number
    sessionsFMPAAdditionnels: number
    signaturesFMPA: number
    epi: number
    materielsResponsable: number
    incidentsSignales: number
    incidentsTraites: number
    conversationsCreees: number
    participations: number
    messagesEnvoyes: number
    messagesLus: number
    notifications: number
    evenementsCreees: number
    participationsEvenements: number
    exportsTTAGeneres: number
    exportsTTAValides: number
    auditLogs: number
  }

  export type PersonnelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnelRoles?: boolean | PersonnelCountOutputTypeCountPersonnelRolesArgs
    competences?: boolean | PersonnelCountOutputTypeCountCompetencesArgs
    aptitudesMedicales?: boolean | PersonnelCountOutputTypeCountAptitudesMedicalesArgs
    inscriptionsFMPA?: boolean | PersonnelCountOutputTypeCountInscriptionsFMPAArgs
    sessionsFMPAFormateur?: boolean | PersonnelCountOutputTypeCountSessionsFMPAFormateurArgs
    sessionsFMPAAdditionnels?: boolean | PersonnelCountOutputTypeCountSessionsFMPAAdditionnelsArgs
    signaturesFMPA?: boolean | PersonnelCountOutputTypeCountSignaturesFMPAArgs
    epi?: boolean | PersonnelCountOutputTypeCountEpiArgs
    materielsResponsable?: boolean | PersonnelCountOutputTypeCountMaterielsResponsableArgs
    incidentsSignales?: boolean | PersonnelCountOutputTypeCountIncidentsSignalesArgs
    incidentsTraites?: boolean | PersonnelCountOutputTypeCountIncidentsTraitesArgs
    conversationsCreees?: boolean | PersonnelCountOutputTypeCountConversationsCreeesArgs
    participations?: boolean | PersonnelCountOutputTypeCountParticipationsArgs
    messagesEnvoyes?: boolean | PersonnelCountOutputTypeCountMessagesEnvoyesArgs
    messagesLus?: boolean | PersonnelCountOutputTypeCountMessagesLusArgs
    notifications?: boolean | PersonnelCountOutputTypeCountNotificationsArgs
    evenementsCreees?: boolean | PersonnelCountOutputTypeCountEvenementsCreeesArgs
    participationsEvenements?: boolean | PersonnelCountOutputTypeCountParticipationsEvenementsArgs
    exportsTTAGeneres?: boolean | PersonnelCountOutputTypeCountExportsTTAGeneresArgs
    exportsTTAValides?: boolean | PersonnelCountOutputTypeCountExportsTTAValidesArgs
    auditLogs?: boolean | PersonnelCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCountOutputType
     */
    select?: PersonnelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountPersonnelRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnelRoleWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountCompetencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnelCompetenceWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountAptitudesMedicalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AptitudeMedicaleWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountInscriptionsFMPAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscriptionFMPAWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountSessionsFMPAFormateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionFMPAWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountSessionsFMPAAdditionnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionFMPAFormateurWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountSignaturesFMPAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignatureFMPAWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountEpiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EPIWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountMaterielsResponsableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterielWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountIncidentsSignalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentMaterielWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountIncidentsTraitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentMaterielWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountConversationsCreeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountMessagesEnvoyesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountMessagesLusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageLuWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountEvenementsCreeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvenementWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountParticipationsEvenementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvenementParticipantWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountExportsTTAGeneresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportTTAWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountExportsTTAValidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportTTAWhereInput
  }

  /**
   * PersonnelCountOutputType without action
   */
  export type PersonnelCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    personnels: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnels?: boolean | RoleCountOutputTypeCountPersonnelsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPersonnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnelRoleWhereInput
  }


  /**
   * Count Type TypeCompetenceCountOutputType
   */

  export type TypeCompetenceCountOutputType = {
    competences: number
  }

  export type TypeCompetenceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    competences?: boolean | TypeCompetenceCountOutputTypeCountCompetencesArgs
  }

  // Custom InputTypes
  /**
   * TypeCompetenceCountOutputType without action
   */
  export type TypeCompetenceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCompetenceCountOutputType
     */
    select?: TypeCompetenceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TypeCompetenceCountOutputType without action
   */
  export type TypeCompetenceCountOutputTypeCountCompetencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnelCompetenceWhereInput
  }


  /**
   * Count Type TypeFMPACountOutputType
   */

  export type TypeFMPACountOutputType = {
    sessions: number
  }

  export type TypeFMPACountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | TypeFMPACountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * TypeFMPACountOutputType without action
   */
  export type TypeFMPACountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeFMPACountOutputType
     */
    select?: TypeFMPACountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TypeFMPACountOutputType without action
   */
  export type TypeFMPACountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionFMPAWhereInput
  }


  /**
   * Count Type SessionFMPACountOutputType
   */

  export type SessionFMPACountOutputType = {
    formateursAdditionnels: number
    inscriptions: number
    signatures: number
    exportsTTA: number
  }

  export type SessionFMPACountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formateursAdditionnels?: boolean | SessionFMPACountOutputTypeCountFormateursAdditionnelsArgs
    inscriptions?: boolean | SessionFMPACountOutputTypeCountInscriptionsArgs
    signatures?: boolean | SessionFMPACountOutputTypeCountSignaturesArgs
    exportsTTA?: boolean | SessionFMPACountOutputTypeCountExportsTTAArgs
  }

  // Custom InputTypes
  /**
   * SessionFMPACountOutputType without action
   */
  export type SessionFMPACountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPACountOutputType
     */
    select?: SessionFMPACountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionFMPACountOutputType without action
   */
  export type SessionFMPACountOutputTypeCountFormateursAdditionnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionFMPAFormateurWhereInput
  }

  /**
   * SessionFMPACountOutputType without action
   */
  export type SessionFMPACountOutputTypeCountInscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscriptionFMPAWhereInput
  }

  /**
   * SessionFMPACountOutputType without action
   */
  export type SessionFMPACountOutputTypeCountSignaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignatureFMPAWhereInput
  }

  /**
   * SessionFMPACountOutputType without action
   */
  export type SessionFMPACountOutputTypeCountExportsTTAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportTTAWhereInput
  }


  /**
   * Count Type CategorieMaterielCountOutputType
   */

  export type CategorieMaterielCountOutputType = {
    materiels: number
  }

  export type CategorieMaterielCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materiels?: boolean | CategorieMaterielCountOutputTypeCountMaterielsArgs
  }

  // Custom InputTypes
  /**
   * CategorieMaterielCountOutputType without action
   */
  export type CategorieMaterielCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorieMaterielCountOutputType
     */
    select?: CategorieMaterielCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategorieMaterielCountOutputType without action
   */
  export type CategorieMaterielCountOutputTypeCountMaterielsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterielWhereInput
  }


  /**
   * Count Type MaterielCountOutputType
   */

  export type MaterielCountOutputType = {
    incidents: number
  }

  export type MaterielCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incidents?: boolean | MaterielCountOutputTypeCountIncidentsArgs
  }

  // Custom InputTypes
  /**
   * MaterielCountOutputType without action
   */
  export type MaterielCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterielCountOutputType
     */
    select?: MaterielCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaterielCountOutputType without action
   */
  export type MaterielCountOutputTypeCountIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentMaterielWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    participants: number
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ConversationCountOutputTypeCountParticipantsArgs
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    messagesLus: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messagesLus?: boolean | MessageCountOutputTypeCountMessagesLusArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountMessagesLusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageLuWhereInput
  }


  /**
   * Count Type EvenementCountOutputType
   */

  export type EvenementCountOutputType = {
    participants: number
  }

  export type EvenementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | EvenementCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * EvenementCountOutputType without action
   */
  export type EvenementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementCountOutputType
     */
    select?: EvenementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvenementCountOutputType without action
   */
  export type EvenementCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvenementParticipantWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Grade
   */

  export type AggregateGrade = {
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  export type GradeAvgAggregateOutputType = {
    id: number | null
    ordreHierarchique: number | null
  }

  export type GradeSumAggregateOutputType = {
    id: number | null
    ordreHierarchique: number | null
  }

  export type GradeMinAggregateOutputType = {
    id: number | null
    code: string | null
    libelle: string | null
    categorie: $Enums.Categorie | null
    ordreHierarchique: number | null
    actif: boolean | null
  }

  export type GradeMaxAggregateOutputType = {
    id: number | null
    code: string | null
    libelle: string | null
    categorie: $Enums.Categorie | null
    ordreHierarchique: number | null
    actif: boolean | null
  }

  export type GradeCountAggregateOutputType = {
    id: number
    code: number
    libelle: number
    categorie: number
    ordreHierarchique: number
    actif: number
    _all: number
  }


  export type GradeAvgAggregateInputType = {
    id?: true
    ordreHierarchique?: true
  }

  export type GradeSumAggregateInputType = {
    id?: true
    ordreHierarchique?: true
  }

  export type GradeMinAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    categorie?: true
    ordreHierarchique?: true
    actif?: true
  }

  export type GradeMaxAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    categorie?: true
    ordreHierarchique?: true
    actif?: true
  }

  export type GradeCountAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    categorie?: true
    ordreHierarchique?: true
    actif?: true
    _all?: true
  }

  export type GradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grade to aggregate.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grades
    **/
    _count?: true | GradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeMaxAggregateInputType
  }

  export type GetGradeAggregateType<T extends GradeAggregateArgs> = {
        [P in keyof T & keyof AggregateGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrade[P]>
      : GetScalarType<T[P], AggregateGrade[P]>
  }




  export type GradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithAggregationInput | GradeOrderByWithAggregationInput[]
    by: GradeScalarFieldEnum[] | GradeScalarFieldEnum
    having?: GradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeCountAggregateInputType | true
    _avg?: GradeAvgAggregateInputType
    _sum?: GradeSumAggregateInputType
    _min?: GradeMinAggregateInputType
    _max?: GradeMaxAggregateInputType
  }

  export type GradeGroupByOutputType = {
    id: number
    code: string
    libelle: string
    categorie: $Enums.Categorie
    ordreHierarchique: number
    actif: boolean
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  type GetGradeGroupByPayload<T extends GradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeGroupByOutputType[P]>
            : GetScalarType<T[P], GradeGroupByOutputType[P]>
        }
      >
    >


  export type GradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    categorie?: boolean
    ordreHierarchique?: boolean
    actif?: boolean
    personnels?: boolean | Grade$personnelsArgs<ExtArgs>
    _count?: boolean | GradeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    categorie?: boolean
    ordreHierarchique?: boolean
    actif?: boolean
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectScalar = {
    id?: boolean
    code?: boolean
    libelle?: boolean
    categorie?: boolean
    ordreHierarchique?: boolean
    actif?: boolean
  }

  export type GradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnels?: boolean | Grade$personnelsArgs<ExtArgs>
    _count?: boolean | GradeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grade"
    objects: {
      personnels: Prisma.$PersonnelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      libelle: string
      categorie: $Enums.Categorie
      ordreHierarchique: number
      actif: boolean
    }, ExtArgs["result"]["grade"]>
    composites: {}
  }

  type GradeGetPayload<S extends boolean | null | undefined | GradeDefaultArgs> = $Result.GetResult<Prisma.$GradePayload, S>

  type GradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GradeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GradeCountAggregateInputType | true
    }

  export interface GradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grade'], meta: { name: 'Grade' } }
    /**
     * Find zero or one Grade that matches the filter.
     * @param {GradeFindUniqueArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeFindUniqueArgs>(args: SelectSubset<T, GradeFindUniqueArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Grade that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GradeFindUniqueOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Grade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeFindFirstArgs>(args?: SelectSubset<T, GradeFindFirstArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Grade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades
     * const grades = await prisma.grade.findMany()
     * 
     * // Get first 10 Grades
     * const grades = await prisma.grade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeWithIdOnly = await prisma.grade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeFindManyArgs>(args?: SelectSubset<T, GradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Grade.
     * @param {GradeCreateArgs} args - Arguments to create a Grade.
     * @example
     * // Create one Grade
     * const Grade = await prisma.grade.create({
     *   data: {
     *     // ... data to create a Grade
     *   }
     * })
     * 
     */
    create<T extends GradeCreateArgs>(args: SelectSubset<T, GradeCreateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Grades.
     * @param {GradeCreateManyArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeCreateManyArgs>(args?: SelectSubset<T, GradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grades and returns the data saved in the database.
     * @param {GradeCreateManyAndReturnArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Grade.
     * @param {GradeDeleteArgs} args - Arguments to delete one Grade.
     * @example
     * // Delete one Grade
     * const Grade = await prisma.grade.delete({
     *   where: {
     *     // ... filter to delete one Grade
     *   }
     * })
     * 
     */
    delete<T extends GradeDeleteArgs>(args: SelectSubset<T, GradeDeleteArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Grade.
     * @param {GradeUpdateArgs} args - Arguments to update one Grade.
     * @example
     * // Update one Grade
     * const grade = await prisma.grade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeUpdateArgs>(args: SelectSubset<T, GradeUpdateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Grades.
     * @param {GradeDeleteManyArgs} args - Arguments to filter Grades to delete.
     * @example
     * // Delete a few Grades
     * const { count } = await prisma.grade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeDeleteManyArgs>(args?: SelectSubset<T, GradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeUpdateManyArgs>(args: SelectSubset<T, GradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Grade.
     * @param {GradeUpsertArgs} args - Arguments to update or create a Grade.
     * @example
     * // Update or create a Grade
     * const grade = await prisma.grade.upsert({
     *   create: {
     *     // ... data to create a Grade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grade we want to update
     *   }
     * })
     */
    upsert<T extends GradeUpsertArgs>(args: SelectSubset<T, GradeUpsertArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCountArgs} args - Arguments to filter Grades to count.
     * @example
     * // Count the number of Grades
     * const count = await prisma.grade.count({
     *   where: {
     *     // ... the filter for the Grades we want to count
     *   }
     * })
    **/
    count<T extends GradeCountArgs>(
      args?: Subset<T, GradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeAggregateArgs>(args: Subset<T, GradeAggregateArgs>): Prisma.PrismaPromise<GetGradeAggregateType<T>>

    /**
     * Group by Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeGroupByArgs['orderBy'] }
        : { orderBy?: GradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grade model
   */
  readonly fields: GradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnels<T extends Grade$personnelsArgs<ExtArgs> = {}>(args?: Subset<T, Grade$personnelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grade model
   */ 
  interface GradeFieldRefs {
    readonly id: FieldRef<"Grade", 'Int'>
    readonly code: FieldRef<"Grade", 'String'>
    readonly libelle: FieldRef<"Grade", 'String'>
    readonly categorie: FieldRef<"Grade", 'Categorie'>
    readonly ordreHierarchique: FieldRef<"Grade", 'Int'>
    readonly actif: FieldRef<"Grade", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Grade findUnique
   */
  export type GradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findUniqueOrThrow
   */
  export type GradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findFirst
   */
  export type GradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findFirstOrThrow
   */
  export type GradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findMany
   */
  export type GradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade create
   */
  export type GradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Grade.
     */
    data: XOR<GradeCreateInput, GradeUncheckedCreateInput>
  }

  /**
   * Grade createMany
   */
  export type GradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grade createManyAndReturn
   */
  export type GradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grade update
   */
  export type GradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Grade.
     */
    data: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
    /**
     * Choose, which Grade to update.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade updateMany
   */
  export type GradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
  }

  /**
   * Grade upsert
   */
  export type GradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Grade to update in case it exists.
     */
    where: GradeWhereUniqueInput
    /**
     * In case the Grade found by the `where` argument doesn't exist, create a new Grade with this data.
     */
    create: XOR<GradeCreateInput, GradeUncheckedCreateInput>
    /**
     * In case the Grade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
  }

  /**
   * Grade delete
   */
  export type GradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter which Grade to delete.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade deleteMany
   */
  export type GradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grades to delete
     */
    where?: GradeWhereInput
  }

  /**
   * Grade.personnels
   */
  export type Grade$personnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    where?: PersonnelWhereInput
    orderBy?: PersonnelOrderByWithRelationInput | PersonnelOrderByWithRelationInput[]
    cursor?: PersonnelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnelScalarFieldEnum | PersonnelScalarFieldEnum[]
  }

  /**
   * Grade without action
   */
  export type GradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
  }


  /**
   * Model Centre
   */

  export type AggregateCentre = {
    _count: CentreCountAggregateOutputType | null
    _avg: CentreAvgAggregateOutputType | null
    _sum: CentreSumAggregateOutputType | null
    _min: CentreMinAggregateOutputType | null
    _max: CentreMaxAggregateOutputType | null
  }

  export type CentreAvgAggregateOutputType = {
    id: number | null
  }

  export type CentreSumAggregateOutputType = {
    id: number | null
  }

  export type CentreMinAggregateOutputType = {
    id: number | null
    code: string | null
    nom: string | null
    type: $Enums.TypeCentre | null
    adresse: string | null
    ville: string | null
    codePostal: string | null
    telephone: string | null
    email: string | null
    actif: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CentreMaxAggregateOutputType = {
    id: number | null
    code: string | null
    nom: string | null
    type: $Enums.TypeCentre | null
    adresse: string | null
    ville: string | null
    codePostal: string | null
    telephone: string | null
    email: string | null
    actif: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CentreCountAggregateOutputType = {
    id: number
    code: number
    nom: number
    type: number
    adresse: number
    ville: number
    codePostal: number
    telephone: number
    email: number
    actif: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CentreAvgAggregateInputType = {
    id?: true
  }

  export type CentreSumAggregateInputType = {
    id?: true
  }

  export type CentreMinAggregateInputType = {
    id?: true
    code?: true
    nom?: true
    type?: true
    adresse?: true
    ville?: true
    codePostal?: true
    telephone?: true
    email?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CentreMaxAggregateInputType = {
    id?: true
    code?: true
    nom?: true
    type?: true
    adresse?: true
    ville?: true
    codePostal?: true
    telephone?: true
    email?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CentreCountAggregateInputType = {
    id?: true
    code?: true
    nom?: true
    type?: true
    adresse?: true
    ville?: true
    codePostal?: true
    telephone?: true
    email?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CentreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Centre to aggregate.
     */
    where?: CentreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Centres to fetch.
     */
    orderBy?: CentreOrderByWithRelationInput | CentreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CentreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Centres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Centres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Centres
    **/
    _count?: true | CentreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CentreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CentreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CentreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CentreMaxAggregateInputType
  }

  export type GetCentreAggregateType<T extends CentreAggregateArgs> = {
        [P in keyof T & keyof AggregateCentre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCentre[P]>
      : GetScalarType<T[P], AggregateCentre[P]>
  }




  export type CentreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CentreWhereInput
    orderBy?: CentreOrderByWithAggregationInput | CentreOrderByWithAggregationInput[]
    by: CentreScalarFieldEnum[] | CentreScalarFieldEnum
    having?: CentreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CentreCountAggregateInputType | true
    _avg?: CentreAvgAggregateInputType
    _sum?: CentreSumAggregateInputType
    _min?: CentreMinAggregateInputType
    _max?: CentreMaxAggregateInputType
  }

  export type CentreGroupByOutputType = {
    id: number
    code: string
    nom: string
    type: $Enums.TypeCentre
    adresse: string | null
    ville: string | null
    codePostal: string | null
    telephone: string | null
    email: string | null
    actif: boolean
    createdAt: Date
    updatedAt: Date
    _count: CentreCountAggregateOutputType | null
    _avg: CentreAvgAggregateOutputType | null
    _sum: CentreSumAggregateOutputType | null
    _min: CentreMinAggregateOutputType | null
    _max: CentreMaxAggregateOutputType | null
  }

  type GetCentreGroupByPayload<T extends CentreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CentreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CentreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CentreGroupByOutputType[P]>
            : GetScalarType<T[P], CentreGroupByOutputType[P]>
        }
      >
    >


  export type CentreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    nom?: boolean
    type?: boolean
    adresse?: boolean
    ville?: boolean
    codePostal?: boolean
    telephone?: boolean
    email?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personnels?: boolean | Centre$personnelsArgs<ExtArgs>
    sessions?: boolean | Centre$sessionsArgs<ExtArgs>
    materiels?: boolean | Centre$materielsArgs<ExtArgs>
    evenements?: boolean | Centre$evenementsArgs<ExtArgs>
    exportsTTA?: boolean | Centre$exportsTTAArgs<ExtArgs>
    _count?: boolean | CentreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["centre"]>

  export type CentreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    nom?: boolean
    type?: boolean
    adresse?: boolean
    ville?: boolean
    codePostal?: boolean
    telephone?: boolean
    email?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["centre"]>

  export type CentreSelectScalar = {
    id?: boolean
    code?: boolean
    nom?: boolean
    type?: boolean
    adresse?: boolean
    ville?: boolean
    codePostal?: boolean
    telephone?: boolean
    email?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CentreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnels?: boolean | Centre$personnelsArgs<ExtArgs>
    sessions?: boolean | Centre$sessionsArgs<ExtArgs>
    materiels?: boolean | Centre$materielsArgs<ExtArgs>
    evenements?: boolean | Centre$evenementsArgs<ExtArgs>
    exportsTTA?: boolean | Centre$exportsTTAArgs<ExtArgs>
    _count?: boolean | CentreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CentreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CentrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Centre"
    objects: {
      personnels: Prisma.$PersonnelPayload<ExtArgs>[]
      sessions: Prisma.$SessionFMPAPayload<ExtArgs>[]
      materiels: Prisma.$MaterielPayload<ExtArgs>[]
      evenements: Prisma.$EvenementPayload<ExtArgs>[]
      exportsTTA: Prisma.$ExportTTAPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      nom: string
      type: $Enums.TypeCentre
      adresse: string | null
      ville: string | null
      codePostal: string | null
      telephone: string | null
      email: string | null
      actif: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["centre"]>
    composites: {}
  }

  type CentreGetPayload<S extends boolean | null | undefined | CentreDefaultArgs> = $Result.GetResult<Prisma.$CentrePayload, S>

  type CentreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CentreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CentreCountAggregateInputType | true
    }

  export interface CentreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Centre'], meta: { name: 'Centre' } }
    /**
     * Find zero or one Centre that matches the filter.
     * @param {CentreFindUniqueArgs} args - Arguments to find a Centre
     * @example
     * // Get one Centre
     * const centre = await prisma.centre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CentreFindUniqueArgs>(args: SelectSubset<T, CentreFindUniqueArgs<ExtArgs>>): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Centre that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CentreFindUniqueOrThrowArgs} args - Arguments to find a Centre
     * @example
     * // Get one Centre
     * const centre = await prisma.centre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CentreFindUniqueOrThrowArgs>(args: SelectSubset<T, CentreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Centre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreFindFirstArgs} args - Arguments to find a Centre
     * @example
     * // Get one Centre
     * const centre = await prisma.centre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CentreFindFirstArgs>(args?: SelectSubset<T, CentreFindFirstArgs<ExtArgs>>): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Centre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreFindFirstOrThrowArgs} args - Arguments to find a Centre
     * @example
     * // Get one Centre
     * const centre = await prisma.centre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CentreFindFirstOrThrowArgs>(args?: SelectSubset<T, CentreFindFirstOrThrowArgs<ExtArgs>>): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Centres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Centres
     * const centres = await prisma.centre.findMany()
     * 
     * // Get first 10 Centres
     * const centres = await prisma.centre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const centreWithIdOnly = await prisma.centre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CentreFindManyArgs>(args?: SelectSubset<T, CentreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Centre.
     * @param {CentreCreateArgs} args - Arguments to create a Centre.
     * @example
     * // Create one Centre
     * const Centre = await prisma.centre.create({
     *   data: {
     *     // ... data to create a Centre
     *   }
     * })
     * 
     */
    create<T extends CentreCreateArgs>(args: SelectSubset<T, CentreCreateArgs<ExtArgs>>): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Centres.
     * @param {CentreCreateManyArgs} args - Arguments to create many Centres.
     * @example
     * // Create many Centres
     * const centre = await prisma.centre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CentreCreateManyArgs>(args?: SelectSubset<T, CentreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Centres and returns the data saved in the database.
     * @param {CentreCreateManyAndReturnArgs} args - Arguments to create many Centres.
     * @example
     * // Create many Centres
     * const centre = await prisma.centre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Centres and only return the `id`
     * const centreWithIdOnly = await prisma.centre.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CentreCreateManyAndReturnArgs>(args?: SelectSubset<T, CentreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Centre.
     * @param {CentreDeleteArgs} args - Arguments to delete one Centre.
     * @example
     * // Delete one Centre
     * const Centre = await prisma.centre.delete({
     *   where: {
     *     // ... filter to delete one Centre
     *   }
     * })
     * 
     */
    delete<T extends CentreDeleteArgs>(args: SelectSubset<T, CentreDeleteArgs<ExtArgs>>): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Centre.
     * @param {CentreUpdateArgs} args - Arguments to update one Centre.
     * @example
     * // Update one Centre
     * const centre = await prisma.centre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CentreUpdateArgs>(args: SelectSubset<T, CentreUpdateArgs<ExtArgs>>): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Centres.
     * @param {CentreDeleteManyArgs} args - Arguments to filter Centres to delete.
     * @example
     * // Delete a few Centres
     * const { count } = await prisma.centre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CentreDeleteManyArgs>(args?: SelectSubset<T, CentreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Centres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Centres
     * const centre = await prisma.centre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CentreUpdateManyArgs>(args: SelectSubset<T, CentreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Centre.
     * @param {CentreUpsertArgs} args - Arguments to update or create a Centre.
     * @example
     * // Update or create a Centre
     * const centre = await prisma.centre.upsert({
     *   create: {
     *     // ... data to create a Centre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Centre we want to update
     *   }
     * })
     */
    upsert<T extends CentreUpsertArgs>(args: SelectSubset<T, CentreUpsertArgs<ExtArgs>>): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Centres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreCountArgs} args - Arguments to filter Centres to count.
     * @example
     * // Count the number of Centres
     * const count = await prisma.centre.count({
     *   where: {
     *     // ... the filter for the Centres we want to count
     *   }
     * })
    **/
    count<T extends CentreCountArgs>(
      args?: Subset<T, CentreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CentreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Centre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CentreAggregateArgs>(args: Subset<T, CentreAggregateArgs>): Prisma.PrismaPromise<GetCentreAggregateType<T>>

    /**
     * Group by Centre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CentreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CentreGroupByArgs['orderBy'] }
        : { orderBy?: CentreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CentreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCentreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Centre model
   */
  readonly fields: CentreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Centre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CentreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnels<T extends Centre$personnelsArgs<ExtArgs> = {}>(args?: Subset<T, Centre$personnelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends Centre$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Centre$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "findMany"> | Null>
    materiels<T extends Centre$materielsArgs<ExtArgs> = {}>(args?: Subset<T, Centre$materielsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findMany"> | Null>
    evenements<T extends Centre$evenementsArgs<ExtArgs> = {}>(args?: Subset<T, Centre$evenementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "findMany"> | Null>
    exportsTTA<T extends Centre$exportsTTAArgs<ExtArgs> = {}>(args?: Subset<T, Centre$exportsTTAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportTTAPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Centre model
   */ 
  interface CentreFieldRefs {
    readonly id: FieldRef<"Centre", 'Int'>
    readonly code: FieldRef<"Centre", 'String'>
    readonly nom: FieldRef<"Centre", 'String'>
    readonly type: FieldRef<"Centre", 'TypeCentre'>
    readonly adresse: FieldRef<"Centre", 'String'>
    readonly ville: FieldRef<"Centre", 'String'>
    readonly codePostal: FieldRef<"Centre", 'String'>
    readonly telephone: FieldRef<"Centre", 'String'>
    readonly email: FieldRef<"Centre", 'String'>
    readonly actif: FieldRef<"Centre", 'Boolean'>
    readonly createdAt: FieldRef<"Centre", 'DateTime'>
    readonly updatedAt: FieldRef<"Centre", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Centre findUnique
   */
  export type CentreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * Filter, which Centre to fetch.
     */
    where: CentreWhereUniqueInput
  }

  /**
   * Centre findUniqueOrThrow
   */
  export type CentreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * Filter, which Centre to fetch.
     */
    where: CentreWhereUniqueInput
  }

  /**
   * Centre findFirst
   */
  export type CentreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * Filter, which Centre to fetch.
     */
    where?: CentreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Centres to fetch.
     */
    orderBy?: CentreOrderByWithRelationInput | CentreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Centres.
     */
    cursor?: CentreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Centres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Centres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Centres.
     */
    distinct?: CentreScalarFieldEnum | CentreScalarFieldEnum[]
  }

  /**
   * Centre findFirstOrThrow
   */
  export type CentreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * Filter, which Centre to fetch.
     */
    where?: CentreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Centres to fetch.
     */
    orderBy?: CentreOrderByWithRelationInput | CentreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Centres.
     */
    cursor?: CentreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Centres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Centres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Centres.
     */
    distinct?: CentreScalarFieldEnum | CentreScalarFieldEnum[]
  }

  /**
   * Centre findMany
   */
  export type CentreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * Filter, which Centres to fetch.
     */
    where?: CentreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Centres to fetch.
     */
    orderBy?: CentreOrderByWithRelationInput | CentreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Centres.
     */
    cursor?: CentreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Centres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Centres.
     */
    skip?: number
    distinct?: CentreScalarFieldEnum | CentreScalarFieldEnum[]
  }

  /**
   * Centre create
   */
  export type CentreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * The data needed to create a Centre.
     */
    data: XOR<CentreCreateInput, CentreUncheckedCreateInput>
  }

  /**
   * Centre createMany
   */
  export type CentreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Centres.
     */
    data: CentreCreateManyInput | CentreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Centre createManyAndReturn
   */
  export type CentreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Centres.
     */
    data: CentreCreateManyInput | CentreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Centre update
   */
  export type CentreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * The data needed to update a Centre.
     */
    data: XOR<CentreUpdateInput, CentreUncheckedUpdateInput>
    /**
     * Choose, which Centre to update.
     */
    where: CentreWhereUniqueInput
  }

  /**
   * Centre updateMany
   */
  export type CentreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Centres.
     */
    data: XOR<CentreUpdateManyMutationInput, CentreUncheckedUpdateManyInput>
    /**
     * Filter which Centres to update
     */
    where?: CentreWhereInput
  }

  /**
   * Centre upsert
   */
  export type CentreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * The filter to search for the Centre to update in case it exists.
     */
    where: CentreWhereUniqueInput
    /**
     * In case the Centre found by the `where` argument doesn't exist, create a new Centre with this data.
     */
    create: XOR<CentreCreateInput, CentreUncheckedCreateInput>
    /**
     * In case the Centre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CentreUpdateInput, CentreUncheckedUpdateInput>
  }

  /**
   * Centre delete
   */
  export type CentreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * Filter which Centre to delete.
     */
    where: CentreWhereUniqueInput
  }

  /**
   * Centre deleteMany
   */
  export type CentreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Centres to delete
     */
    where?: CentreWhereInput
  }

  /**
   * Centre.personnels
   */
  export type Centre$personnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    where?: PersonnelWhereInput
    orderBy?: PersonnelOrderByWithRelationInput | PersonnelOrderByWithRelationInput[]
    cursor?: PersonnelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnelScalarFieldEnum | PersonnelScalarFieldEnum[]
  }

  /**
   * Centre.sessions
   */
  export type Centre$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAInclude<ExtArgs> | null
    where?: SessionFMPAWhereInput
    orderBy?: SessionFMPAOrderByWithRelationInput | SessionFMPAOrderByWithRelationInput[]
    cursor?: SessionFMPAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionFMPAScalarFieldEnum | SessionFMPAScalarFieldEnum[]
  }

  /**
   * Centre.materiels
   */
  export type Centre$materielsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    where?: MaterielWhereInput
    orderBy?: MaterielOrderByWithRelationInput | MaterielOrderByWithRelationInput[]
    cursor?: MaterielWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterielScalarFieldEnum | MaterielScalarFieldEnum[]
  }

  /**
   * Centre.evenements
   */
  export type Centre$evenementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    where?: EvenementWhereInput
    orderBy?: EvenementOrderByWithRelationInput | EvenementOrderByWithRelationInput[]
    cursor?: EvenementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvenementScalarFieldEnum | EvenementScalarFieldEnum[]
  }

  /**
   * Centre.exportsTTA
   */
  export type Centre$exportsTTAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAInclude<ExtArgs> | null
    where?: ExportTTAWhereInput
    orderBy?: ExportTTAOrderByWithRelationInput | ExportTTAOrderByWithRelationInput[]
    cursor?: ExportTTAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExportTTAScalarFieldEnum | ExportTTAScalarFieldEnum[]
  }

  /**
   * Centre without action
   */
  export type CentreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
  }


  /**
   * Model Personnel
   */

  export type AggregatePersonnel = {
    _count: PersonnelCountAggregateOutputType | null
    _avg: PersonnelAvgAggregateOutputType | null
    _sum: PersonnelSumAggregateOutputType | null
    _min: PersonnelMinAggregateOutputType | null
    _max: PersonnelMaxAggregateOutputType | null
  }

  export type PersonnelAvgAggregateOutputType = {
    id: number | null
    centreId: number | null
    gradeId: number | null
  }

  export type PersonnelSumAggregateOutputType = {
    id: number | null
    centreId: number | null
    gradeId: number | null
  }

  export type PersonnelMinAggregateOutputType = {
    id: number | null
    matricule: string | null
    nom: string | null
    prenom: string | null
    dateNaissance: Date | null
    sexe: $Enums.Sexe | null
    email: string | null
    telephoneMobile: string | null
    telephoneFixe: string | null
    adresse: string | null
    ville: string | null
    codePostal: string | null
    centreId: number | null
    gradeId: number | null
    categorie: $Enums.Categorie | null
    dateEngagement: Date | null
    dateFinEngagement: Date | null
    statut: $Enums.StatutPersonnel | null
    password: string | null
    refreshToken: string | null
    lastLogin: Date | null
    resetToken: string | null
    resetTokenExpires: Date | null
    photoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PersonnelMaxAggregateOutputType = {
    id: number | null
    matricule: string | null
    nom: string | null
    prenom: string | null
    dateNaissance: Date | null
    sexe: $Enums.Sexe | null
    email: string | null
    telephoneMobile: string | null
    telephoneFixe: string | null
    adresse: string | null
    ville: string | null
    codePostal: string | null
    centreId: number | null
    gradeId: number | null
    categorie: $Enums.Categorie | null
    dateEngagement: Date | null
    dateFinEngagement: Date | null
    statut: $Enums.StatutPersonnel | null
    password: string | null
    refreshToken: string | null
    lastLogin: Date | null
    resetToken: string | null
    resetTokenExpires: Date | null
    photoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PersonnelCountAggregateOutputType = {
    id: number
    matricule: number
    nom: number
    prenom: number
    dateNaissance: number
    sexe: number
    email: number
    telephoneMobile: number
    telephoneFixe: number
    adresse: number
    ville: number
    codePostal: number
    centreId: number
    gradeId: number
    categorie: number
    dateEngagement: number
    dateFinEngagement: number
    statut: number
    password: number
    refreshToken: number
    lastLogin: number
    resetToken: number
    resetTokenExpires: number
    photoUrl: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PersonnelAvgAggregateInputType = {
    id?: true
    centreId?: true
    gradeId?: true
  }

  export type PersonnelSumAggregateInputType = {
    id?: true
    centreId?: true
    gradeId?: true
  }

  export type PersonnelMinAggregateInputType = {
    id?: true
    matricule?: true
    nom?: true
    prenom?: true
    dateNaissance?: true
    sexe?: true
    email?: true
    telephoneMobile?: true
    telephoneFixe?: true
    adresse?: true
    ville?: true
    codePostal?: true
    centreId?: true
    gradeId?: true
    categorie?: true
    dateEngagement?: true
    dateFinEngagement?: true
    statut?: true
    password?: true
    refreshToken?: true
    lastLogin?: true
    resetToken?: true
    resetTokenExpires?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PersonnelMaxAggregateInputType = {
    id?: true
    matricule?: true
    nom?: true
    prenom?: true
    dateNaissance?: true
    sexe?: true
    email?: true
    telephoneMobile?: true
    telephoneFixe?: true
    adresse?: true
    ville?: true
    codePostal?: true
    centreId?: true
    gradeId?: true
    categorie?: true
    dateEngagement?: true
    dateFinEngagement?: true
    statut?: true
    password?: true
    refreshToken?: true
    lastLogin?: true
    resetToken?: true
    resetTokenExpires?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PersonnelCountAggregateInputType = {
    id?: true
    matricule?: true
    nom?: true
    prenom?: true
    dateNaissance?: true
    sexe?: true
    email?: true
    telephoneMobile?: true
    telephoneFixe?: true
    adresse?: true
    ville?: true
    codePostal?: true
    centreId?: true
    gradeId?: true
    categorie?: true
    dateEngagement?: true
    dateFinEngagement?: true
    statut?: true
    password?: true
    refreshToken?: true
    lastLogin?: true
    resetToken?: true
    resetTokenExpires?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PersonnelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Personnel to aggregate.
     */
    where?: PersonnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnel to fetch.
     */
    orderBy?: PersonnelOrderByWithRelationInput | PersonnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnel from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnel.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Personnel
    **/
    _count?: true | PersonnelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonnelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonnelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonnelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonnelMaxAggregateInputType
  }

  export type GetPersonnelAggregateType<T extends PersonnelAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonnel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonnel[P]>
      : GetScalarType<T[P], AggregatePersonnel[P]>
  }




  export type PersonnelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnelWhereInput
    orderBy?: PersonnelOrderByWithAggregationInput | PersonnelOrderByWithAggregationInput[]
    by: PersonnelScalarFieldEnum[] | PersonnelScalarFieldEnum
    having?: PersonnelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonnelCountAggregateInputType | true
    _avg?: PersonnelAvgAggregateInputType
    _sum?: PersonnelSumAggregateInputType
    _min?: PersonnelMinAggregateInputType
    _max?: PersonnelMaxAggregateInputType
  }

  export type PersonnelGroupByOutputType = {
    id: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance: Date | null
    sexe: $Enums.Sexe | null
    email: string | null
    telephoneMobile: string | null
    telephoneFixe: string | null
    adresse: string | null
    ville: string | null
    codePostal: string | null
    centreId: number | null
    gradeId: number | null
    categorie: $Enums.Categorie
    dateEngagement: Date | null
    dateFinEngagement: Date | null
    statut: $Enums.StatutPersonnel
    password: string
    refreshToken: string | null
    lastLogin: Date | null
    resetToken: string | null
    resetTokenExpires: Date | null
    photoUrl: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PersonnelCountAggregateOutputType | null
    _avg: PersonnelAvgAggregateOutputType | null
    _sum: PersonnelSumAggregateOutputType | null
    _min: PersonnelMinAggregateOutputType | null
    _max: PersonnelMaxAggregateOutputType | null
  }

  type GetPersonnelGroupByPayload<T extends PersonnelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonnelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonnelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonnelGroupByOutputType[P]>
            : GetScalarType<T[P], PersonnelGroupByOutputType[P]>
        }
      >
    >


  export type PersonnelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matricule?: boolean
    nom?: boolean
    prenom?: boolean
    dateNaissance?: boolean
    sexe?: boolean
    email?: boolean
    telephoneMobile?: boolean
    telephoneFixe?: boolean
    adresse?: boolean
    ville?: boolean
    codePostal?: boolean
    centreId?: boolean
    gradeId?: boolean
    categorie?: boolean
    dateEngagement?: boolean
    dateFinEngagement?: boolean
    statut?: boolean
    password?: boolean
    refreshToken?: boolean
    lastLogin?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    centre?: boolean | Personnel$centreArgs<ExtArgs>
    grade?: boolean | Personnel$gradeArgs<ExtArgs>
    personnelRoles?: boolean | Personnel$personnelRolesArgs<ExtArgs>
    competences?: boolean | Personnel$competencesArgs<ExtArgs>
    aptitudesMedicales?: boolean | Personnel$aptitudesMedicalesArgs<ExtArgs>
    inscriptionsFMPA?: boolean | Personnel$inscriptionsFMPAArgs<ExtArgs>
    sessionsFMPAFormateur?: boolean | Personnel$sessionsFMPAFormateurArgs<ExtArgs>
    sessionsFMPAAdditionnels?: boolean | Personnel$sessionsFMPAAdditionnelsArgs<ExtArgs>
    signaturesFMPA?: boolean | Personnel$signaturesFMPAArgs<ExtArgs>
    epi?: boolean | Personnel$epiArgs<ExtArgs>
    materielsResponsable?: boolean | Personnel$materielsResponsableArgs<ExtArgs>
    incidentsSignales?: boolean | Personnel$incidentsSignalesArgs<ExtArgs>
    incidentsTraites?: boolean | Personnel$incidentsTraitesArgs<ExtArgs>
    conversationsCreees?: boolean | Personnel$conversationsCreeesArgs<ExtArgs>
    participations?: boolean | Personnel$participationsArgs<ExtArgs>
    messagesEnvoyes?: boolean | Personnel$messagesEnvoyesArgs<ExtArgs>
    messagesLus?: boolean | Personnel$messagesLusArgs<ExtArgs>
    notifications?: boolean | Personnel$notificationsArgs<ExtArgs>
    evenementsCreees?: boolean | Personnel$evenementsCreeesArgs<ExtArgs>
    participationsEvenements?: boolean | Personnel$participationsEvenementsArgs<ExtArgs>
    exportsTTAGeneres?: boolean | Personnel$exportsTTAGeneresArgs<ExtArgs>
    exportsTTAValides?: boolean | Personnel$exportsTTAValidesArgs<ExtArgs>
    auditLogs?: boolean | Personnel$auditLogsArgs<ExtArgs>
    _count?: boolean | PersonnelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnel"]>

  export type PersonnelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matricule?: boolean
    nom?: boolean
    prenom?: boolean
    dateNaissance?: boolean
    sexe?: boolean
    email?: boolean
    telephoneMobile?: boolean
    telephoneFixe?: boolean
    adresse?: boolean
    ville?: boolean
    codePostal?: boolean
    centreId?: boolean
    gradeId?: boolean
    categorie?: boolean
    dateEngagement?: boolean
    dateFinEngagement?: boolean
    statut?: boolean
    password?: boolean
    refreshToken?: boolean
    lastLogin?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    centre?: boolean | Personnel$centreArgs<ExtArgs>
    grade?: boolean | Personnel$gradeArgs<ExtArgs>
  }, ExtArgs["result"]["personnel"]>

  export type PersonnelSelectScalar = {
    id?: boolean
    matricule?: boolean
    nom?: boolean
    prenom?: boolean
    dateNaissance?: boolean
    sexe?: boolean
    email?: boolean
    telephoneMobile?: boolean
    telephoneFixe?: boolean
    adresse?: boolean
    ville?: boolean
    codePostal?: boolean
    centreId?: boolean
    gradeId?: boolean
    categorie?: boolean
    dateEngagement?: boolean
    dateFinEngagement?: boolean
    statut?: boolean
    password?: boolean
    refreshToken?: boolean
    lastLogin?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PersonnelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    centre?: boolean | Personnel$centreArgs<ExtArgs>
    grade?: boolean | Personnel$gradeArgs<ExtArgs>
    personnelRoles?: boolean | Personnel$personnelRolesArgs<ExtArgs>
    competences?: boolean | Personnel$competencesArgs<ExtArgs>
    aptitudesMedicales?: boolean | Personnel$aptitudesMedicalesArgs<ExtArgs>
    inscriptionsFMPA?: boolean | Personnel$inscriptionsFMPAArgs<ExtArgs>
    sessionsFMPAFormateur?: boolean | Personnel$sessionsFMPAFormateurArgs<ExtArgs>
    sessionsFMPAAdditionnels?: boolean | Personnel$sessionsFMPAAdditionnelsArgs<ExtArgs>
    signaturesFMPA?: boolean | Personnel$signaturesFMPAArgs<ExtArgs>
    epi?: boolean | Personnel$epiArgs<ExtArgs>
    materielsResponsable?: boolean | Personnel$materielsResponsableArgs<ExtArgs>
    incidentsSignales?: boolean | Personnel$incidentsSignalesArgs<ExtArgs>
    incidentsTraites?: boolean | Personnel$incidentsTraitesArgs<ExtArgs>
    conversationsCreees?: boolean | Personnel$conversationsCreeesArgs<ExtArgs>
    participations?: boolean | Personnel$participationsArgs<ExtArgs>
    messagesEnvoyes?: boolean | Personnel$messagesEnvoyesArgs<ExtArgs>
    messagesLus?: boolean | Personnel$messagesLusArgs<ExtArgs>
    notifications?: boolean | Personnel$notificationsArgs<ExtArgs>
    evenementsCreees?: boolean | Personnel$evenementsCreeesArgs<ExtArgs>
    participationsEvenements?: boolean | Personnel$participationsEvenementsArgs<ExtArgs>
    exportsTTAGeneres?: boolean | Personnel$exportsTTAGeneresArgs<ExtArgs>
    exportsTTAValides?: boolean | Personnel$exportsTTAValidesArgs<ExtArgs>
    auditLogs?: boolean | Personnel$auditLogsArgs<ExtArgs>
    _count?: boolean | PersonnelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonnelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    centre?: boolean | Personnel$centreArgs<ExtArgs>
    grade?: boolean | Personnel$gradeArgs<ExtArgs>
  }

  export type $PersonnelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Personnel"
    objects: {
      centre: Prisma.$CentrePayload<ExtArgs> | null
      grade: Prisma.$GradePayload<ExtArgs> | null
      personnelRoles: Prisma.$PersonnelRolePayload<ExtArgs>[]
      competences: Prisma.$PersonnelCompetencePayload<ExtArgs>[]
      aptitudesMedicales: Prisma.$AptitudeMedicalePayload<ExtArgs>[]
      inscriptionsFMPA: Prisma.$InscriptionFMPAPayload<ExtArgs>[]
      sessionsFMPAFormateur: Prisma.$SessionFMPAPayload<ExtArgs>[]
      sessionsFMPAAdditionnels: Prisma.$SessionFMPAFormateurPayload<ExtArgs>[]
      signaturesFMPA: Prisma.$SignatureFMPAPayload<ExtArgs>[]
      epi: Prisma.$EPIPayload<ExtArgs>[]
      materielsResponsable: Prisma.$MaterielPayload<ExtArgs>[]
      incidentsSignales: Prisma.$IncidentMaterielPayload<ExtArgs>[]
      incidentsTraites: Prisma.$IncidentMaterielPayload<ExtArgs>[]
      conversationsCreees: Prisma.$ConversationPayload<ExtArgs>[]
      participations: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      messagesEnvoyes: Prisma.$MessagePayload<ExtArgs>[]
      messagesLus: Prisma.$MessageLuPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      evenementsCreees: Prisma.$EvenementPayload<ExtArgs>[]
      participationsEvenements: Prisma.$EvenementParticipantPayload<ExtArgs>[]
      exportsTTAGeneres: Prisma.$ExportTTAPayload<ExtArgs>[]
      exportsTTAValides: Prisma.$ExportTTAPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      matricule: string
      nom: string
      prenom: string
      dateNaissance: Date | null
      sexe: $Enums.Sexe | null
      email: string | null
      telephoneMobile: string | null
      telephoneFixe: string | null
      adresse: string | null
      ville: string | null
      codePostal: string | null
      centreId: number | null
      gradeId: number | null
      categorie: $Enums.Categorie
      dateEngagement: Date | null
      dateFinEngagement: Date | null
      statut: $Enums.StatutPersonnel
      password: string
      refreshToken: string | null
      lastLogin: Date | null
      resetToken: string | null
      resetTokenExpires: Date | null
      photoUrl: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["personnel"]>
    composites: {}
  }

  type PersonnelGetPayload<S extends boolean | null | undefined | PersonnelDefaultArgs> = $Result.GetResult<Prisma.$PersonnelPayload, S>

  type PersonnelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonnelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonnelCountAggregateInputType | true
    }

  export interface PersonnelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Personnel'], meta: { name: 'Personnel' } }
    /**
     * Find zero or one Personnel that matches the filter.
     * @param {PersonnelFindUniqueArgs} args - Arguments to find a Personnel
     * @example
     * // Get one Personnel
     * const personnel = await prisma.personnel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonnelFindUniqueArgs>(args: SelectSubset<T, PersonnelFindUniqueArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Personnel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonnelFindUniqueOrThrowArgs} args - Arguments to find a Personnel
     * @example
     * // Get one Personnel
     * const personnel = await prisma.personnel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonnelFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonnelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Personnel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelFindFirstArgs} args - Arguments to find a Personnel
     * @example
     * // Get one Personnel
     * const personnel = await prisma.personnel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonnelFindFirstArgs>(args?: SelectSubset<T, PersonnelFindFirstArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Personnel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelFindFirstOrThrowArgs} args - Arguments to find a Personnel
     * @example
     * // Get one Personnel
     * const personnel = await prisma.personnel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonnelFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonnelFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Personnel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personnel
     * const personnel = await prisma.personnel.findMany()
     * 
     * // Get first 10 Personnel
     * const personnel = await prisma.personnel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personnelWithIdOnly = await prisma.personnel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonnelFindManyArgs>(args?: SelectSubset<T, PersonnelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Personnel.
     * @param {PersonnelCreateArgs} args - Arguments to create a Personnel.
     * @example
     * // Create one Personnel
     * const Personnel = await prisma.personnel.create({
     *   data: {
     *     // ... data to create a Personnel
     *   }
     * })
     * 
     */
    create<T extends PersonnelCreateArgs>(args: SelectSubset<T, PersonnelCreateArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Personnel.
     * @param {PersonnelCreateManyArgs} args - Arguments to create many Personnel.
     * @example
     * // Create many Personnel
     * const personnel = await prisma.personnel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonnelCreateManyArgs>(args?: SelectSubset<T, PersonnelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Personnel and returns the data saved in the database.
     * @param {PersonnelCreateManyAndReturnArgs} args - Arguments to create many Personnel.
     * @example
     * // Create many Personnel
     * const personnel = await prisma.personnel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Personnel and only return the `id`
     * const personnelWithIdOnly = await prisma.personnel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonnelCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonnelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Personnel.
     * @param {PersonnelDeleteArgs} args - Arguments to delete one Personnel.
     * @example
     * // Delete one Personnel
     * const Personnel = await prisma.personnel.delete({
     *   where: {
     *     // ... filter to delete one Personnel
     *   }
     * })
     * 
     */
    delete<T extends PersonnelDeleteArgs>(args: SelectSubset<T, PersonnelDeleteArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Personnel.
     * @param {PersonnelUpdateArgs} args - Arguments to update one Personnel.
     * @example
     * // Update one Personnel
     * const personnel = await prisma.personnel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonnelUpdateArgs>(args: SelectSubset<T, PersonnelUpdateArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Personnel.
     * @param {PersonnelDeleteManyArgs} args - Arguments to filter Personnel to delete.
     * @example
     * // Delete a few Personnel
     * const { count } = await prisma.personnel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonnelDeleteManyArgs>(args?: SelectSubset<T, PersonnelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personnel
     * const personnel = await prisma.personnel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonnelUpdateManyArgs>(args: SelectSubset<T, PersonnelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personnel.
     * @param {PersonnelUpsertArgs} args - Arguments to update or create a Personnel.
     * @example
     * // Update or create a Personnel
     * const personnel = await prisma.personnel.upsert({
     *   create: {
     *     // ... data to create a Personnel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personnel we want to update
     *   }
     * })
     */
    upsert<T extends PersonnelUpsertArgs>(args: SelectSubset<T, PersonnelUpsertArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Personnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelCountArgs} args - Arguments to filter Personnel to count.
     * @example
     * // Count the number of Personnel
     * const count = await prisma.personnel.count({
     *   where: {
     *     // ... the filter for the Personnel we want to count
     *   }
     * })
    **/
    count<T extends PersonnelCountArgs>(
      args?: Subset<T, PersonnelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonnelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonnelAggregateArgs>(args: Subset<T, PersonnelAggregateArgs>): Prisma.PrismaPromise<GetPersonnelAggregateType<T>>

    /**
     * Group by Personnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonnelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonnelGroupByArgs['orderBy'] }
        : { orderBy?: PersonnelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonnelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonnelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Personnel model
   */
  readonly fields: PersonnelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Personnel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonnelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    centre<T extends Personnel$centreArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$centreArgs<ExtArgs>>): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    grade<T extends Personnel$gradeArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$gradeArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    personnelRoles<T extends Personnel$personnelRolesArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$personnelRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelRolePayload<ExtArgs>, T, "findMany"> | Null>
    competences<T extends Personnel$competencesArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$competencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelCompetencePayload<ExtArgs>, T, "findMany"> | Null>
    aptitudesMedicales<T extends Personnel$aptitudesMedicalesArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$aptitudesMedicalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AptitudeMedicalePayload<ExtArgs>, T, "findMany"> | Null>
    inscriptionsFMPA<T extends Personnel$inscriptionsFMPAArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$inscriptionsFMPAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscriptionFMPAPayload<ExtArgs>, T, "findMany"> | Null>
    sessionsFMPAFormateur<T extends Personnel$sessionsFMPAFormateurArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$sessionsFMPAFormateurArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "findMany"> | Null>
    sessionsFMPAAdditionnels<T extends Personnel$sessionsFMPAAdditionnelsArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$sessionsFMPAAdditionnelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionFMPAFormateurPayload<ExtArgs>, T, "findMany"> | Null>
    signaturesFMPA<T extends Personnel$signaturesFMPAArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$signaturesFMPAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignatureFMPAPayload<ExtArgs>, T, "findMany"> | Null>
    epi<T extends Personnel$epiArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$epiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EPIPayload<ExtArgs>, T, "findMany"> | Null>
    materielsResponsable<T extends Personnel$materielsResponsableArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$materielsResponsableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findMany"> | Null>
    incidentsSignales<T extends Personnel$incidentsSignalesArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$incidentsSignalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentMaterielPayload<ExtArgs>, T, "findMany"> | Null>
    incidentsTraites<T extends Personnel$incidentsTraitesArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$incidentsTraitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentMaterielPayload<ExtArgs>, T, "findMany"> | Null>
    conversationsCreees<T extends Personnel$conversationsCreeesArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$conversationsCreeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany"> | Null>
    participations<T extends Personnel$participationsArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    messagesEnvoyes<T extends Personnel$messagesEnvoyesArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$messagesEnvoyesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    messagesLus<T extends Personnel$messagesLusArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$messagesLusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLuPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Personnel$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    evenementsCreees<T extends Personnel$evenementsCreeesArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$evenementsCreeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "findMany"> | Null>
    participationsEvenements<T extends Personnel$participationsEvenementsArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$participationsEvenementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    exportsTTAGeneres<T extends Personnel$exportsTTAGeneresArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$exportsTTAGeneresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportTTAPayload<ExtArgs>, T, "findMany"> | Null>
    exportsTTAValides<T extends Personnel$exportsTTAValidesArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$exportsTTAValidesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportTTAPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Personnel$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Personnel$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Personnel model
   */ 
  interface PersonnelFieldRefs {
    readonly id: FieldRef<"Personnel", 'Int'>
    readonly matricule: FieldRef<"Personnel", 'String'>
    readonly nom: FieldRef<"Personnel", 'String'>
    readonly prenom: FieldRef<"Personnel", 'String'>
    readonly dateNaissance: FieldRef<"Personnel", 'DateTime'>
    readonly sexe: FieldRef<"Personnel", 'Sexe'>
    readonly email: FieldRef<"Personnel", 'String'>
    readonly telephoneMobile: FieldRef<"Personnel", 'String'>
    readonly telephoneFixe: FieldRef<"Personnel", 'String'>
    readonly adresse: FieldRef<"Personnel", 'String'>
    readonly ville: FieldRef<"Personnel", 'String'>
    readonly codePostal: FieldRef<"Personnel", 'String'>
    readonly centreId: FieldRef<"Personnel", 'Int'>
    readonly gradeId: FieldRef<"Personnel", 'Int'>
    readonly categorie: FieldRef<"Personnel", 'Categorie'>
    readonly dateEngagement: FieldRef<"Personnel", 'DateTime'>
    readonly dateFinEngagement: FieldRef<"Personnel", 'DateTime'>
    readonly statut: FieldRef<"Personnel", 'StatutPersonnel'>
    readonly password: FieldRef<"Personnel", 'String'>
    readonly refreshToken: FieldRef<"Personnel", 'String'>
    readonly lastLogin: FieldRef<"Personnel", 'DateTime'>
    readonly resetToken: FieldRef<"Personnel", 'String'>
    readonly resetTokenExpires: FieldRef<"Personnel", 'DateTime'>
    readonly photoUrl: FieldRef<"Personnel", 'String'>
    readonly createdAt: FieldRef<"Personnel", 'DateTime'>
    readonly updatedAt: FieldRef<"Personnel", 'DateTime'>
    readonly deletedAt: FieldRef<"Personnel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Personnel findUnique
   */
  export type PersonnelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * Filter, which Personnel to fetch.
     */
    where: PersonnelWhereUniqueInput
  }

  /**
   * Personnel findUniqueOrThrow
   */
  export type PersonnelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * Filter, which Personnel to fetch.
     */
    where: PersonnelWhereUniqueInput
  }

  /**
   * Personnel findFirst
   */
  export type PersonnelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * Filter, which Personnel to fetch.
     */
    where?: PersonnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnel to fetch.
     */
    orderBy?: PersonnelOrderByWithRelationInput | PersonnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personnel.
     */
    cursor?: PersonnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnel from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnel.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personnel.
     */
    distinct?: PersonnelScalarFieldEnum | PersonnelScalarFieldEnum[]
  }

  /**
   * Personnel findFirstOrThrow
   */
  export type PersonnelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * Filter, which Personnel to fetch.
     */
    where?: PersonnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnel to fetch.
     */
    orderBy?: PersonnelOrderByWithRelationInput | PersonnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personnel.
     */
    cursor?: PersonnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnel from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnel.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personnel.
     */
    distinct?: PersonnelScalarFieldEnum | PersonnelScalarFieldEnum[]
  }

  /**
   * Personnel findMany
   */
  export type PersonnelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * Filter, which Personnel to fetch.
     */
    where?: PersonnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personnel to fetch.
     */
    orderBy?: PersonnelOrderByWithRelationInput | PersonnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Personnel.
     */
    cursor?: PersonnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personnel from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personnel.
     */
    skip?: number
    distinct?: PersonnelScalarFieldEnum | PersonnelScalarFieldEnum[]
  }

  /**
   * Personnel create
   */
  export type PersonnelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * The data needed to create a Personnel.
     */
    data: XOR<PersonnelCreateInput, PersonnelUncheckedCreateInput>
  }

  /**
   * Personnel createMany
   */
  export type PersonnelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Personnel.
     */
    data: PersonnelCreateManyInput | PersonnelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Personnel createManyAndReturn
   */
  export type PersonnelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Personnel.
     */
    data: PersonnelCreateManyInput | PersonnelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Personnel update
   */
  export type PersonnelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * The data needed to update a Personnel.
     */
    data: XOR<PersonnelUpdateInput, PersonnelUncheckedUpdateInput>
    /**
     * Choose, which Personnel to update.
     */
    where: PersonnelWhereUniqueInput
  }

  /**
   * Personnel updateMany
   */
  export type PersonnelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Personnel.
     */
    data: XOR<PersonnelUpdateManyMutationInput, PersonnelUncheckedUpdateManyInput>
    /**
     * Filter which Personnel to update
     */
    where?: PersonnelWhereInput
  }

  /**
   * Personnel upsert
   */
  export type PersonnelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * The filter to search for the Personnel to update in case it exists.
     */
    where: PersonnelWhereUniqueInput
    /**
     * In case the Personnel found by the `where` argument doesn't exist, create a new Personnel with this data.
     */
    create: XOR<PersonnelCreateInput, PersonnelUncheckedCreateInput>
    /**
     * In case the Personnel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonnelUpdateInput, PersonnelUncheckedUpdateInput>
  }

  /**
   * Personnel delete
   */
  export type PersonnelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    /**
     * Filter which Personnel to delete.
     */
    where: PersonnelWhereUniqueInput
  }

  /**
   * Personnel deleteMany
   */
  export type PersonnelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Personnel to delete
     */
    where?: PersonnelWhereInput
  }

  /**
   * Personnel.centre
   */
  export type Personnel$centreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
    where?: CentreWhereInput
  }

  /**
   * Personnel.grade
   */
  export type Personnel$gradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
  }

  /**
   * Personnel.personnelRoles
   */
  export type Personnel$personnelRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelRole
     */
    select?: PersonnelRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelRoleInclude<ExtArgs> | null
    where?: PersonnelRoleWhereInput
    orderBy?: PersonnelRoleOrderByWithRelationInput | PersonnelRoleOrderByWithRelationInput[]
    cursor?: PersonnelRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnelRoleScalarFieldEnum | PersonnelRoleScalarFieldEnum[]
  }

  /**
   * Personnel.competences
   */
  export type Personnel$competencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCompetence
     */
    select?: PersonnelCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelCompetenceInclude<ExtArgs> | null
    where?: PersonnelCompetenceWhereInput
    orderBy?: PersonnelCompetenceOrderByWithRelationInput | PersonnelCompetenceOrderByWithRelationInput[]
    cursor?: PersonnelCompetenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnelCompetenceScalarFieldEnum | PersonnelCompetenceScalarFieldEnum[]
  }

  /**
   * Personnel.aptitudesMedicales
   */
  export type Personnel$aptitudesMedicalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AptitudeMedicale
     */
    select?: AptitudeMedicaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AptitudeMedicaleInclude<ExtArgs> | null
    where?: AptitudeMedicaleWhereInput
    orderBy?: AptitudeMedicaleOrderByWithRelationInput | AptitudeMedicaleOrderByWithRelationInput[]
    cursor?: AptitudeMedicaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AptitudeMedicaleScalarFieldEnum | AptitudeMedicaleScalarFieldEnum[]
  }

  /**
   * Personnel.inscriptionsFMPA
   */
  export type Personnel$inscriptionsFMPAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InscriptionFMPA
     */
    select?: InscriptionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscriptionFMPAInclude<ExtArgs> | null
    where?: InscriptionFMPAWhereInput
    orderBy?: InscriptionFMPAOrderByWithRelationInput | InscriptionFMPAOrderByWithRelationInput[]
    cursor?: InscriptionFMPAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscriptionFMPAScalarFieldEnum | InscriptionFMPAScalarFieldEnum[]
  }

  /**
   * Personnel.sessionsFMPAFormateur
   */
  export type Personnel$sessionsFMPAFormateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAInclude<ExtArgs> | null
    where?: SessionFMPAWhereInput
    orderBy?: SessionFMPAOrderByWithRelationInput | SessionFMPAOrderByWithRelationInput[]
    cursor?: SessionFMPAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionFMPAScalarFieldEnum | SessionFMPAScalarFieldEnum[]
  }

  /**
   * Personnel.sessionsFMPAAdditionnels
   */
  export type Personnel$sessionsFMPAAdditionnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPAFormateur
     */
    select?: SessionFMPAFormateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAFormateurInclude<ExtArgs> | null
    where?: SessionFMPAFormateurWhereInput
    orderBy?: SessionFMPAFormateurOrderByWithRelationInput | SessionFMPAFormateurOrderByWithRelationInput[]
    cursor?: SessionFMPAFormateurWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionFMPAFormateurScalarFieldEnum | SessionFMPAFormateurScalarFieldEnum[]
  }

  /**
   * Personnel.signaturesFMPA
   */
  export type Personnel$signaturesFMPAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignatureFMPA
     */
    select?: SignatureFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureFMPAInclude<ExtArgs> | null
    where?: SignatureFMPAWhereInput
    orderBy?: SignatureFMPAOrderByWithRelationInput | SignatureFMPAOrderByWithRelationInput[]
    cursor?: SignatureFMPAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignatureFMPAScalarFieldEnum | SignatureFMPAScalarFieldEnum[]
  }

  /**
   * Personnel.epi
   */
  export type Personnel$epiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EPI
     */
    select?: EPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EPIInclude<ExtArgs> | null
    where?: EPIWhereInput
    orderBy?: EPIOrderByWithRelationInput | EPIOrderByWithRelationInput[]
    cursor?: EPIWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EPIScalarFieldEnum | EPIScalarFieldEnum[]
  }

  /**
   * Personnel.materielsResponsable
   */
  export type Personnel$materielsResponsableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    where?: MaterielWhereInput
    orderBy?: MaterielOrderByWithRelationInput | MaterielOrderByWithRelationInput[]
    cursor?: MaterielWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterielScalarFieldEnum | MaterielScalarFieldEnum[]
  }

  /**
   * Personnel.incidentsSignales
   */
  export type Personnel$incidentsSignalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentMateriel
     */
    select?: IncidentMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentMaterielInclude<ExtArgs> | null
    where?: IncidentMaterielWhereInput
    orderBy?: IncidentMaterielOrderByWithRelationInput | IncidentMaterielOrderByWithRelationInput[]
    cursor?: IncidentMaterielWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentMaterielScalarFieldEnum | IncidentMaterielScalarFieldEnum[]
  }

  /**
   * Personnel.incidentsTraites
   */
  export type Personnel$incidentsTraitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentMateriel
     */
    select?: IncidentMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentMaterielInclude<ExtArgs> | null
    where?: IncidentMaterielWhereInput
    orderBy?: IncidentMaterielOrderByWithRelationInput | IncidentMaterielOrderByWithRelationInput[]
    cursor?: IncidentMaterielWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentMaterielScalarFieldEnum | IncidentMaterielScalarFieldEnum[]
  }

  /**
   * Personnel.conversationsCreees
   */
  export type Personnel$conversationsCreeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Personnel.participations
   */
  export type Personnel$participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * Personnel.messagesEnvoyes
   */
  export type Personnel$messagesEnvoyesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Personnel.messagesLus
   */
  export type Personnel$messagesLusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLu
     */
    select?: MessageLuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLuInclude<ExtArgs> | null
    where?: MessageLuWhereInput
    orderBy?: MessageLuOrderByWithRelationInput | MessageLuOrderByWithRelationInput[]
    cursor?: MessageLuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageLuScalarFieldEnum | MessageLuScalarFieldEnum[]
  }

  /**
   * Personnel.notifications
   */
  export type Personnel$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Personnel.evenementsCreees
   */
  export type Personnel$evenementsCreeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    where?: EvenementWhereInput
    orderBy?: EvenementOrderByWithRelationInput | EvenementOrderByWithRelationInput[]
    cursor?: EvenementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvenementScalarFieldEnum | EvenementScalarFieldEnum[]
  }

  /**
   * Personnel.participationsEvenements
   */
  export type Personnel$participationsEvenementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementParticipant
     */
    select?: EvenementParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementParticipantInclude<ExtArgs> | null
    where?: EvenementParticipantWhereInput
    orderBy?: EvenementParticipantOrderByWithRelationInput | EvenementParticipantOrderByWithRelationInput[]
    cursor?: EvenementParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvenementParticipantScalarFieldEnum | EvenementParticipantScalarFieldEnum[]
  }

  /**
   * Personnel.exportsTTAGeneres
   */
  export type Personnel$exportsTTAGeneresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAInclude<ExtArgs> | null
    where?: ExportTTAWhereInput
    orderBy?: ExportTTAOrderByWithRelationInput | ExportTTAOrderByWithRelationInput[]
    cursor?: ExportTTAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExportTTAScalarFieldEnum | ExportTTAScalarFieldEnum[]
  }

  /**
   * Personnel.exportsTTAValides
   */
  export type Personnel$exportsTTAValidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAInclude<ExtArgs> | null
    where?: ExportTTAWhereInput
    orderBy?: ExportTTAOrderByWithRelationInput | ExportTTAOrderByWithRelationInput[]
    cursor?: ExportTTAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExportTTAScalarFieldEnum | ExportTTAScalarFieldEnum[]
  }

  /**
   * Personnel.auditLogs
   */
  export type Personnel$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Personnel without action
   */
  export type PersonnelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    code: string | null
    libelle: string | null
    description: string | null
    actif: boolean | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    code: string | null
    libelle: string | null
    description: string | null
    actif: boolean | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    code: number
    libelle: number
    description: number
    permissions: number
    actif: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    description?: true
    actif?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    description?: true
    actif?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    description?: true
    permissions?: true
    actif?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    code: string
    libelle: string
    description: string | null
    permissions: JsonValue
    actif: boolean
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    description?: boolean
    permissions?: boolean
    actif?: boolean
    personnels?: boolean | Role$personnelsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    description?: boolean
    permissions?: boolean
    actif?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    code?: boolean
    libelle?: boolean
    description?: boolean
    permissions?: boolean
    actif?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnels?: boolean | Role$personnelsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      personnels: Prisma.$PersonnelRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      libelle: string
      description: string | null
      permissions: Prisma.JsonValue
      actif: boolean
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnels<T extends Role$personnelsArgs<ExtArgs> = {}>(args?: Subset<T, Role$personnelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly code: FieldRef<"Role", 'String'>
    readonly libelle: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly permissions: FieldRef<"Role", 'Json'>
    readonly actif: FieldRef<"Role", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.personnels
   */
  export type Role$personnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelRole
     */
    select?: PersonnelRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelRoleInclude<ExtArgs> | null
    where?: PersonnelRoleWhereInput
    orderBy?: PersonnelRoleOrderByWithRelationInput | PersonnelRoleOrderByWithRelationInput[]
    cursor?: PersonnelRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnelRoleScalarFieldEnum | PersonnelRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model PersonnelRole
   */

  export type AggregatePersonnelRole = {
    _count: PersonnelRoleCountAggregateOutputType | null
    _avg: PersonnelRoleAvgAggregateOutputType | null
    _sum: PersonnelRoleSumAggregateOutputType | null
    _min: PersonnelRoleMinAggregateOutputType | null
    _max: PersonnelRoleMaxAggregateOutputType | null
  }

  export type PersonnelRoleAvgAggregateOutputType = {
    personnelId: number | null
    roleId: number | null
  }

  export type PersonnelRoleSumAggregateOutputType = {
    personnelId: number | null
    roleId: number | null
  }

  export type PersonnelRoleMinAggregateOutputType = {
    personnelId: number | null
    roleId: number | null
    dateAttribution: Date | null
    dateFin: Date | null
  }

  export type PersonnelRoleMaxAggregateOutputType = {
    personnelId: number | null
    roleId: number | null
    dateAttribution: Date | null
    dateFin: Date | null
  }

  export type PersonnelRoleCountAggregateOutputType = {
    personnelId: number
    roleId: number
    dateAttribution: number
    dateFin: number
    _all: number
  }


  export type PersonnelRoleAvgAggregateInputType = {
    personnelId?: true
    roleId?: true
  }

  export type PersonnelRoleSumAggregateInputType = {
    personnelId?: true
    roleId?: true
  }

  export type PersonnelRoleMinAggregateInputType = {
    personnelId?: true
    roleId?: true
    dateAttribution?: true
    dateFin?: true
  }

  export type PersonnelRoleMaxAggregateInputType = {
    personnelId?: true
    roleId?: true
    dateAttribution?: true
    dateFin?: true
  }

  export type PersonnelRoleCountAggregateInputType = {
    personnelId?: true
    roleId?: true
    dateAttribution?: true
    dateFin?: true
    _all?: true
  }

  export type PersonnelRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonnelRole to aggregate.
     */
    where?: PersonnelRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnelRoles to fetch.
     */
    orderBy?: PersonnelRoleOrderByWithRelationInput | PersonnelRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonnelRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnelRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnelRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonnelRoles
    **/
    _count?: true | PersonnelRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonnelRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonnelRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonnelRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonnelRoleMaxAggregateInputType
  }

  export type GetPersonnelRoleAggregateType<T extends PersonnelRoleAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonnelRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonnelRole[P]>
      : GetScalarType<T[P], AggregatePersonnelRole[P]>
  }




  export type PersonnelRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnelRoleWhereInput
    orderBy?: PersonnelRoleOrderByWithAggregationInput | PersonnelRoleOrderByWithAggregationInput[]
    by: PersonnelRoleScalarFieldEnum[] | PersonnelRoleScalarFieldEnum
    having?: PersonnelRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonnelRoleCountAggregateInputType | true
    _avg?: PersonnelRoleAvgAggregateInputType
    _sum?: PersonnelRoleSumAggregateInputType
    _min?: PersonnelRoleMinAggregateInputType
    _max?: PersonnelRoleMaxAggregateInputType
  }

  export type PersonnelRoleGroupByOutputType = {
    personnelId: number
    roleId: number
    dateAttribution: Date
    dateFin: Date | null
    _count: PersonnelRoleCountAggregateOutputType | null
    _avg: PersonnelRoleAvgAggregateOutputType | null
    _sum: PersonnelRoleSumAggregateOutputType | null
    _min: PersonnelRoleMinAggregateOutputType | null
    _max: PersonnelRoleMaxAggregateOutputType | null
  }

  type GetPersonnelRoleGroupByPayload<T extends PersonnelRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonnelRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonnelRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonnelRoleGroupByOutputType[P]>
            : GetScalarType<T[P], PersonnelRoleGroupByOutputType[P]>
        }
      >
    >


  export type PersonnelRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personnelId?: boolean
    roleId?: boolean
    dateAttribution?: boolean
    dateFin?: boolean
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnelRole"]>

  export type PersonnelRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personnelId?: boolean
    roleId?: boolean
    dateAttribution?: boolean
    dateFin?: boolean
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnelRole"]>

  export type PersonnelRoleSelectScalar = {
    personnelId?: boolean
    roleId?: boolean
    dateAttribution?: boolean
    dateFin?: boolean
  }

  export type PersonnelRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type PersonnelRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $PersonnelRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonnelRole"
    objects: {
      personnel: Prisma.$PersonnelPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      personnelId: number
      roleId: number
      dateAttribution: Date
      dateFin: Date | null
    }, ExtArgs["result"]["personnelRole"]>
    composites: {}
  }

  type PersonnelRoleGetPayload<S extends boolean | null | undefined | PersonnelRoleDefaultArgs> = $Result.GetResult<Prisma.$PersonnelRolePayload, S>

  type PersonnelRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonnelRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonnelRoleCountAggregateInputType | true
    }

  export interface PersonnelRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonnelRole'], meta: { name: 'PersonnelRole' } }
    /**
     * Find zero or one PersonnelRole that matches the filter.
     * @param {PersonnelRoleFindUniqueArgs} args - Arguments to find a PersonnelRole
     * @example
     * // Get one PersonnelRole
     * const personnelRole = await prisma.personnelRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonnelRoleFindUniqueArgs>(args: SelectSubset<T, PersonnelRoleFindUniqueArgs<ExtArgs>>): Prisma__PersonnelRoleClient<$Result.GetResult<Prisma.$PersonnelRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PersonnelRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonnelRoleFindUniqueOrThrowArgs} args - Arguments to find a PersonnelRole
     * @example
     * // Get one PersonnelRole
     * const personnelRole = await prisma.personnelRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonnelRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonnelRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonnelRoleClient<$Result.GetResult<Prisma.$PersonnelRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PersonnelRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelRoleFindFirstArgs} args - Arguments to find a PersonnelRole
     * @example
     * // Get one PersonnelRole
     * const personnelRole = await prisma.personnelRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonnelRoleFindFirstArgs>(args?: SelectSubset<T, PersonnelRoleFindFirstArgs<ExtArgs>>): Prisma__PersonnelRoleClient<$Result.GetResult<Prisma.$PersonnelRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PersonnelRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelRoleFindFirstOrThrowArgs} args - Arguments to find a PersonnelRole
     * @example
     * // Get one PersonnelRole
     * const personnelRole = await prisma.personnelRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonnelRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonnelRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonnelRoleClient<$Result.GetResult<Prisma.$PersonnelRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PersonnelRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonnelRoles
     * const personnelRoles = await prisma.personnelRole.findMany()
     * 
     * // Get first 10 PersonnelRoles
     * const personnelRoles = await prisma.personnelRole.findMany({ take: 10 })
     * 
     * // Only select the `personnelId`
     * const personnelRoleWithPersonnelIdOnly = await prisma.personnelRole.findMany({ select: { personnelId: true } })
     * 
     */
    findMany<T extends PersonnelRoleFindManyArgs>(args?: SelectSubset<T, PersonnelRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PersonnelRole.
     * @param {PersonnelRoleCreateArgs} args - Arguments to create a PersonnelRole.
     * @example
     * // Create one PersonnelRole
     * const PersonnelRole = await prisma.personnelRole.create({
     *   data: {
     *     // ... data to create a PersonnelRole
     *   }
     * })
     * 
     */
    create<T extends PersonnelRoleCreateArgs>(args: SelectSubset<T, PersonnelRoleCreateArgs<ExtArgs>>): Prisma__PersonnelRoleClient<$Result.GetResult<Prisma.$PersonnelRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PersonnelRoles.
     * @param {PersonnelRoleCreateManyArgs} args - Arguments to create many PersonnelRoles.
     * @example
     * // Create many PersonnelRoles
     * const personnelRole = await prisma.personnelRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonnelRoleCreateManyArgs>(args?: SelectSubset<T, PersonnelRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonnelRoles and returns the data saved in the database.
     * @param {PersonnelRoleCreateManyAndReturnArgs} args - Arguments to create many PersonnelRoles.
     * @example
     * // Create many PersonnelRoles
     * const personnelRole = await prisma.personnelRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonnelRoles and only return the `personnelId`
     * const personnelRoleWithPersonnelIdOnly = await prisma.personnelRole.createManyAndReturn({ 
     *   select: { personnelId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonnelRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonnelRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PersonnelRole.
     * @param {PersonnelRoleDeleteArgs} args - Arguments to delete one PersonnelRole.
     * @example
     * // Delete one PersonnelRole
     * const PersonnelRole = await prisma.personnelRole.delete({
     *   where: {
     *     // ... filter to delete one PersonnelRole
     *   }
     * })
     * 
     */
    delete<T extends PersonnelRoleDeleteArgs>(args: SelectSubset<T, PersonnelRoleDeleteArgs<ExtArgs>>): Prisma__PersonnelRoleClient<$Result.GetResult<Prisma.$PersonnelRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PersonnelRole.
     * @param {PersonnelRoleUpdateArgs} args - Arguments to update one PersonnelRole.
     * @example
     * // Update one PersonnelRole
     * const personnelRole = await prisma.personnelRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonnelRoleUpdateArgs>(args: SelectSubset<T, PersonnelRoleUpdateArgs<ExtArgs>>): Prisma__PersonnelRoleClient<$Result.GetResult<Prisma.$PersonnelRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PersonnelRoles.
     * @param {PersonnelRoleDeleteManyArgs} args - Arguments to filter PersonnelRoles to delete.
     * @example
     * // Delete a few PersonnelRoles
     * const { count } = await prisma.personnelRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonnelRoleDeleteManyArgs>(args?: SelectSubset<T, PersonnelRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonnelRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonnelRoles
     * const personnelRole = await prisma.personnelRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonnelRoleUpdateManyArgs>(args: SelectSubset<T, PersonnelRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonnelRole.
     * @param {PersonnelRoleUpsertArgs} args - Arguments to update or create a PersonnelRole.
     * @example
     * // Update or create a PersonnelRole
     * const personnelRole = await prisma.personnelRole.upsert({
     *   create: {
     *     // ... data to create a PersonnelRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonnelRole we want to update
     *   }
     * })
     */
    upsert<T extends PersonnelRoleUpsertArgs>(args: SelectSubset<T, PersonnelRoleUpsertArgs<ExtArgs>>): Prisma__PersonnelRoleClient<$Result.GetResult<Prisma.$PersonnelRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PersonnelRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelRoleCountArgs} args - Arguments to filter PersonnelRoles to count.
     * @example
     * // Count the number of PersonnelRoles
     * const count = await prisma.personnelRole.count({
     *   where: {
     *     // ... the filter for the PersonnelRoles we want to count
     *   }
     * })
    **/
    count<T extends PersonnelRoleCountArgs>(
      args?: Subset<T, PersonnelRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonnelRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonnelRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonnelRoleAggregateArgs>(args: Subset<T, PersonnelRoleAggregateArgs>): Prisma.PrismaPromise<GetPersonnelRoleAggregateType<T>>

    /**
     * Group by PersonnelRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonnelRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonnelRoleGroupByArgs['orderBy'] }
        : { orderBy?: PersonnelRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonnelRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonnelRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonnelRole model
   */
  readonly fields: PersonnelRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonnelRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonnelRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnel<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonnelRole model
   */ 
  interface PersonnelRoleFieldRefs {
    readonly personnelId: FieldRef<"PersonnelRole", 'Int'>
    readonly roleId: FieldRef<"PersonnelRole", 'Int'>
    readonly dateAttribution: FieldRef<"PersonnelRole", 'DateTime'>
    readonly dateFin: FieldRef<"PersonnelRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PersonnelRole findUnique
   */
  export type PersonnelRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelRole
     */
    select?: PersonnelRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelRoleInclude<ExtArgs> | null
    /**
     * Filter, which PersonnelRole to fetch.
     */
    where: PersonnelRoleWhereUniqueInput
  }

  /**
   * PersonnelRole findUniqueOrThrow
   */
  export type PersonnelRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelRole
     */
    select?: PersonnelRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelRoleInclude<ExtArgs> | null
    /**
     * Filter, which PersonnelRole to fetch.
     */
    where: PersonnelRoleWhereUniqueInput
  }

  /**
   * PersonnelRole findFirst
   */
  export type PersonnelRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelRole
     */
    select?: PersonnelRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelRoleInclude<ExtArgs> | null
    /**
     * Filter, which PersonnelRole to fetch.
     */
    where?: PersonnelRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnelRoles to fetch.
     */
    orderBy?: PersonnelRoleOrderByWithRelationInput | PersonnelRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonnelRoles.
     */
    cursor?: PersonnelRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnelRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnelRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonnelRoles.
     */
    distinct?: PersonnelRoleScalarFieldEnum | PersonnelRoleScalarFieldEnum[]
  }

  /**
   * PersonnelRole findFirstOrThrow
   */
  export type PersonnelRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelRole
     */
    select?: PersonnelRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelRoleInclude<ExtArgs> | null
    /**
     * Filter, which PersonnelRole to fetch.
     */
    where?: PersonnelRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnelRoles to fetch.
     */
    orderBy?: PersonnelRoleOrderByWithRelationInput | PersonnelRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonnelRoles.
     */
    cursor?: PersonnelRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnelRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnelRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonnelRoles.
     */
    distinct?: PersonnelRoleScalarFieldEnum | PersonnelRoleScalarFieldEnum[]
  }

  /**
   * PersonnelRole findMany
   */
  export type PersonnelRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelRole
     */
    select?: PersonnelRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelRoleInclude<ExtArgs> | null
    /**
     * Filter, which PersonnelRoles to fetch.
     */
    where?: PersonnelRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnelRoles to fetch.
     */
    orderBy?: PersonnelRoleOrderByWithRelationInput | PersonnelRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonnelRoles.
     */
    cursor?: PersonnelRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnelRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnelRoles.
     */
    skip?: number
    distinct?: PersonnelRoleScalarFieldEnum | PersonnelRoleScalarFieldEnum[]
  }

  /**
   * PersonnelRole create
   */
  export type PersonnelRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelRole
     */
    select?: PersonnelRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonnelRole.
     */
    data: XOR<PersonnelRoleCreateInput, PersonnelRoleUncheckedCreateInput>
  }

  /**
   * PersonnelRole createMany
   */
  export type PersonnelRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonnelRoles.
     */
    data: PersonnelRoleCreateManyInput | PersonnelRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonnelRole createManyAndReturn
   */
  export type PersonnelRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelRole
     */
    select?: PersonnelRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PersonnelRoles.
     */
    data: PersonnelRoleCreateManyInput | PersonnelRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonnelRole update
   */
  export type PersonnelRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelRole
     */
    select?: PersonnelRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonnelRole.
     */
    data: XOR<PersonnelRoleUpdateInput, PersonnelRoleUncheckedUpdateInput>
    /**
     * Choose, which PersonnelRole to update.
     */
    where: PersonnelRoleWhereUniqueInput
  }

  /**
   * PersonnelRole updateMany
   */
  export type PersonnelRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonnelRoles.
     */
    data: XOR<PersonnelRoleUpdateManyMutationInput, PersonnelRoleUncheckedUpdateManyInput>
    /**
     * Filter which PersonnelRoles to update
     */
    where?: PersonnelRoleWhereInput
  }

  /**
   * PersonnelRole upsert
   */
  export type PersonnelRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelRole
     */
    select?: PersonnelRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonnelRole to update in case it exists.
     */
    where: PersonnelRoleWhereUniqueInput
    /**
     * In case the PersonnelRole found by the `where` argument doesn't exist, create a new PersonnelRole with this data.
     */
    create: XOR<PersonnelRoleCreateInput, PersonnelRoleUncheckedCreateInput>
    /**
     * In case the PersonnelRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonnelRoleUpdateInput, PersonnelRoleUncheckedUpdateInput>
  }

  /**
   * PersonnelRole delete
   */
  export type PersonnelRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelRole
     */
    select?: PersonnelRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelRoleInclude<ExtArgs> | null
    /**
     * Filter which PersonnelRole to delete.
     */
    where: PersonnelRoleWhereUniqueInput
  }

  /**
   * PersonnelRole deleteMany
   */
  export type PersonnelRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonnelRoles to delete
     */
    where?: PersonnelRoleWhereInput
  }

  /**
   * PersonnelRole without action
   */
  export type PersonnelRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelRole
     */
    select?: PersonnelRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelRoleInclude<ExtArgs> | null
  }


  /**
   * Model TypeCompetence
   */

  export type AggregateTypeCompetence = {
    _count: TypeCompetenceCountAggregateOutputType | null
    _avg: TypeCompetenceAvgAggregateOutputType | null
    _sum: TypeCompetenceSumAggregateOutputType | null
    _min: TypeCompetenceMinAggregateOutputType | null
    _max: TypeCompetenceMaxAggregateOutputType | null
  }

  export type TypeCompetenceAvgAggregateOutputType = {
    id: number | null
    dureeValiditeMois: number | null
  }

  export type TypeCompetenceSumAggregateOutputType = {
    id: number | null
    dureeValiditeMois: number | null
  }

  export type TypeCompetenceMinAggregateOutputType = {
    id: number | null
    code: string | null
    libelle: string | null
    description: string | null
    dureeValiditeMois: number | null
    actif: boolean | null
  }

  export type TypeCompetenceMaxAggregateOutputType = {
    id: number | null
    code: string | null
    libelle: string | null
    description: string | null
    dureeValiditeMois: number | null
    actif: boolean | null
  }

  export type TypeCompetenceCountAggregateOutputType = {
    id: number
    code: number
    libelle: number
    description: number
    dureeValiditeMois: number
    actif: number
    _all: number
  }


  export type TypeCompetenceAvgAggregateInputType = {
    id?: true
    dureeValiditeMois?: true
  }

  export type TypeCompetenceSumAggregateInputType = {
    id?: true
    dureeValiditeMois?: true
  }

  export type TypeCompetenceMinAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    description?: true
    dureeValiditeMois?: true
    actif?: true
  }

  export type TypeCompetenceMaxAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    description?: true
    dureeValiditeMois?: true
    actif?: true
  }

  export type TypeCompetenceCountAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    description?: true
    dureeValiditeMois?: true
    actif?: true
    _all?: true
  }

  export type TypeCompetenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypeCompetence to aggregate.
     */
    where?: TypeCompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeCompetences to fetch.
     */
    orderBy?: TypeCompetenceOrderByWithRelationInput | TypeCompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypeCompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeCompetences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeCompetences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypeCompetences
    **/
    _count?: true | TypeCompetenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypeCompetenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypeCompetenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeCompetenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeCompetenceMaxAggregateInputType
  }

  export type GetTypeCompetenceAggregateType<T extends TypeCompetenceAggregateArgs> = {
        [P in keyof T & keyof AggregateTypeCompetence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypeCompetence[P]>
      : GetScalarType<T[P], AggregateTypeCompetence[P]>
  }




  export type TypeCompetenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypeCompetenceWhereInput
    orderBy?: TypeCompetenceOrderByWithAggregationInput | TypeCompetenceOrderByWithAggregationInput[]
    by: TypeCompetenceScalarFieldEnum[] | TypeCompetenceScalarFieldEnum
    having?: TypeCompetenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeCompetenceCountAggregateInputType | true
    _avg?: TypeCompetenceAvgAggregateInputType
    _sum?: TypeCompetenceSumAggregateInputType
    _min?: TypeCompetenceMinAggregateInputType
    _max?: TypeCompetenceMaxAggregateInputType
  }

  export type TypeCompetenceGroupByOutputType = {
    id: number
    code: string
    libelle: string
    description: string | null
    dureeValiditeMois: number | null
    actif: boolean
    _count: TypeCompetenceCountAggregateOutputType | null
    _avg: TypeCompetenceAvgAggregateOutputType | null
    _sum: TypeCompetenceSumAggregateOutputType | null
    _min: TypeCompetenceMinAggregateOutputType | null
    _max: TypeCompetenceMaxAggregateOutputType | null
  }

  type GetTypeCompetenceGroupByPayload<T extends TypeCompetenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypeCompetenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeCompetenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeCompetenceGroupByOutputType[P]>
            : GetScalarType<T[P], TypeCompetenceGroupByOutputType[P]>
        }
      >
    >


  export type TypeCompetenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    description?: boolean
    dureeValiditeMois?: boolean
    actif?: boolean
    competences?: boolean | TypeCompetence$competencesArgs<ExtArgs>
    _count?: boolean | TypeCompetenceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["typeCompetence"]>

  export type TypeCompetenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    description?: boolean
    dureeValiditeMois?: boolean
    actif?: boolean
  }, ExtArgs["result"]["typeCompetence"]>

  export type TypeCompetenceSelectScalar = {
    id?: boolean
    code?: boolean
    libelle?: boolean
    description?: boolean
    dureeValiditeMois?: boolean
    actif?: boolean
  }

  export type TypeCompetenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    competences?: boolean | TypeCompetence$competencesArgs<ExtArgs>
    _count?: boolean | TypeCompetenceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TypeCompetenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TypeCompetencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TypeCompetence"
    objects: {
      competences: Prisma.$PersonnelCompetencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      libelle: string
      description: string | null
      dureeValiditeMois: number | null
      actif: boolean
    }, ExtArgs["result"]["typeCompetence"]>
    composites: {}
  }

  type TypeCompetenceGetPayload<S extends boolean | null | undefined | TypeCompetenceDefaultArgs> = $Result.GetResult<Prisma.$TypeCompetencePayload, S>

  type TypeCompetenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TypeCompetenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TypeCompetenceCountAggregateInputType | true
    }

  export interface TypeCompetenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TypeCompetence'], meta: { name: 'TypeCompetence' } }
    /**
     * Find zero or one TypeCompetence that matches the filter.
     * @param {TypeCompetenceFindUniqueArgs} args - Arguments to find a TypeCompetence
     * @example
     * // Get one TypeCompetence
     * const typeCompetence = await prisma.typeCompetence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TypeCompetenceFindUniqueArgs>(args: SelectSubset<T, TypeCompetenceFindUniqueArgs<ExtArgs>>): Prisma__TypeCompetenceClient<$Result.GetResult<Prisma.$TypeCompetencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TypeCompetence that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TypeCompetenceFindUniqueOrThrowArgs} args - Arguments to find a TypeCompetence
     * @example
     * // Get one TypeCompetence
     * const typeCompetence = await prisma.typeCompetence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TypeCompetenceFindUniqueOrThrowArgs>(args: SelectSubset<T, TypeCompetenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TypeCompetenceClient<$Result.GetResult<Prisma.$TypeCompetencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TypeCompetence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeCompetenceFindFirstArgs} args - Arguments to find a TypeCompetence
     * @example
     * // Get one TypeCompetence
     * const typeCompetence = await prisma.typeCompetence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TypeCompetenceFindFirstArgs>(args?: SelectSubset<T, TypeCompetenceFindFirstArgs<ExtArgs>>): Prisma__TypeCompetenceClient<$Result.GetResult<Prisma.$TypeCompetencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TypeCompetence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeCompetenceFindFirstOrThrowArgs} args - Arguments to find a TypeCompetence
     * @example
     * // Get one TypeCompetence
     * const typeCompetence = await prisma.typeCompetence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TypeCompetenceFindFirstOrThrowArgs>(args?: SelectSubset<T, TypeCompetenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TypeCompetenceClient<$Result.GetResult<Prisma.$TypeCompetencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TypeCompetences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeCompetenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypeCompetences
     * const typeCompetences = await prisma.typeCompetence.findMany()
     * 
     * // Get first 10 TypeCompetences
     * const typeCompetences = await prisma.typeCompetence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typeCompetenceWithIdOnly = await prisma.typeCompetence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TypeCompetenceFindManyArgs>(args?: SelectSubset<T, TypeCompetenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypeCompetencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TypeCompetence.
     * @param {TypeCompetenceCreateArgs} args - Arguments to create a TypeCompetence.
     * @example
     * // Create one TypeCompetence
     * const TypeCompetence = await prisma.typeCompetence.create({
     *   data: {
     *     // ... data to create a TypeCompetence
     *   }
     * })
     * 
     */
    create<T extends TypeCompetenceCreateArgs>(args: SelectSubset<T, TypeCompetenceCreateArgs<ExtArgs>>): Prisma__TypeCompetenceClient<$Result.GetResult<Prisma.$TypeCompetencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TypeCompetences.
     * @param {TypeCompetenceCreateManyArgs} args - Arguments to create many TypeCompetences.
     * @example
     * // Create many TypeCompetences
     * const typeCompetence = await prisma.typeCompetence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TypeCompetenceCreateManyArgs>(args?: SelectSubset<T, TypeCompetenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TypeCompetences and returns the data saved in the database.
     * @param {TypeCompetenceCreateManyAndReturnArgs} args - Arguments to create many TypeCompetences.
     * @example
     * // Create many TypeCompetences
     * const typeCompetence = await prisma.typeCompetence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TypeCompetences and only return the `id`
     * const typeCompetenceWithIdOnly = await prisma.typeCompetence.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TypeCompetenceCreateManyAndReturnArgs>(args?: SelectSubset<T, TypeCompetenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypeCompetencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TypeCompetence.
     * @param {TypeCompetenceDeleteArgs} args - Arguments to delete one TypeCompetence.
     * @example
     * // Delete one TypeCompetence
     * const TypeCompetence = await prisma.typeCompetence.delete({
     *   where: {
     *     // ... filter to delete one TypeCompetence
     *   }
     * })
     * 
     */
    delete<T extends TypeCompetenceDeleteArgs>(args: SelectSubset<T, TypeCompetenceDeleteArgs<ExtArgs>>): Prisma__TypeCompetenceClient<$Result.GetResult<Prisma.$TypeCompetencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TypeCompetence.
     * @param {TypeCompetenceUpdateArgs} args - Arguments to update one TypeCompetence.
     * @example
     * // Update one TypeCompetence
     * const typeCompetence = await prisma.typeCompetence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TypeCompetenceUpdateArgs>(args: SelectSubset<T, TypeCompetenceUpdateArgs<ExtArgs>>): Prisma__TypeCompetenceClient<$Result.GetResult<Prisma.$TypeCompetencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TypeCompetences.
     * @param {TypeCompetenceDeleteManyArgs} args - Arguments to filter TypeCompetences to delete.
     * @example
     * // Delete a few TypeCompetences
     * const { count } = await prisma.typeCompetence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TypeCompetenceDeleteManyArgs>(args?: SelectSubset<T, TypeCompetenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypeCompetences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeCompetenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypeCompetences
     * const typeCompetence = await prisma.typeCompetence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TypeCompetenceUpdateManyArgs>(args: SelectSubset<T, TypeCompetenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TypeCompetence.
     * @param {TypeCompetenceUpsertArgs} args - Arguments to update or create a TypeCompetence.
     * @example
     * // Update or create a TypeCompetence
     * const typeCompetence = await prisma.typeCompetence.upsert({
     *   create: {
     *     // ... data to create a TypeCompetence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypeCompetence we want to update
     *   }
     * })
     */
    upsert<T extends TypeCompetenceUpsertArgs>(args: SelectSubset<T, TypeCompetenceUpsertArgs<ExtArgs>>): Prisma__TypeCompetenceClient<$Result.GetResult<Prisma.$TypeCompetencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TypeCompetences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeCompetenceCountArgs} args - Arguments to filter TypeCompetences to count.
     * @example
     * // Count the number of TypeCompetences
     * const count = await prisma.typeCompetence.count({
     *   where: {
     *     // ... the filter for the TypeCompetences we want to count
     *   }
     * })
    **/
    count<T extends TypeCompetenceCountArgs>(
      args?: Subset<T, TypeCompetenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeCompetenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypeCompetence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeCompetenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeCompetenceAggregateArgs>(args: Subset<T, TypeCompetenceAggregateArgs>): Prisma.PrismaPromise<GetTypeCompetenceAggregateType<T>>

    /**
     * Group by TypeCompetence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeCompetenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeCompetenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeCompetenceGroupByArgs['orderBy'] }
        : { orderBy?: TypeCompetenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeCompetenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeCompetenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TypeCompetence model
   */
  readonly fields: TypeCompetenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TypeCompetence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TypeCompetenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    competences<T extends TypeCompetence$competencesArgs<ExtArgs> = {}>(args?: Subset<T, TypeCompetence$competencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelCompetencePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TypeCompetence model
   */ 
  interface TypeCompetenceFieldRefs {
    readonly id: FieldRef<"TypeCompetence", 'Int'>
    readonly code: FieldRef<"TypeCompetence", 'String'>
    readonly libelle: FieldRef<"TypeCompetence", 'String'>
    readonly description: FieldRef<"TypeCompetence", 'String'>
    readonly dureeValiditeMois: FieldRef<"TypeCompetence", 'Int'>
    readonly actif: FieldRef<"TypeCompetence", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TypeCompetence findUnique
   */
  export type TypeCompetenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCompetence
     */
    select?: TypeCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which TypeCompetence to fetch.
     */
    where: TypeCompetenceWhereUniqueInput
  }

  /**
   * TypeCompetence findUniqueOrThrow
   */
  export type TypeCompetenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCompetence
     */
    select?: TypeCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which TypeCompetence to fetch.
     */
    where: TypeCompetenceWhereUniqueInput
  }

  /**
   * TypeCompetence findFirst
   */
  export type TypeCompetenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCompetence
     */
    select?: TypeCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which TypeCompetence to fetch.
     */
    where?: TypeCompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeCompetences to fetch.
     */
    orderBy?: TypeCompetenceOrderByWithRelationInput | TypeCompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeCompetences.
     */
    cursor?: TypeCompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeCompetences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeCompetences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeCompetences.
     */
    distinct?: TypeCompetenceScalarFieldEnum | TypeCompetenceScalarFieldEnum[]
  }

  /**
   * TypeCompetence findFirstOrThrow
   */
  export type TypeCompetenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCompetence
     */
    select?: TypeCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which TypeCompetence to fetch.
     */
    where?: TypeCompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeCompetences to fetch.
     */
    orderBy?: TypeCompetenceOrderByWithRelationInput | TypeCompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeCompetences.
     */
    cursor?: TypeCompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeCompetences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeCompetences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeCompetences.
     */
    distinct?: TypeCompetenceScalarFieldEnum | TypeCompetenceScalarFieldEnum[]
  }

  /**
   * TypeCompetence findMany
   */
  export type TypeCompetenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCompetence
     */
    select?: TypeCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which TypeCompetences to fetch.
     */
    where?: TypeCompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeCompetences to fetch.
     */
    orderBy?: TypeCompetenceOrderByWithRelationInput | TypeCompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypeCompetences.
     */
    cursor?: TypeCompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeCompetences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeCompetences.
     */
    skip?: number
    distinct?: TypeCompetenceScalarFieldEnum | TypeCompetenceScalarFieldEnum[]
  }

  /**
   * TypeCompetence create
   */
  export type TypeCompetenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCompetence
     */
    select?: TypeCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeCompetenceInclude<ExtArgs> | null
    /**
     * The data needed to create a TypeCompetence.
     */
    data: XOR<TypeCompetenceCreateInput, TypeCompetenceUncheckedCreateInput>
  }

  /**
   * TypeCompetence createMany
   */
  export type TypeCompetenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TypeCompetences.
     */
    data: TypeCompetenceCreateManyInput | TypeCompetenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TypeCompetence createManyAndReturn
   */
  export type TypeCompetenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCompetence
     */
    select?: TypeCompetenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TypeCompetences.
     */
    data: TypeCompetenceCreateManyInput | TypeCompetenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TypeCompetence update
   */
  export type TypeCompetenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCompetence
     */
    select?: TypeCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeCompetenceInclude<ExtArgs> | null
    /**
     * The data needed to update a TypeCompetence.
     */
    data: XOR<TypeCompetenceUpdateInput, TypeCompetenceUncheckedUpdateInput>
    /**
     * Choose, which TypeCompetence to update.
     */
    where: TypeCompetenceWhereUniqueInput
  }

  /**
   * TypeCompetence updateMany
   */
  export type TypeCompetenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TypeCompetences.
     */
    data: XOR<TypeCompetenceUpdateManyMutationInput, TypeCompetenceUncheckedUpdateManyInput>
    /**
     * Filter which TypeCompetences to update
     */
    where?: TypeCompetenceWhereInput
  }

  /**
   * TypeCompetence upsert
   */
  export type TypeCompetenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCompetence
     */
    select?: TypeCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeCompetenceInclude<ExtArgs> | null
    /**
     * The filter to search for the TypeCompetence to update in case it exists.
     */
    where: TypeCompetenceWhereUniqueInput
    /**
     * In case the TypeCompetence found by the `where` argument doesn't exist, create a new TypeCompetence with this data.
     */
    create: XOR<TypeCompetenceCreateInput, TypeCompetenceUncheckedCreateInput>
    /**
     * In case the TypeCompetence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypeCompetenceUpdateInput, TypeCompetenceUncheckedUpdateInput>
  }

  /**
   * TypeCompetence delete
   */
  export type TypeCompetenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCompetence
     */
    select?: TypeCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeCompetenceInclude<ExtArgs> | null
    /**
     * Filter which TypeCompetence to delete.
     */
    where: TypeCompetenceWhereUniqueInput
  }

  /**
   * TypeCompetence deleteMany
   */
  export type TypeCompetenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypeCompetences to delete
     */
    where?: TypeCompetenceWhereInput
  }

  /**
   * TypeCompetence.competences
   */
  export type TypeCompetence$competencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCompetence
     */
    select?: PersonnelCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelCompetenceInclude<ExtArgs> | null
    where?: PersonnelCompetenceWhereInput
    orderBy?: PersonnelCompetenceOrderByWithRelationInput | PersonnelCompetenceOrderByWithRelationInput[]
    cursor?: PersonnelCompetenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonnelCompetenceScalarFieldEnum | PersonnelCompetenceScalarFieldEnum[]
  }

  /**
   * TypeCompetence without action
   */
  export type TypeCompetenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCompetence
     */
    select?: TypeCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeCompetenceInclude<ExtArgs> | null
  }


  /**
   * Model PersonnelCompetence
   */

  export type AggregatePersonnelCompetence = {
    _count: PersonnelCompetenceCountAggregateOutputType | null
    _avg: PersonnelCompetenceAvgAggregateOutputType | null
    _sum: PersonnelCompetenceSumAggregateOutputType | null
    _min: PersonnelCompetenceMinAggregateOutputType | null
    _max: PersonnelCompetenceMaxAggregateOutputType | null
  }

  export type PersonnelCompetenceAvgAggregateOutputType = {
    id: number | null
    personnelId: number | null
    typeCompetenceId: number | null
  }

  export type PersonnelCompetenceSumAggregateOutputType = {
    id: number | null
    personnelId: number | null
    typeCompetenceId: number | null
  }

  export type PersonnelCompetenceMinAggregateOutputType = {
    id: number | null
    personnelId: number | null
    typeCompetenceId: number | null
    dateObtention: Date | null
    dateExpiration: Date | null
    niveau: string | null
    numeroDiplome: string | null
    organismeDelivrance: string | null
    actif: boolean | null
    createdAt: Date | null
  }

  export type PersonnelCompetenceMaxAggregateOutputType = {
    id: number | null
    personnelId: number | null
    typeCompetenceId: number | null
    dateObtention: Date | null
    dateExpiration: Date | null
    niveau: string | null
    numeroDiplome: string | null
    organismeDelivrance: string | null
    actif: boolean | null
    createdAt: Date | null
  }

  export type PersonnelCompetenceCountAggregateOutputType = {
    id: number
    personnelId: number
    typeCompetenceId: number
    dateObtention: number
    dateExpiration: number
    niveau: number
    numeroDiplome: number
    organismeDelivrance: number
    actif: number
    createdAt: number
    _all: number
  }


  export type PersonnelCompetenceAvgAggregateInputType = {
    id?: true
    personnelId?: true
    typeCompetenceId?: true
  }

  export type PersonnelCompetenceSumAggregateInputType = {
    id?: true
    personnelId?: true
    typeCompetenceId?: true
  }

  export type PersonnelCompetenceMinAggregateInputType = {
    id?: true
    personnelId?: true
    typeCompetenceId?: true
    dateObtention?: true
    dateExpiration?: true
    niveau?: true
    numeroDiplome?: true
    organismeDelivrance?: true
    actif?: true
    createdAt?: true
  }

  export type PersonnelCompetenceMaxAggregateInputType = {
    id?: true
    personnelId?: true
    typeCompetenceId?: true
    dateObtention?: true
    dateExpiration?: true
    niveau?: true
    numeroDiplome?: true
    organismeDelivrance?: true
    actif?: true
    createdAt?: true
  }

  export type PersonnelCompetenceCountAggregateInputType = {
    id?: true
    personnelId?: true
    typeCompetenceId?: true
    dateObtention?: true
    dateExpiration?: true
    niveau?: true
    numeroDiplome?: true
    organismeDelivrance?: true
    actif?: true
    createdAt?: true
    _all?: true
  }

  export type PersonnelCompetenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonnelCompetence to aggregate.
     */
    where?: PersonnelCompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnelCompetences to fetch.
     */
    orderBy?: PersonnelCompetenceOrderByWithRelationInput | PersonnelCompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonnelCompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnelCompetences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnelCompetences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonnelCompetences
    **/
    _count?: true | PersonnelCompetenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonnelCompetenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonnelCompetenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonnelCompetenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonnelCompetenceMaxAggregateInputType
  }

  export type GetPersonnelCompetenceAggregateType<T extends PersonnelCompetenceAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonnelCompetence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonnelCompetence[P]>
      : GetScalarType<T[P], AggregatePersonnelCompetence[P]>
  }




  export type PersonnelCompetenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonnelCompetenceWhereInput
    orderBy?: PersonnelCompetenceOrderByWithAggregationInput | PersonnelCompetenceOrderByWithAggregationInput[]
    by: PersonnelCompetenceScalarFieldEnum[] | PersonnelCompetenceScalarFieldEnum
    having?: PersonnelCompetenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonnelCompetenceCountAggregateInputType | true
    _avg?: PersonnelCompetenceAvgAggregateInputType
    _sum?: PersonnelCompetenceSumAggregateInputType
    _min?: PersonnelCompetenceMinAggregateInputType
    _max?: PersonnelCompetenceMaxAggregateInputType
  }

  export type PersonnelCompetenceGroupByOutputType = {
    id: number
    personnelId: number
    typeCompetenceId: number
    dateObtention: Date
    dateExpiration: Date | null
    niveau: string | null
    numeroDiplome: string | null
    organismeDelivrance: string | null
    actif: boolean
    createdAt: Date
    _count: PersonnelCompetenceCountAggregateOutputType | null
    _avg: PersonnelCompetenceAvgAggregateOutputType | null
    _sum: PersonnelCompetenceSumAggregateOutputType | null
    _min: PersonnelCompetenceMinAggregateOutputType | null
    _max: PersonnelCompetenceMaxAggregateOutputType | null
  }

  type GetPersonnelCompetenceGroupByPayload<T extends PersonnelCompetenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonnelCompetenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonnelCompetenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonnelCompetenceGroupByOutputType[P]>
            : GetScalarType<T[P], PersonnelCompetenceGroupByOutputType[P]>
        }
      >
    >


  export type PersonnelCompetenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personnelId?: boolean
    typeCompetenceId?: boolean
    dateObtention?: boolean
    dateExpiration?: boolean
    niveau?: boolean
    numeroDiplome?: boolean
    organismeDelivrance?: boolean
    actif?: boolean
    createdAt?: boolean
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
    typeCompetence?: boolean | TypeCompetenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnelCompetence"]>

  export type PersonnelCompetenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personnelId?: boolean
    typeCompetenceId?: boolean
    dateObtention?: boolean
    dateExpiration?: boolean
    niveau?: boolean
    numeroDiplome?: boolean
    organismeDelivrance?: boolean
    actif?: boolean
    createdAt?: boolean
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
    typeCompetence?: boolean | TypeCompetenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personnelCompetence"]>

  export type PersonnelCompetenceSelectScalar = {
    id?: boolean
    personnelId?: boolean
    typeCompetenceId?: boolean
    dateObtention?: boolean
    dateExpiration?: boolean
    niveau?: boolean
    numeroDiplome?: boolean
    organismeDelivrance?: boolean
    actif?: boolean
    createdAt?: boolean
  }

  export type PersonnelCompetenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
    typeCompetence?: boolean | TypeCompetenceDefaultArgs<ExtArgs>
  }
  export type PersonnelCompetenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
    typeCompetence?: boolean | TypeCompetenceDefaultArgs<ExtArgs>
  }

  export type $PersonnelCompetencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonnelCompetence"
    objects: {
      personnel: Prisma.$PersonnelPayload<ExtArgs>
      typeCompetence: Prisma.$TypeCompetencePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      personnelId: number
      typeCompetenceId: number
      dateObtention: Date
      dateExpiration: Date | null
      niveau: string | null
      numeroDiplome: string | null
      organismeDelivrance: string | null
      actif: boolean
      createdAt: Date
    }, ExtArgs["result"]["personnelCompetence"]>
    composites: {}
  }

  type PersonnelCompetenceGetPayload<S extends boolean | null | undefined | PersonnelCompetenceDefaultArgs> = $Result.GetResult<Prisma.$PersonnelCompetencePayload, S>

  type PersonnelCompetenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonnelCompetenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonnelCompetenceCountAggregateInputType | true
    }

  export interface PersonnelCompetenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonnelCompetence'], meta: { name: 'PersonnelCompetence' } }
    /**
     * Find zero or one PersonnelCompetence that matches the filter.
     * @param {PersonnelCompetenceFindUniqueArgs} args - Arguments to find a PersonnelCompetence
     * @example
     * // Get one PersonnelCompetence
     * const personnelCompetence = await prisma.personnelCompetence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonnelCompetenceFindUniqueArgs>(args: SelectSubset<T, PersonnelCompetenceFindUniqueArgs<ExtArgs>>): Prisma__PersonnelCompetenceClient<$Result.GetResult<Prisma.$PersonnelCompetencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PersonnelCompetence that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonnelCompetenceFindUniqueOrThrowArgs} args - Arguments to find a PersonnelCompetence
     * @example
     * // Get one PersonnelCompetence
     * const personnelCompetence = await prisma.personnelCompetence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonnelCompetenceFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonnelCompetenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonnelCompetenceClient<$Result.GetResult<Prisma.$PersonnelCompetencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PersonnelCompetence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelCompetenceFindFirstArgs} args - Arguments to find a PersonnelCompetence
     * @example
     * // Get one PersonnelCompetence
     * const personnelCompetence = await prisma.personnelCompetence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonnelCompetenceFindFirstArgs>(args?: SelectSubset<T, PersonnelCompetenceFindFirstArgs<ExtArgs>>): Prisma__PersonnelCompetenceClient<$Result.GetResult<Prisma.$PersonnelCompetencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PersonnelCompetence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelCompetenceFindFirstOrThrowArgs} args - Arguments to find a PersonnelCompetence
     * @example
     * // Get one PersonnelCompetence
     * const personnelCompetence = await prisma.personnelCompetence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonnelCompetenceFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonnelCompetenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonnelCompetenceClient<$Result.GetResult<Prisma.$PersonnelCompetencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PersonnelCompetences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelCompetenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonnelCompetences
     * const personnelCompetences = await prisma.personnelCompetence.findMany()
     * 
     * // Get first 10 PersonnelCompetences
     * const personnelCompetences = await prisma.personnelCompetence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personnelCompetenceWithIdOnly = await prisma.personnelCompetence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonnelCompetenceFindManyArgs>(args?: SelectSubset<T, PersonnelCompetenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelCompetencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PersonnelCompetence.
     * @param {PersonnelCompetenceCreateArgs} args - Arguments to create a PersonnelCompetence.
     * @example
     * // Create one PersonnelCompetence
     * const PersonnelCompetence = await prisma.personnelCompetence.create({
     *   data: {
     *     // ... data to create a PersonnelCompetence
     *   }
     * })
     * 
     */
    create<T extends PersonnelCompetenceCreateArgs>(args: SelectSubset<T, PersonnelCompetenceCreateArgs<ExtArgs>>): Prisma__PersonnelCompetenceClient<$Result.GetResult<Prisma.$PersonnelCompetencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PersonnelCompetences.
     * @param {PersonnelCompetenceCreateManyArgs} args - Arguments to create many PersonnelCompetences.
     * @example
     * // Create many PersonnelCompetences
     * const personnelCompetence = await prisma.personnelCompetence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonnelCompetenceCreateManyArgs>(args?: SelectSubset<T, PersonnelCompetenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonnelCompetences and returns the data saved in the database.
     * @param {PersonnelCompetenceCreateManyAndReturnArgs} args - Arguments to create many PersonnelCompetences.
     * @example
     * // Create many PersonnelCompetences
     * const personnelCompetence = await prisma.personnelCompetence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonnelCompetences and only return the `id`
     * const personnelCompetenceWithIdOnly = await prisma.personnelCompetence.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonnelCompetenceCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonnelCompetenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonnelCompetencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PersonnelCompetence.
     * @param {PersonnelCompetenceDeleteArgs} args - Arguments to delete one PersonnelCompetence.
     * @example
     * // Delete one PersonnelCompetence
     * const PersonnelCompetence = await prisma.personnelCompetence.delete({
     *   where: {
     *     // ... filter to delete one PersonnelCompetence
     *   }
     * })
     * 
     */
    delete<T extends PersonnelCompetenceDeleteArgs>(args: SelectSubset<T, PersonnelCompetenceDeleteArgs<ExtArgs>>): Prisma__PersonnelCompetenceClient<$Result.GetResult<Prisma.$PersonnelCompetencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PersonnelCompetence.
     * @param {PersonnelCompetenceUpdateArgs} args - Arguments to update one PersonnelCompetence.
     * @example
     * // Update one PersonnelCompetence
     * const personnelCompetence = await prisma.personnelCompetence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonnelCompetenceUpdateArgs>(args: SelectSubset<T, PersonnelCompetenceUpdateArgs<ExtArgs>>): Prisma__PersonnelCompetenceClient<$Result.GetResult<Prisma.$PersonnelCompetencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PersonnelCompetences.
     * @param {PersonnelCompetenceDeleteManyArgs} args - Arguments to filter PersonnelCompetences to delete.
     * @example
     * // Delete a few PersonnelCompetences
     * const { count } = await prisma.personnelCompetence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonnelCompetenceDeleteManyArgs>(args?: SelectSubset<T, PersonnelCompetenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonnelCompetences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelCompetenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonnelCompetences
     * const personnelCompetence = await prisma.personnelCompetence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonnelCompetenceUpdateManyArgs>(args: SelectSubset<T, PersonnelCompetenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonnelCompetence.
     * @param {PersonnelCompetenceUpsertArgs} args - Arguments to update or create a PersonnelCompetence.
     * @example
     * // Update or create a PersonnelCompetence
     * const personnelCompetence = await prisma.personnelCompetence.upsert({
     *   create: {
     *     // ... data to create a PersonnelCompetence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonnelCompetence we want to update
     *   }
     * })
     */
    upsert<T extends PersonnelCompetenceUpsertArgs>(args: SelectSubset<T, PersonnelCompetenceUpsertArgs<ExtArgs>>): Prisma__PersonnelCompetenceClient<$Result.GetResult<Prisma.$PersonnelCompetencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PersonnelCompetences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelCompetenceCountArgs} args - Arguments to filter PersonnelCompetences to count.
     * @example
     * // Count the number of PersonnelCompetences
     * const count = await prisma.personnelCompetence.count({
     *   where: {
     *     // ... the filter for the PersonnelCompetences we want to count
     *   }
     * })
    **/
    count<T extends PersonnelCompetenceCountArgs>(
      args?: Subset<T, PersonnelCompetenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonnelCompetenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonnelCompetence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelCompetenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonnelCompetenceAggregateArgs>(args: Subset<T, PersonnelCompetenceAggregateArgs>): Prisma.PrismaPromise<GetPersonnelCompetenceAggregateType<T>>

    /**
     * Group by PersonnelCompetence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonnelCompetenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonnelCompetenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonnelCompetenceGroupByArgs['orderBy'] }
        : { orderBy?: PersonnelCompetenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonnelCompetenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonnelCompetenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonnelCompetence model
   */
  readonly fields: PersonnelCompetenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonnelCompetence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonnelCompetenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnel<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    typeCompetence<T extends TypeCompetenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TypeCompetenceDefaultArgs<ExtArgs>>): Prisma__TypeCompetenceClient<$Result.GetResult<Prisma.$TypeCompetencePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonnelCompetence model
   */ 
  interface PersonnelCompetenceFieldRefs {
    readonly id: FieldRef<"PersonnelCompetence", 'Int'>
    readonly personnelId: FieldRef<"PersonnelCompetence", 'Int'>
    readonly typeCompetenceId: FieldRef<"PersonnelCompetence", 'Int'>
    readonly dateObtention: FieldRef<"PersonnelCompetence", 'DateTime'>
    readonly dateExpiration: FieldRef<"PersonnelCompetence", 'DateTime'>
    readonly niveau: FieldRef<"PersonnelCompetence", 'String'>
    readonly numeroDiplome: FieldRef<"PersonnelCompetence", 'String'>
    readonly organismeDelivrance: FieldRef<"PersonnelCompetence", 'String'>
    readonly actif: FieldRef<"PersonnelCompetence", 'Boolean'>
    readonly createdAt: FieldRef<"PersonnelCompetence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PersonnelCompetence findUnique
   */
  export type PersonnelCompetenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCompetence
     */
    select?: PersonnelCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which PersonnelCompetence to fetch.
     */
    where: PersonnelCompetenceWhereUniqueInput
  }

  /**
   * PersonnelCompetence findUniqueOrThrow
   */
  export type PersonnelCompetenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCompetence
     */
    select?: PersonnelCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which PersonnelCompetence to fetch.
     */
    where: PersonnelCompetenceWhereUniqueInput
  }

  /**
   * PersonnelCompetence findFirst
   */
  export type PersonnelCompetenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCompetence
     */
    select?: PersonnelCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which PersonnelCompetence to fetch.
     */
    where?: PersonnelCompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnelCompetences to fetch.
     */
    orderBy?: PersonnelCompetenceOrderByWithRelationInput | PersonnelCompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonnelCompetences.
     */
    cursor?: PersonnelCompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnelCompetences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnelCompetences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonnelCompetences.
     */
    distinct?: PersonnelCompetenceScalarFieldEnum | PersonnelCompetenceScalarFieldEnum[]
  }

  /**
   * PersonnelCompetence findFirstOrThrow
   */
  export type PersonnelCompetenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCompetence
     */
    select?: PersonnelCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which PersonnelCompetence to fetch.
     */
    where?: PersonnelCompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnelCompetences to fetch.
     */
    orderBy?: PersonnelCompetenceOrderByWithRelationInput | PersonnelCompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonnelCompetences.
     */
    cursor?: PersonnelCompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnelCompetences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnelCompetences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonnelCompetences.
     */
    distinct?: PersonnelCompetenceScalarFieldEnum | PersonnelCompetenceScalarFieldEnum[]
  }

  /**
   * PersonnelCompetence findMany
   */
  export type PersonnelCompetenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCompetence
     */
    select?: PersonnelCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelCompetenceInclude<ExtArgs> | null
    /**
     * Filter, which PersonnelCompetences to fetch.
     */
    where?: PersonnelCompetenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonnelCompetences to fetch.
     */
    orderBy?: PersonnelCompetenceOrderByWithRelationInput | PersonnelCompetenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonnelCompetences.
     */
    cursor?: PersonnelCompetenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonnelCompetences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonnelCompetences.
     */
    skip?: number
    distinct?: PersonnelCompetenceScalarFieldEnum | PersonnelCompetenceScalarFieldEnum[]
  }

  /**
   * PersonnelCompetence create
   */
  export type PersonnelCompetenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCompetence
     */
    select?: PersonnelCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelCompetenceInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonnelCompetence.
     */
    data: XOR<PersonnelCompetenceCreateInput, PersonnelCompetenceUncheckedCreateInput>
  }

  /**
   * PersonnelCompetence createMany
   */
  export type PersonnelCompetenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonnelCompetences.
     */
    data: PersonnelCompetenceCreateManyInput | PersonnelCompetenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonnelCompetence createManyAndReturn
   */
  export type PersonnelCompetenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCompetence
     */
    select?: PersonnelCompetenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PersonnelCompetences.
     */
    data: PersonnelCompetenceCreateManyInput | PersonnelCompetenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelCompetenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonnelCompetence update
   */
  export type PersonnelCompetenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCompetence
     */
    select?: PersonnelCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelCompetenceInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonnelCompetence.
     */
    data: XOR<PersonnelCompetenceUpdateInput, PersonnelCompetenceUncheckedUpdateInput>
    /**
     * Choose, which PersonnelCompetence to update.
     */
    where: PersonnelCompetenceWhereUniqueInput
  }

  /**
   * PersonnelCompetence updateMany
   */
  export type PersonnelCompetenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonnelCompetences.
     */
    data: XOR<PersonnelCompetenceUpdateManyMutationInput, PersonnelCompetenceUncheckedUpdateManyInput>
    /**
     * Filter which PersonnelCompetences to update
     */
    where?: PersonnelCompetenceWhereInput
  }

  /**
   * PersonnelCompetence upsert
   */
  export type PersonnelCompetenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCompetence
     */
    select?: PersonnelCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelCompetenceInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonnelCompetence to update in case it exists.
     */
    where: PersonnelCompetenceWhereUniqueInput
    /**
     * In case the PersonnelCompetence found by the `where` argument doesn't exist, create a new PersonnelCompetence with this data.
     */
    create: XOR<PersonnelCompetenceCreateInput, PersonnelCompetenceUncheckedCreateInput>
    /**
     * In case the PersonnelCompetence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonnelCompetenceUpdateInput, PersonnelCompetenceUncheckedUpdateInput>
  }

  /**
   * PersonnelCompetence delete
   */
  export type PersonnelCompetenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCompetence
     */
    select?: PersonnelCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelCompetenceInclude<ExtArgs> | null
    /**
     * Filter which PersonnelCompetence to delete.
     */
    where: PersonnelCompetenceWhereUniqueInput
  }

  /**
   * PersonnelCompetence deleteMany
   */
  export type PersonnelCompetenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonnelCompetences to delete
     */
    where?: PersonnelCompetenceWhereInput
  }

  /**
   * PersonnelCompetence without action
   */
  export type PersonnelCompetenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonnelCompetence
     */
    select?: PersonnelCompetenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelCompetenceInclude<ExtArgs> | null
  }


  /**
   * Model AptitudeMedicale
   */

  export type AggregateAptitudeMedicale = {
    _count: AptitudeMedicaleCountAggregateOutputType | null
    _avg: AptitudeMedicaleAvgAggregateOutputType | null
    _sum: AptitudeMedicaleSumAggregateOutputType | null
    _min: AptitudeMedicaleMinAggregateOutputType | null
    _max: AptitudeMedicaleMaxAggregateOutputType | null
  }

  export type AptitudeMedicaleAvgAggregateOutputType = {
    id: number | null
    personnelId: number | null
  }

  export type AptitudeMedicaleSumAggregateOutputType = {
    id: number | null
    personnelId: number | null
  }

  export type AptitudeMedicaleMinAggregateOutputType = {
    id: number | null
    personnelId: number | null
    dateVisite: Date | null
    dateProchaineVisite: Date | null
    aptitude: $Enums.StatutAptitude | null
    restrictions: string | null
    medecin: string | null
    commentaires: string | null
    createdAt: Date | null
  }

  export type AptitudeMedicaleMaxAggregateOutputType = {
    id: number | null
    personnelId: number | null
    dateVisite: Date | null
    dateProchaineVisite: Date | null
    aptitude: $Enums.StatutAptitude | null
    restrictions: string | null
    medecin: string | null
    commentaires: string | null
    createdAt: Date | null
  }

  export type AptitudeMedicaleCountAggregateOutputType = {
    id: number
    personnelId: number
    dateVisite: number
    dateProchaineVisite: number
    aptitude: number
    restrictions: number
    medecin: number
    commentaires: number
    createdAt: number
    _all: number
  }


  export type AptitudeMedicaleAvgAggregateInputType = {
    id?: true
    personnelId?: true
  }

  export type AptitudeMedicaleSumAggregateInputType = {
    id?: true
    personnelId?: true
  }

  export type AptitudeMedicaleMinAggregateInputType = {
    id?: true
    personnelId?: true
    dateVisite?: true
    dateProchaineVisite?: true
    aptitude?: true
    restrictions?: true
    medecin?: true
    commentaires?: true
    createdAt?: true
  }

  export type AptitudeMedicaleMaxAggregateInputType = {
    id?: true
    personnelId?: true
    dateVisite?: true
    dateProchaineVisite?: true
    aptitude?: true
    restrictions?: true
    medecin?: true
    commentaires?: true
    createdAt?: true
  }

  export type AptitudeMedicaleCountAggregateInputType = {
    id?: true
    personnelId?: true
    dateVisite?: true
    dateProchaineVisite?: true
    aptitude?: true
    restrictions?: true
    medecin?: true
    commentaires?: true
    createdAt?: true
    _all?: true
  }

  export type AptitudeMedicaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AptitudeMedicale to aggregate.
     */
    where?: AptitudeMedicaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AptitudeMedicales to fetch.
     */
    orderBy?: AptitudeMedicaleOrderByWithRelationInput | AptitudeMedicaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AptitudeMedicaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AptitudeMedicales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AptitudeMedicales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AptitudeMedicales
    **/
    _count?: true | AptitudeMedicaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AptitudeMedicaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AptitudeMedicaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AptitudeMedicaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AptitudeMedicaleMaxAggregateInputType
  }

  export type GetAptitudeMedicaleAggregateType<T extends AptitudeMedicaleAggregateArgs> = {
        [P in keyof T & keyof AggregateAptitudeMedicale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAptitudeMedicale[P]>
      : GetScalarType<T[P], AggregateAptitudeMedicale[P]>
  }




  export type AptitudeMedicaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AptitudeMedicaleWhereInput
    orderBy?: AptitudeMedicaleOrderByWithAggregationInput | AptitudeMedicaleOrderByWithAggregationInput[]
    by: AptitudeMedicaleScalarFieldEnum[] | AptitudeMedicaleScalarFieldEnum
    having?: AptitudeMedicaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AptitudeMedicaleCountAggregateInputType | true
    _avg?: AptitudeMedicaleAvgAggregateInputType
    _sum?: AptitudeMedicaleSumAggregateInputType
    _min?: AptitudeMedicaleMinAggregateInputType
    _max?: AptitudeMedicaleMaxAggregateInputType
  }

  export type AptitudeMedicaleGroupByOutputType = {
    id: number
    personnelId: number
    dateVisite: Date
    dateProchaineVisite: Date | null
    aptitude: $Enums.StatutAptitude
    restrictions: string | null
    medecin: string | null
    commentaires: string | null
    createdAt: Date
    _count: AptitudeMedicaleCountAggregateOutputType | null
    _avg: AptitudeMedicaleAvgAggregateOutputType | null
    _sum: AptitudeMedicaleSumAggregateOutputType | null
    _min: AptitudeMedicaleMinAggregateOutputType | null
    _max: AptitudeMedicaleMaxAggregateOutputType | null
  }

  type GetAptitudeMedicaleGroupByPayload<T extends AptitudeMedicaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AptitudeMedicaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AptitudeMedicaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AptitudeMedicaleGroupByOutputType[P]>
            : GetScalarType<T[P], AptitudeMedicaleGroupByOutputType[P]>
        }
      >
    >


  export type AptitudeMedicaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personnelId?: boolean
    dateVisite?: boolean
    dateProchaineVisite?: boolean
    aptitude?: boolean
    restrictions?: boolean
    medecin?: boolean
    commentaires?: boolean
    createdAt?: boolean
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aptitudeMedicale"]>

  export type AptitudeMedicaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personnelId?: boolean
    dateVisite?: boolean
    dateProchaineVisite?: boolean
    aptitude?: boolean
    restrictions?: boolean
    medecin?: boolean
    commentaires?: boolean
    createdAt?: boolean
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aptitudeMedicale"]>

  export type AptitudeMedicaleSelectScalar = {
    id?: boolean
    personnelId?: boolean
    dateVisite?: boolean
    dateProchaineVisite?: boolean
    aptitude?: boolean
    restrictions?: boolean
    medecin?: boolean
    commentaires?: boolean
    createdAt?: boolean
  }

  export type AptitudeMedicaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }
  export type AptitudeMedicaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }

  export type $AptitudeMedicalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AptitudeMedicale"
    objects: {
      personnel: Prisma.$PersonnelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      personnelId: number
      dateVisite: Date
      dateProchaineVisite: Date | null
      aptitude: $Enums.StatutAptitude
      restrictions: string | null
      medecin: string | null
      commentaires: string | null
      createdAt: Date
    }, ExtArgs["result"]["aptitudeMedicale"]>
    composites: {}
  }

  type AptitudeMedicaleGetPayload<S extends boolean | null | undefined | AptitudeMedicaleDefaultArgs> = $Result.GetResult<Prisma.$AptitudeMedicalePayload, S>

  type AptitudeMedicaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AptitudeMedicaleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AptitudeMedicaleCountAggregateInputType | true
    }

  export interface AptitudeMedicaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AptitudeMedicale'], meta: { name: 'AptitudeMedicale' } }
    /**
     * Find zero or one AptitudeMedicale that matches the filter.
     * @param {AptitudeMedicaleFindUniqueArgs} args - Arguments to find a AptitudeMedicale
     * @example
     * // Get one AptitudeMedicale
     * const aptitudeMedicale = await prisma.aptitudeMedicale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AptitudeMedicaleFindUniqueArgs>(args: SelectSubset<T, AptitudeMedicaleFindUniqueArgs<ExtArgs>>): Prisma__AptitudeMedicaleClient<$Result.GetResult<Prisma.$AptitudeMedicalePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AptitudeMedicale that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AptitudeMedicaleFindUniqueOrThrowArgs} args - Arguments to find a AptitudeMedicale
     * @example
     * // Get one AptitudeMedicale
     * const aptitudeMedicale = await prisma.aptitudeMedicale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AptitudeMedicaleFindUniqueOrThrowArgs>(args: SelectSubset<T, AptitudeMedicaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AptitudeMedicaleClient<$Result.GetResult<Prisma.$AptitudeMedicalePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AptitudeMedicale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AptitudeMedicaleFindFirstArgs} args - Arguments to find a AptitudeMedicale
     * @example
     * // Get one AptitudeMedicale
     * const aptitudeMedicale = await prisma.aptitudeMedicale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AptitudeMedicaleFindFirstArgs>(args?: SelectSubset<T, AptitudeMedicaleFindFirstArgs<ExtArgs>>): Prisma__AptitudeMedicaleClient<$Result.GetResult<Prisma.$AptitudeMedicalePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AptitudeMedicale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AptitudeMedicaleFindFirstOrThrowArgs} args - Arguments to find a AptitudeMedicale
     * @example
     * // Get one AptitudeMedicale
     * const aptitudeMedicale = await prisma.aptitudeMedicale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AptitudeMedicaleFindFirstOrThrowArgs>(args?: SelectSubset<T, AptitudeMedicaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AptitudeMedicaleClient<$Result.GetResult<Prisma.$AptitudeMedicalePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AptitudeMedicales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AptitudeMedicaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AptitudeMedicales
     * const aptitudeMedicales = await prisma.aptitudeMedicale.findMany()
     * 
     * // Get first 10 AptitudeMedicales
     * const aptitudeMedicales = await prisma.aptitudeMedicale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aptitudeMedicaleWithIdOnly = await prisma.aptitudeMedicale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AptitudeMedicaleFindManyArgs>(args?: SelectSubset<T, AptitudeMedicaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AptitudeMedicalePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AptitudeMedicale.
     * @param {AptitudeMedicaleCreateArgs} args - Arguments to create a AptitudeMedicale.
     * @example
     * // Create one AptitudeMedicale
     * const AptitudeMedicale = await prisma.aptitudeMedicale.create({
     *   data: {
     *     // ... data to create a AptitudeMedicale
     *   }
     * })
     * 
     */
    create<T extends AptitudeMedicaleCreateArgs>(args: SelectSubset<T, AptitudeMedicaleCreateArgs<ExtArgs>>): Prisma__AptitudeMedicaleClient<$Result.GetResult<Prisma.$AptitudeMedicalePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AptitudeMedicales.
     * @param {AptitudeMedicaleCreateManyArgs} args - Arguments to create many AptitudeMedicales.
     * @example
     * // Create many AptitudeMedicales
     * const aptitudeMedicale = await prisma.aptitudeMedicale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AptitudeMedicaleCreateManyArgs>(args?: SelectSubset<T, AptitudeMedicaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AptitudeMedicales and returns the data saved in the database.
     * @param {AptitudeMedicaleCreateManyAndReturnArgs} args - Arguments to create many AptitudeMedicales.
     * @example
     * // Create many AptitudeMedicales
     * const aptitudeMedicale = await prisma.aptitudeMedicale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AptitudeMedicales and only return the `id`
     * const aptitudeMedicaleWithIdOnly = await prisma.aptitudeMedicale.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AptitudeMedicaleCreateManyAndReturnArgs>(args?: SelectSubset<T, AptitudeMedicaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AptitudeMedicalePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AptitudeMedicale.
     * @param {AptitudeMedicaleDeleteArgs} args - Arguments to delete one AptitudeMedicale.
     * @example
     * // Delete one AptitudeMedicale
     * const AptitudeMedicale = await prisma.aptitudeMedicale.delete({
     *   where: {
     *     // ... filter to delete one AptitudeMedicale
     *   }
     * })
     * 
     */
    delete<T extends AptitudeMedicaleDeleteArgs>(args: SelectSubset<T, AptitudeMedicaleDeleteArgs<ExtArgs>>): Prisma__AptitudeMedicaleClient<$Result.GetResult<Prisma.$AptitudeMedicalePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AptitudeMedicale.
     * @param {AptitudeMedicaleUpdateArgs} args - Arguments to update one AptitudeMedicale.
     * @example
     * // Update one AptitudeMedicale
     * const aptitudeMedicale = await prisma.aptitudeMedicale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AptitudeMedicaleUpdateArgs>(args: SelectSubset<T, AptitudeMedicaleUpdateArgs<ExtArgs>>): Prisma__AptitudeMedicaleClient<$Result.GetResult<Prisma.$AptitudeMedicalePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AptitudeMedicales.
     * @param {AptitudeMedicaleDeleteManyArgs} args - Arguments to filter AptitudeMedicales to delete.
     * @example
     * // Delete a few AptitudeMedicales
     * const { count } = await prisma.aptitudeMedicale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AptitudeMedicaleDeleteManyArgs>(args?: SelectSubset<T, AptitudeMedicaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AptitudeMedicales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AptitudeMedicaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AptitudeMedicales
     * const aptitudeMedicale = await prisma.aptitudeMedicale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AptitudeMedicaleUpdateManyArgs>(args: SelectSubset<T, AptitudeMedicaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AptitudeMedicale.
     * @param {AptitudeMedicaleUpsertArgs} args - Arguments to update or create a AptitudeMedicale.
     * @example
     * // Update or create a AptitudeMedicale
     * const aptitudeMedicale = await prisma.aptitudeMedicale.upsert({
     *   create: {
     *     // ... data to create a AptitudeMedicale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AptitudeMedicale we want to update
     *   }
     * })
     */
    upsert<T extends AptitudeMedicaleUpsertArgs>(args: SelectSubset<T, AptitudeMedicaleUpsertArgs<ExtArgs>>): Prisma__AptitudeMedicaleClient<$Result.GetResult<Prisma.$AptitudeMedicalePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AptitudeMedicales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AptitudeMedicaleCountArgs} args - Arguments to filter AptitudeMedicales to count.
     * @example
     * // Count the number of AptitudeMedicales
     * const count = await prisma.aptitudeMedicale.count({
     *   where: {
     *     // ... the filter for the AptitudeMedicales we want to count
     *   }
     * })
    **/
    count<T extends AptitudeMedicaleCountArgs>(
      args?: Subset<T, AptitudeMedicaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AptitudeMedicaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AptitudeMedicale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AptitudeMedicaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AptitudeMedicaleAggregateArgs>(args: Subset<T, AptitudeMedicaleAggregateArgs>): Prisma.PrismaPromise<GetAptitudeMedicaleAggregateType<T>>

    /**
     * Group by AptitudeMedicale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AptitudeMedicaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AptitudeMedicaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AptitudeMedicaleGroupByArgs['orderBy'] }
        : { orderBy?: AptitudeMedicaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AptitudeMedicaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAptitudeMedicaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AptitudeMedicale model
   */
  readonly fields: AptitudeMedicaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AptitudeMedicale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AptitudeMedicaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnel<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AptitudeMedicale model
   */ 
  interface AptitudeMedicaleFieldRefs {
    readonly id: FieldRef<"AptitudeMedicale", 'Int'>
    readonly personnelId: FieldRef<"AptitudeMedicale", 'Int'>
    readonly dateVisite: FieldRef<"AptitudeMedicale", 'DateTime'>
    readonly dateProchaineVisite: FieldRef<"AptitudeMedicale", 'DateTime'>
    readonly aptitude: FieldRef<"AptitudeMedicale", 'StatutAptitude'>
    readonly restrictions: FieldRef<"AptitudeMedicale", 'String'>
    readonly medecin: FieldRef<"AptitudeMedicale", 'String'>
    readonly commentaires: FieldRef<"AptitudeMedicale", 'String'>
    readonly createdAt: FieldRef<"AptitudeMedicale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AptitudeMedicale findUnique
   */
  export type AptitudeMedicaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AptitudeMedicale
     */
    select?: AptitudeMedicaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AptitudeMedicaleInclude<ExtArgs> | null
    /**
     * Filter, which AptitudeMedicale to fetch.
     */
    where: AptitudeMedicaleWhereUniqueInput
  }

  /**
   * AptitudeMedicale findUniqueOrThrow
   */
  export type AptitudeMedicaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AptitudeMedicale
     */
    select?: AptitudeMedicaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AptitudeMedicaleInclude<ExtArgs> | null
    /**
     * Filter, which AptitudeMedicale to fetch.
     */
    where: AptitudeMedicaleWhereUniqueInput
  }

  /**
   * AptitudeMedicale findFirst
   */
  export type AptitudeMedicaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AptitudeMedicale
     */
    select?: AptitudeMedicaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AptitudeMedicaleInclude<ExtArgs> | null
    /**
     * Filter, which AptitudeMedicale to fetch.
     */
    where?: AptitudeMedicaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AptitudeMedicales to fetch.
     */
    orderBy?: AptitudeMedicaleOrderByWithRelationInput | AptitudeMedicaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AptitudeMedicales.
     */
    cursor?: AptitudeMedicaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AptitudeMedicales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AptitudeMedicales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AptitudeMedicales.
     */
    distinct?: AptitudeMedicaleScalarFieldEnum | AptitudeMedicaleScalarFieldEnum[]
  }

  /**
   * AptitudeMedicale findFirstOrThrow
   */
  export type AptitudeMedicaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AptitudeMedicale
     */
    select?: AptitudeMedicaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AptitudeMedicaleInclude<ExtArgs> | null
    /**
     * Filter, which AptitudeMedicale to fetch.
     */
    where?: AptitudeMedicaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AptitudeMedicales to fetch.
     */
    orderBy?: AptitudeMedicaleOrderByWithRelationInput | AptitudeMedicaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AptitudeMedicales.
     */
    cursor?: AptitudeMedicaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AptitudeMedicales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AptitudeMedicales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AptitudeMedicales.
     */
    distinct?: AptitudeMedicaleScalarFieldEnum | AptitudeMedicaleScalarFieldEnum[]
  }

  /**
   * AptitudeMedicale findMany
   */
  export type AptitudeMedicaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AptitudeMedicale
     */
    select?: AptitudeMedicaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AptitudeMedicaleInclude<ExtArgs> | null
    /**
     * Filter, which AptitudeMedicales to fetch.
     */
    where?: AptitudeMedicaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AptitudeMedicales to fetch.
     */
    orderBy?: AptitudeMedicaleOrderByWithRelationInput | AptitudeMedicaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AptitudeMedicales.
     */
    cursor?: AptitudeMedicaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AptitudeMedicales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AptitudeMedicales.
     */
    skip?: number
    distinct?: AptitudeMedicaleScalarFieldEnum | AptitudeMedicaleScalarFieldEnum[]
  }

  /**
   * AptitudeMedicale create
   */
  export type AptitudeMedicaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AptitudeMedicale
     */
    select?: AptitudeMedicaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AptitudeMedicaleInclude<ExtArgs> | null
    /**
     * The data needed to create a AptitudeMedicale.
     */
    data: XOR<AptitudeMedicaleCreateInput, AptitudeMedicaleUncheckedCreateInput>
  }

  /**
   * AptitudeMedicale createMany
   */
  export type AptitudeMedicaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AptitudeMedicales.
     */
    data: AptitudeMedicaleCreateManyInput | AptitudeMedicaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AptitudeMedicale createManyAndReturn
   */
  export type AptitudeMedicaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AptitudeMedicale
     */
    select?: AptitudeMedicaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AptitudeMedicales.
     */
    data: AptitudeMedicaleCreateManyInput | AptitudeMedicaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AptitudeMedicaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AptitudeMedicale update
   */
  export type AptitudeMedicaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AptitudeMedicale
     */
    select?: AptitudeMedicaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AptitudeMedicaleInclude<ExtArgs> | null
    /**
     * The data needed to update a AptitudeMedicale.
     */
    data: XOR<AptitudeMedicaleUpdateInput, AptitudeMedicaleUncheckedUpdateInput>
    /**
     * Choose, which AptitudeMedicale to update.
     */
    where: AptitudeMedicaleWhereUniqueInput
  }

  /**
   * AptitudeMedicale updateMany
   */
  export type AptitudeMedicaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AptitudeMedicales.
     */
    data: XOR<AptitudeMedicaleUpdateManyMutationInput, AptitudeMedicaleUncheckedUpdateManyInput>
    /**
     * Filter which AptitudeMedicales to update
     */
    where?: AptitudeMedicaleWhereInput
  }

  /**
   * AptitudeMedicale upsert
   */
  export type AptitudeMedicaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AptitudeMedicale
     */
    select?: AptitudeMedicaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AptitudeMedicaleInclude<ExtArgs> | null
    /**
     * The filter to search for the AptitudeMedicale to update in case it exists.
     */
    where: AptitudeMedicaleWhereUniqueInput
    /**
     * In case the AptitudeMedicale found by the `where` argument doesn't exist, create a new AptitudeMedicale with this data.
     */
    create: XOR<AptitudeMedicaleCreateInput, AptitudeMedicaleUncheckedCreateInput>
    /**
     * In case the AptitudeMedicale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AptitudeMedicaleUpdateInput, AptitudeMedicaleUncheckedUpdateInput>
  }

  /**
   * AptitudeMedicale delete
   */
  export type AptitudeMedicaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AptitudeMedicale
     */
    select?: AptitudeMedicaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AptitudeMedicaleInclude<ExtArgs> | null
    /**
     * Filter which AptitudeMedicale to delete.
     */
    where: AptitudeMedicaleWhereUniqueInput
  }

  /**
   * AptitudeMedicale deleteMany
   */
  export type AptitudeMedicaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AptitudeMedicales to delete
     */
    where?: AptitudeMedicaleWhereInput
  }

  /**
   * AptitudeMedicale without action
   */
  export type AptitudeMedicaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AptitudeMedicale
     */
    select?: AptitudeMedicaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AptitudeMedicaleInclude<ExtArgs> | null
  }


  /**
   * Model TypeFMPA
   */

  export type AggregateTypeFMPA = {
    _count: TypeFMPACountAggregateOutputType | null
    _avg: TypeFMPAAvgAggregateOutputType | null
    _sum: TypeFMPASumAggregateOutputType | null
    _min: TypeFMPAMinAggregateOutputType | null
    _max: TypeFMPAMaxAggregateOutputType | null
  }

  export type TypeFMPAAvgAggregateOutputType = {
    id: number | null
    dureeHeures: number | null
    periodiciteMois: number | null
  }

  export type TypeFMPASumAggregateOutputType = {
    id: number | null
    dureeHeures: number | null
    periodiciteMois: number | null
  }

  export type TypeFMPAMinAggregateOutputType = {
    id: number | null
    code: string | null
    libelle: string | null
    dureeHeures: number | null
    obligatoire: boolean | null
    periodiciteMois: number | null
    description: string | null
    actif: boolean | null
  }

  export type TypeFMPAMaxAggregateOutputType = {
    id: number | null
    code: string | null
    libelle: string | null
    dureeHeures: number | null
    obligatoire: boolean | null
    periodiciteMois: number | null
    description: string | null
    actif: boolean | null
  }

  export type TypeFMPACountAggregateOutputType = {
    id: number
    code: number
    libelle: number
    dureeHeures: number
    obligatoire: number
    periodiciteMois: number
    description: number
    actif: number
    _all: number
  }


  export type TypeFMPAAvgAggregateInputType = {
    id?: true
    dureeHeures?: true
    periodiciteMois?: true
  }

  export type TypeFMPASumAggregateInputType = {
    id?: true
    dureeHeures?: true
    periodiciteMois?: true
  }

  export type TypeFMPAMinAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    dureeHeures?: true
    obligatoire?: true
    periodiciteMois?: true
    description?: true
    actif?: true
  }

  export type TypeFMPAMaxAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    dureeHeures?: true
    obligatoire?: true
    periodiciteMois?: true
    description?: true
    actif?: true
  }

  export type TypeFMPACountAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    dureeHeures?: true
    obligatoire?: true
    periodiciteMois?: true
    description?: true
    actif?: true
    _all?: true
  }

  export type TypeFMPAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypeFMPA to aggregate.
     */
    where?: TypeFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeFMPAS to fetch.
     */
    orderBy?: TypeFMPAOrderByWithRelationInput | TypeFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypeFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeFMPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypeFMPAS
    **/
    _count?: true | TypeFMPACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypeFMPAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypeFMPASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeFMPAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeFMPAMaxAggregateInputType
  }

  export type GetTypeFMPAAggregateType<T extends TypeFMPAAggregateArgs> = {
        [P in keyof T & keyof AggregateTypeFMPA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypeFMPA[P]>
      : GetScalarType<T[P], AggregateTypeFMPA[P]>
  }




  export type TypeFMPAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypeFMPAWhereInput
    orderBy?: TypeFMPAOrderByWithAggregationInput | TypeFMPAOrderByWithAggregationInput[]
    by: TypeFMPAScalarFieldEnum[] | TypeFMPAScalarFieldEnum
    having?: TypeFMPAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeFMPACountAggregateInputType | true
    _avg?: TypeFMPAAvgAggregateInputType
    _sum?: TypeFMPASumAggregateInputType
    _min?: TypeFMPAMinAggregateInputType
    _max?: TypeFMPAMaxAggregateInputType
  }

  export type TypeFMPAGroupByOutputType = {
    id: number
    code: string
    libelle: string
    dureeHeures: number
    obligatoire: boolean
    periodiciteMois: number | null
    description: string | null
    actif: boolean
    _count: TypeFMPACountAggregateOutputType | null
    _avg: TypeFMPAAvgAggregateOutputType | null
    _sum: TypeFMPASumAggregateOutputType | null
    _min: TypeFMPAMinAggregateOutputType | null
    _max: TypeFMPAMaxAggregateOutputType | null
  }

  type GetTypeFMPAGroupByPayload<T extends TypeFMPAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypeFMPAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeFMPAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeFMPAGroupByOutputType[P]>
            : GetScalarType<T[P], TypeFMPAGroupByOutputType[P]>
        }
      >
    >


  export type TypeFMPASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    dureeHeures?: boolean
    obligatoire?: boolean
    periodiciteMois?: boolean
    description?: boolean
    actif?: boolean
    sessions?: boolean | TypeFMPA$sessionsArgs<ExtArgs>
    _count?: boolean | TypeFMPACountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["typeFMPA"]>

  export type TypeFMPASelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    dureeHeures?: boolean
    obligatoire?: boolean
    periodiciteMois?: boolean
    description?: boolean
    actif?: boolean
  }, ExtArgs["result"]["typeFMPA"]>

  export type TypeFMPASelectScalar = {
    id?: boolean
    code?: boolean
    libelle?: boolean
    dureeHeures?: boolean
    obligatoire?: boolean
    periodiciteMois?: boolean
    description?: boolean
    actif?: boolean
  }

  export type TypeFMPAInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | TypeFMPA$sessionsArgs<ExtArgs>
    _count?: boolean | TypeFMPACountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TypeFMPAIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TypeFMPAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TypeFMPA"
    objects: {
      sessions: Prisma.$SessionFMPAPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      libelle: string
      dureeHeures: number
      obligatoire: boolean
      periodiciteMois: number | null
      description: string | null
      actif: boolean
    }, ExtArgs["result"]["typeFMPA"]>
    composites: {}
  }

  type TypeFMPAGetPayload<S extends boolean | null | undefined | TypeFMPADefaultArgs> = $Result.GetResult<Prisma.$TypeFMPAPayload, S>

  type TypeFMPACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TypeFMPAFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TypeFMPACountAggregateInputType | true
    }

  export interface TypeFMPADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TypeFMPA'], meta: { name: 'TypeFMPA' } }
    /**
     * Find zero or one TypeFMPA that matches the filter.
     * @param {TypeFMPAFindUniqueArgs} args - Arguments to find a TypeFMPA
     * @example
     * // Get one TypeFMPA
     * const typeFMPA = await prisma.typeFMPA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TypeFMPAFindUniqueArgs>(args: SelectSubset<T, TypeFMPAFindUniqueArgs<ExtArgs>>): Prisma__TypeFMPAClient<$Result.GetResult<Prisma.$TypeFMPAPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TypeFMPA that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TypeFMPAFindUniqueOrThrowArgs} args - Arguments to find a TypeFMPA
     * @example
     * // Get one TypeFMPA
     * const typeFMPA = await prisma.typeFMPA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TypeFMPAFindUniqueOrThrowArgs>(args: SelectSubset<T, TypeFMPAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TypeFMPAClient<$Result.GetResult<Prisma.$TypeFMPAPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TypeFMPA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFMPAFindFirstArgs} args - Arguments to find a TypeFMPA
     * @example
     * // Get one TypeFMPA
     * const typeFMPA = await prisma.typeFMPA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TypeFMPAFindFirstArgs>(args?: SelectSubset<T, TypeFMPAFindFirstArgs<ExtArgs>>): Prisma__TypeFMPAClient<$Result.GetResult<Prisma.$TypeFMPAPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TypeFMPA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFMPAFindFirstOrThrowArgs} args - Arguments to find a TypeFMPA
     * @example
     * // Get one TypeFMPA
     * const typeFMPA = await prisma.typeFMPA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TypeFMPAFindFirstOrThrowArgs>(args?: SelectSubset<T, TypeFMPAFindFirstOrThrowArgs<ExtArgs>>): Prisma__TypeFMPAClient<$Result.GetResult<Prisma.$TypeFMPAPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TypeFMPAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFMPAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypeFMPAS
     * const typeFMPAS = await prisma.typeFMPA.findMany()
     * 
     * // Get first 10 TypeFMPAS
     * const typeFMPAS = await prisma.typeFMPA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typeFMPAWithIdOnly = await prisma.typeFMPA.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TypeFMPAFindManyArgs>(args?: SelectSubset<T, TypeFMPAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypeFMPAPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TypeFMPA.
     * @param {TypeFMPACreateArgs} args - Arguments to create a TypeFMPA.
     * @example
     * // Create one TypeFMPA
     * const TypeFMPA = await prisma.typeFMPA.create({
     *   data: {
     *     // ... data to create a TypeFMPA
     *   }
     * })
     * 
     */
    create<T extends TypeFMPACreateArgs>(args: SelectSubset<T, TypeFMPACreateArgs<ExtArgs>>): Prisma__TypeFMPAClient<$Result.GetResult<Prisma.$TypeFMPAPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TypeFMPAS.
     * @param {TypeFMPACreateManyArgs} args - Arguments to create many TypeFMPAS.
     * @example
     * // Create many TypeFMPAS
     * const typeFMPA = await prisma.typeFMPA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TypeFMPACreateManyArgs>(args?: SelectSubset<T, TypeFMPACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TypeFMPAS and returns the data saved in the database.
     * @param {TypeFMPACreateManyAndReturnArgs} args - Arguments to create many TypeFMPAS.
     * @example
     * // Create many TypeFMPAS
     * const typeFMPA = await prisma.typeFMPA.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TypeFMPAS and only return the `id`
     * const typeFMPAWithIdOnly = await prisma.typeFMPA.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TypeFMPACreateManyAndReturnArgs>(args?: SelectSubset<T, TypeFMPACreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypeFMPAPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TypeFMPA.
     * @param {TypeFMPADeleteArgs} args - Arguments to delete one TypeFMPA.
     * @example
     * // Delete one TypeFMPA
     * const TypeFMPA = await prisma.typeFMPA.delete({
     *   where: {
     *     // ... filter to delete one TypeFMPA
     *   }
     * })
     * 
     */
    delete<T extends TypeFMPADeleteArgs>(args: SelectSubset<T, TypeFMPADeleteArgs<ExtArgs>>): Prisma__TypeFMPAClient<$Result.GetResult<Prisma.$TypeFMPAPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TypeFMPA.
     * @param {TypeFMPAUpdateArgs} args - Arguments to update one TypeFMPA.
     * @example
     * // Update one TypeFMPA
     * const typeFMPA = await prisma.typeFMPA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TypeFMPAUpdateArgs>(args: SelectSubset<T, TypeFMPAUpdateArgs<ExtArgs>>): Prisma__TypeFMPAClient<$Result.GetResult<Prisma.$TypeFMPAPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TypeFMPAS.
     * @param {TypeFMPADeleteManyArgs} args - Arguments to filter TypeFMPAS to delete.
     * @example
     * // Delete a few TypeFMPAS
     * const { count } = await prisma.typeFMPA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TypeFMPADeleteManyArgs>(args?: SelectSubset<T, TypeFMPADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypeFMPAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFMPAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypeFMPAS
     * const typeFMPA = await prisma.typeFMPA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TypeFMPAUpdateManyArgs>(args: SelectSubset<T, TypeFMPAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TypeFMPA.
     * @param {TypeFMPAUpsertArgs} args - Arguments to update or create a TypeFMPA.
     * @example
     * // Update or create a TypeFMPA
     * const typeFMPA = await prisma.typeFMPA.upsert({
     *   create: {
     *     // ... data to create a TypeFMPA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypeFMPA we want to update
     *   }
     * })
     */
    upsert<T extends TypeFMPAUpsertArgs>(args: SelectSubset<T, TypeFMPAUpsertArgs<ExtArgs>>): Prisma__TypeFMPAClient<$Result.GetResult<Prisma.$TypeFMPAPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TypeFMPAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFMPACountArgs} args - Arguments to filter TypeFMPAS to count.
     * @example
     * // Count the number of TypeFMPAS
     * const count = await prisma.typeFMPA.count({
     *   where: {
     *     // ... the filter for the TypeFMPAS we want to count
     *   }
     * })
    **/
    count<T extends TypeFMPACountArgs>(
      args?: Subset<T, TypeFMPACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeFMPACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypeFMPA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFMPAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeFMPAAggregateArgs>(args: Subset<T, TypeFMPAAggregateArgs>): Prisma.PrismaPromise<GetTypeFMPAAggregateType<T>>

    /**
     * Group by TypeFMPA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFMPAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeFMPAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeFMPAGroupByArgs['orderBy'] }
        : { orderBy?: TypeFMPAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeFMPAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeFMPAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TypeFMPA model
   */
  readonly fields: TypeFMPAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TypeFMPA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TypeFMPAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends TypeFMPA$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, TypeFMPA$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TypeFMPA model
   */ 
  interface TypeFMPAFieldRefs {
    readonly id: FieldRef<"TypeFMPA", 'Int'>
    readonly code: FieldRef<"TypeFMPA", 'String'>
    readonly libelle: FieldRef<"TypeFMPA", 'String'>
    readonly dureeHeures: FieldRef<"TypeFMPA", 'Float'>
    readonly obligatoire: FieldRef<"TypeFMPA", 'Boolean'>
    readonly periodiciteMois: FieldRef<"TypeFMPA", 'Int'>
    readonly description: FieldRef<"TypeFMPA", 'String'>
    readonly actif: FieldRef<"TypeFMPA", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TypeFMPA findUnique
   */
  export type TypeFMPAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeFMPA
     */
    select?: TypeFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeFMPAInclude<ExtArgs> | null
    /**
     * Filter, which TypeFMPA to fetch.
     */
    where: TypeFMPAWhereUniqueInput
  }

  /**
   * TypeFMPA findUniqueOrThrow
   */
  export type TypeFMPAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeFMPA
     */
    select?: TypeFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeFMPAInclude<ExtArgs> | null
    /**
     * Filter, which TypeFMPA to fetch.
     */
    where: TypeFMPAWhereUniqueInput
  }

  /**
   * TypeFMPA findFirst
   */
  export type TypeFMPAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeFMPA
     */
    select?: TypeFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeFMPAInclude<ExtArgs> | null
    /**
     * Filter, which TypeFMPA to fetch.
     */
    where?: TypeFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeFMPAS to fetch.
     */
    orderBy?: TypeFMPAOrderByWithRelationInput | TypeFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeFMPAS.
     */
    cursor?: TypeFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeFMPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeFMPAS.
     */
    distinct?: TypeFMPAScalarFieldEnum | TypeFMPAScalarFieldEnum[]
  }

  /**
   * TypeFMPA findFirstOrThrow
   */
  export type TypeFMPAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeFMPA
     */
    select?: TypeFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeFMPAInclude<ExtArgs> | null
    /**
     * Filter, which TypeFMPA to fetch.
     */
    where?: TypeFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeFMPAS to fetch.
     */
    orderBy?: TypeFMPAOrderByWithRelationInput | TypeFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeFMPAS.
     */
    cursor?: TypeFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeFMPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeFMPAS.
     */
    distinct?: TypeFMPAScalarFieldEnum | TypeFMPAScalarFieldEnum[]
  }

  /**
   * TypeFMPA findMany
   */
  export type TypeFMPAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeFMPA
     */
    select?: TypeFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeFMPAInclude<ExtArgs> | null
    /**
     * Filter, which TypeFMPAS to fetch.
     */
    where?: TypeFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeFMPAS to fetch.
     */
    orderBy?: TypeFMPAOrderByWithRelationInput | TypeFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypeFMPAS.
     */
    cursor?: TypeFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeFMPAS.
     */
    skip?: number
    distinct?: TypeFMPAScalarFieldEnum | TypeFMPAScalarFieldEnum[]
  }

  /**
   * TypeFMPA create
   */
  export type TypeFMPACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeFMPA
     */
    select?: TypeFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeFMPAInclude<ExtArgs> | null
    /**
     * The data needed to create a TypeFMPA.
     */
    data: XOR<TypeFMPACreateInput, TypeFMPAUncheckedCreateInput>
  }

  /**
   * TypeFMPA createMany
   */
  export type TypeFMPACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TypeFMPAS.
     */
    data: TypeFMPACreateManyInput | TypeFMPACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TypeFMPA createManyAndReturn
   */
  export type TypeFMPACreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeFMPA
     */
    select?: TypeFMPASelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TypeFMPAS.
     */
    data: TypeFMPACreateManyInput | TypeFMPACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TypeFMPA update
   */
  export type TypeFMPAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeFMPA
     */
    select?: TypeFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeFMPAInclude<ExtArgs> | null
    /**
     * The data needed to update a TypeFMPA.
     */
    data: XOR<TypeFMPAUpdateInput, TypeFMPAUncheckedUpdateInput>
    /**
     * Choose, which TypeFMPA to update.
     */
    where: TypeFMPAWhereUniqueInput
  }

  /**
   * TypeFMPA updateMany
   */
  export type TypeFMPAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TypeFMPAS.
     */
    data: XOR<TypeFMPAUpdateManyMutationInput, TypeFMPAUncheckedUpdateManyInput>
    /**
     * Filter which TypeFMPAS to update
     */
    where?: TypeFMPAWhereInput
  }

  /**
   * TypeFMPA upsert
   */
  export type TypeFMPAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeFMPA
     */
    select?: TypeFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeFMPAInclude<ExtArgs> | null
    /**
     * The filter to search for the TypeFMPA to update in case it exists.
     */
    where: TypeFMPAWhereUniqueInput
    /**
     * In case the TypeFMPA found by the `where` argument doesn't exist, create a new TypeFMPA with this data.
     */
    create: XOR<TypeFMPACreateInput, TypeFMPAUncheckedCreateInput>
    /**
     * In case the TypeFMPA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypeFMPAUpdateInput, TypeFMPAUncheckedUpdateInput>
  }

  /**
   * TypeFMPA delete
   */
  export type TypeFMPADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeFMPA
     */
    select?: TypeFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeFMPAInclude<ExtArgs> | null
    /**
     * Filter which TypeFMPA to delete.
     */
    where: TypeFMPAWhereUniqueInput
  }

  /**
   * TypeFMPA deleteMany
   */
  export type TypeFMPADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypeFMPAS to delete
     */
    where?: TypeFMPAWhereInput
  }

  /**
   * TypeFMPA.sessions
   */
  export type TypeFMPA$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAInclude<ExtArgs> | null
    where?: SessionFMPAWhereInput
    orderBy?: SessionFMPAOrderByWithRelationInput | SessionFMPAOrderByWithRelationInput[]
    cursor?: SessionFMPAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionFMPAScalarFieldEnum | SessionFMPAScalarFieldEnum[]
  }

  /**
   * TypeFMPA without action
   */
  export type TypeFMPADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeFMPA
     */
    select?: TypeFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeFMPAInclude<ExtArgs> | null
  }


  /**
   * Model SessionFMPA
   */

  export type AggregateSessionFMPA = {
    _count: SessionFMPACountAggregateOutputType | null
    _avg: SessionFMPAAvgAggregateOutputType | null
    _sum: SessionFMPASumAggregateOutputType | null
    _min: SessionFMPAMinAggregateOutputType | null
    _max: SessionFMPAMaxAggregateOutputType | null
  }

  export type SessionFMPAAvgAggregateOutputType = {
    id: number | null
    typeFMPAId: number | null
    centreId: number | null
    nombrePlacesMax: number | null
    nombreInscrits: number | null
    formateurPrincipalId: number | null
    tauxHoraire: number | null
  }

  export type SessionFMPASumAggregateOutputType = {
    id: number | null
    typeFMPAId: number | null
    centreId: number | null
    nombrePlacesMax: number | null
    nombreInscrits: number | null
    formateurPrincipalId: number | null
    tauxHoraire: number | null
  }

  export type SessionFMPAMinAggregateOutputType = {
    id: number | null
    typeFMPAId: number | null
    centreId: number | null
    dateDebut: Date | null
    dateFin: Date | null
    lieu: string | null
    nombrePlacesMax: number | null
    nombreInscrits: number | null
    formateurPrincipalId: number | null
    statut: $Enums.StatutSession | null
    codeTTA: string | null
    tauxHoraire: number | null
    commentaires: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionFMPAMaxAggregateOutputType = {
    id: number | null
    typeFMPAId: number | null
    centreId: number | null
    dateDebut: Date | null
    dateFin: Date | null
    lieu: string | null
    nombrePlacesMax: number | null
    nombreInscrits: number | null
    formateurPrincipalId: number | null
    statut: $Enums.StatutSession | null
    codeTTA: string | null
    tauxHoraire: number | null
    commentaires: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionFMPACountAggregateOutputType = {
    id: number
    typeFMPAId: number
    centreId: number
    dateDebut: number
    dateFin: number
    lieu: number
    nombrePlacesMax: number
    nombreInscrits: number
    formateurPrincipalId: number
    statut: number
    codeTTA: number
    tauxHoraire: number
    commentaires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionFMPAAvgAggregateInputType = {
    id?: true
    typeFMPAId?: true
    centreId?: true
    nombrePlacesMax?: true
    nombreInscrits?: true
    formateurPrincipalId?: true
    tauxHoraire?: true
  }

  export type SessionFMPASumAggregateInputType = {
    id?: true
    typeFMPAId?: true
    centreId?: true
    nombrePlacesMax?: true
    nombreInscrits?: true
    formateurPrincipalId?: true
    tauxHoraire?: true
  }

  export type SessionFMPAMinAggregateInputType = {
    id?: true
    typeFMPAId?: true
    centreId?: true
    dateDebut?: true
    dateFin?: true
    lieu?: true
    nombrePlacesMax?: true
    nombreInscrits?: true
    formateurPrincipalId?: true
    statut?: true
    codeTTA?: true
    tauxHoraire?: true
    commentaires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionFMPAMaxAggregateInputType = {
    id?: true
    typeFMPAId?: true
    centreId?: true
    dateDebut?: true
    dateFin?: true
    lieu?: true
    nombrePlacesMax?: true
    nombreInscrits?: true
    formateurPrincipalId?: true
    statut?: true
    codeTTA?: true
    tauxHoraire?: true
    commentaires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionFMPACountAggregateInputType = {
    id?: true
    typeFMPAId?: true
    centreId?: true
    dateDebut?: true
    dateFin?: true
    lieu?: true
    nombrePlacesMax?: true
    nombreInscrits?: true
    formateurPrincipalId?: true
    statut?: true
    codeTTA?: true
    tauxHoraire?: true
    commentaires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionFMPAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionFMPA to aggregate.
     */
    where?: SessionFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionFMPAS to fetch.
     */
    orderBy?: SessionFMPAOrderByWithRelationInput | SessionFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionFMPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionFMPAS
    **/
    _count?: true | SessionFMPACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionFMPAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionFMPASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionFMPAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionFMPAMaxAggregateInputType
  }

  export type GetSessionFMPAAggregateType<T extends SessionFMPAAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionFMPA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionFMPA[P]>
      : GetScalarType<T[P], AggregateSessionFMPA[P]>
  }




  export type SessionFMPAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionFMPAWhereInput
    orderBy?: SessionFMPAOrderByWithAggregationInput | SessionFMPAOrderByWithAggregationInput[]
    by: SessionFMPAScalarFieldEnum[] | SessionFMPAScalarFieldEnum
    having?: SessionFMPAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionFMPACountAggregateInputType | true
    _avg?: SessionFMPAAvgAggregateInputType
    _sum?: SessionFMPASumAggregateInputType
    _min?: SessionFMPAMinAggregateInputType
    _max?: SessionFMPAMaxAggregateInputType
  }

  export type SessionFMPAGroupByOutputType = {
    id: number
    typeFMPAId: number
    centreId: number | null
    dateDebut: Date
    dateFin: Date
    lieu: string | null
    nombrePlacesMax: number | null
    nombreInscrits: number
    formateurPrincipalId: number
    statut: $Enums.StatutSession
    codeTTA: string | null
    tauxHoraire: number | null
    commentaires: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionFMPACountAggregateOutputType | null
    _avg: SessionFMPAAvgAggregateOutputType | null
    _sum: SessionFMPASumAggregateOutputType | null
    _min: SessionFMPAMinAggregateOutputType | null
    _max: SessionFMPAMaxAggregateOutputType | null
  }

  type GetSessionFMPAGroupByPayload<T extends SessionFMPAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionFMPAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionFMPAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionFMPAGroupByOutputType[P]>
            : GetScalarType<T[P], SessionFMPAGroupByOutputType[P]>
        }
      >
    >


  export type SessionFMPASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeFMPAId?: boolean
    centreId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    lieu?: boolean
    nombrePlacesMax?: boolean
    nombreInscrits?: boolean
    formateurPrincipalId?: boolean
    statut?: boolean
    codeTTA?: boolean
    tauxHoraire?: boolean
    commentaires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    typeFMPA?: boolean | TypeFMPADefaultArgs<ExtArgs>
    centre?: boolean | SessionFMPA$centreArgs<ExtArgs>
    formateurPrincipal?: boolean | PersonnelDefaultArgs<ExtArgs>
    formateursAdditionnels?: boolean | SessionFMPA$formateursAdditionnelsArgs<ExtArgs>
    inscriptions?: boolean | SessionFMPA$inscriptionsArgs<ExtArgs>
    signatures?: boolean | SessionFMPA$signaturesArgs<ExtArgs>
    exportsTTA?: boolean | SessionFMPA$exportsTTAArgs<ExtArgs>
    _count?: boolean | SessionFMPACountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionFMPA"]>

  export type SessionFMPASelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeFMPAId?: boolean
    centreId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    lieu?: boolean
    nombrePlacesMax?: boolean
    nombreInscrits?: boolean
    formateurPrincipalId?: boolean
    statut?: boolean
    codeTTA?: boolean
    tauxHoraire?: boolean
    commentaires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    typeFMPA?: boolean | TypeFMPADefaultArgs<ExtArgs>
    centre?: boolean | SessionFMPA$centreArgs<ExtArgs>
    formateurPrincipal?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionFMPA"]>

  export type SessionFMPASelectScalar = {
    id?: boolean
    typeFMPAId?: boolean
    centreId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    lieu?: boolean
    nombrePlacesMax?: boolean
    nombreInscrits?: boolean
    formateurPrincipalId?: boolean
    statut?: boolean
    codeTTA?: boolean
    tauxHoraire?: boolean
    commentaires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionFMPAInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    typeFMPA?: boolean | TypeFMPADefaultArgs<ExtArgs>
    centre?: boolean | SessionFMPA$centreArgs<ExtArgs>
    formateurPrincipal?: boolean | PersonnelDefaultArgs<ExtArgs>
    formateursAdditionnels?: boolean | SessionFMPA$formateursAdditionnelsArgs<ExtArgs>
    inscriptions?: boolean | SessionFMPA$inscriptionsArgs<ExtArgs>
    signatures?: boolean | SessionFMPA$signaturesArgs<ExtArgs>
    exportsTTA?: boolean | SessionFMPA$exportsTTAArgs<ExtArgs>
    _count?: boolean | SessionFMPACountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessionFMPAIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    typeFMPA?: boolean | TypeFMPADefaultArgs<ExtArgs>
    centre?: boolean | SessionFMPA$centreArgs<ExtArgs>
    formateurPrincipal?: boolean | PersonnelDefaultArgs<ExtArgs>
  }

  export type $SessionFMPAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionFMPA"
    objects: {
      typeFMPA: Prisma.$TypeFMPAPayload<ExtArgs>
      centre: Prisma.$CentrePayload<ExtArgs> | null
      formateurPrincipal: Prisma.$PersonnelPayload<ExtArgs>
      formateursAdditionnels: Prisma.$SessionFMPAFormateurPayload<ExtArgs>[]
      inscriptions: Prisma.$InscriptionFMPAPayload<ExtArgs>[]
      signatures: Prisma.$SignatureFMPAPayload<ExtArgs>[]
      exportsTTA: Prisma.$ExportTTAPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      typeFMPAId: number
      centreId: number | null
      dateDebut: Date
      dateFin: Date
      lieu: string | null
      nombrePlacesMax: number | null
      nombreInscrits: number
      formateurPrincipalId: number
      statut: $Enums.StatutSession
      codeTTA: string | null
      tauxHoraire: number | null
      commentaires: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sessionFMPA"]>
    composites: {}
  }

  type SessionFMPAGetPayload<S extends boolean | null | undefined | SessionFMPADefaultArgs> = $Result.GetResult<Prisma.$SessionFMPAPayload, S>

  type SessionFMPACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFMPAFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionFMPACountAggregateInputType | true
    }

  export interface SessionFMPADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionFMPA'], meta: { name: 'SessionFMPA' } }
    /**
     * Find zero or one SessionFMPA that matches the filter.
     * @param {SessionFMPAFindUniqueArgs} args - Arguments to find a SessionFMPA
     * @example
     * // Get one SessionFMPA
     * const sessionFMPA = await prisma.sessionFMPA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFMPAFindUniqueArgs>(args: SelectSubset<T, SessionFMPAFindUniqueArgs<ExtArgs>>): Prisma__SessionFMPAClient<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionFMPA that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFMPAFindUniqueOrThrowArgs} args - Arguments to find a SessionFMPA
     * @example
     * // Get one SessionFMPA
     * const sessionFMPA = await prisma.sessionFMPA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFMPAFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFMPAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionFMPAClient<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionFMPA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFMPAFindFirstArgs} args - Arguments to find a SessionFMPA
     * @example
     * // Get one SessionFMPA
     * const sessionFMPA = await prisma.sessionFMPA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFMPAFindFirstArgs>(args?: SelectSubset<T, SessionFMPAFindFirstArgs<ExtArgs>>): Prisma__SessionFMPAClient<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionFMPA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFMPAFindFirstOrThrowArgs} args - Arguments to find a SessionFMPA
     * @example
     * // Get one SessionFMPA
     * const sessionFMPA = await prisma.sessionFMPA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFMPAFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFMPAFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionFMPAClient<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionFMPAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFMPAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionFMPAS
     * const sessionFMPAS = await prisma.sessionFMPA.findMany()
     * 
     * // Get first 10 SessionFMPAS
     * const sessionFMPAS = await prisma.sessionFMPA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionFMPAWithIdOnly = await prisma.sessionFMPA.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFMPAFindManyArgs>(args?: SelectSubset<T, SessionFMPAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionFMPA.
     * @param {SessionFMPACreateArgs} args - Arguments to create a SessionFMPA.
     * @example
     * // Create one SessionFMPA
     * const SessionFMPA = await prisma.sessionFMPA.create({
     *   data: {
     *     // ... data to create a SessionFMPA
     *   }
     * })
     * 
     */
    create<T extends SessionFMPACreateArgs>(args: SelectSubset<T, SessionFMPACreateArgs<ExtArgs>>): Prisma__SessionFMPAClient<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionFMPAS.
     * @param {SessionFMPACreateManyArgs} args - Arguments to create many SessionFMPAS.
     * @example
     * // Create many SessionFMPAS
     * const sessionFMPA = await prisma.sessionFMPA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionFMPACreateManyArgs>(args?: SelectSubset<T, SessionFMPACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionFMPAS and returns the data saved in the database.
     * @param {SessionFMPACreateManyAndReturnArgs} args - Arguments to create many SessionFMPAS.
     * @example
     * // Create many SessionFMPAS
     * const sessionFMPA = await prisma.sessionFMPA.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionFMPAS and only return the `id`
     * const sessionFMPAWithIdOnly = await prisma.sessionFMPA.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionFMPACreateManyAndReturnArgs>(args?: SelectSubset<T, SessionFMPACreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionFMPA.
     * @param {SessionFMPADeleteArgs} args - Arguments to delete one SessionFMPA.
     * @example
     * // Delete one SessionFMPA
     * const SessionFMPA = await prisma.sessionFMPA.delete({
     *   where: {
     *     // ... filter to delete one SessionFMPA
     *   }
     * })
     * 
     */
    delete<T extends SessionFMPADeleteArgs>(args: SelectSubset<T, SessionFMPADeleteArgs<ExtArgs>>): Prisma__SessionFMPAClient<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionFMPA.
     * @param {SessionFMPAUpdateArgs} args - Arguments to update one SessionFMPA.
     * @example
     * // Update one SessionFMPA
     * const sessionFMPA = await prisma.sessionFMPA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionFMPAUpdateArgs>(args: SelectSubset<T, SessionFMPAUpdateArgs<ExtArgs>>): Prisma__SessionFMPAClient<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionFMPAS.
     * @param {SessionFMPADeleteManyArgs} args - Arguments to filter SessionFMPAS to delete.
     * @example
     * // Delete a few SessionFMPAS
     * const { count } = await prisma.sessionFMPA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionFMPADeleteManyArgs>(args?: SelectSubset<T, SessionFMPADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionFMPAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFMPAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionFMPAS
     * const sessionFMPA = await prisma.sessionFMPA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionFMPAUpdateManyArgs>(args: SelectSubset<T, SessionFMPAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionFMPA.
     * @param {SessionFMPAUpsertArgs} args - Arguments to update or create a SessionFMPA.
     * @example
     * // Update or create a SessionFMPA
     * const sessionFMPA = await prisma.sessionFMPA.upsert({
     *   create: {
     *     // ... data to create a SessionFMPA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionFMPA we want to update
     *   }
     * })
     */
    upsert<T extends SessionFMPAUpsertArgs>(args: SelectSubset<T, SessionFMPAUpsertArgs<ExtArgs>>): Prisma__SessionFMPAClient<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionFMPAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFMPACountArgs} args - Arguments to filter SessionFMPAS to count.
     * @example
     * // Count the number of SessionFMPAS
     * const count = await prisma.sessionFMPA.count({
     *   where: {
     *     // ... the filter for the SessionFMPAS we want to count
     *   }
     * })
    **/
    count<T extends SessionFMPACountArgs>(
      args?: Subset<T, SessionFMPACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionFMPACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionFMPA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFMPAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionFMPAAggregateArgs>(args: Subset<T, SessionFMPAAggregateArgs>): Prisma.PrismaPromise<GetSessionFMPAAggregateType<T>>

    /**
     * Group by SessionFMPA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFMPAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionFMPAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionFMPAGroupByArgs['orderBy'] }
        : { orderBy?: SessionFMPAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionFMPAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionFMPAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionFMPA model
   */
  readonly fields: SessionFMPAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionFMPA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionFMPAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    typeFMPA<T extends TypeFMPADefaultArgs<ExtArgs> = {}>(args?: Subset<T, TypeFMPADefaultArgs<ExtArgs>>): Prisma__TypeFMPAClient<$Result.GetResult<Prisma.$TypeFMPAPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    centre<T extends SessionFMPA$centreArgs<ExtArgs> = {}>(args?: Subset<T, SessionFMPA$centreArgs<ExtArgs>>): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    formateurPrincipal<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    formateursAdditionnels<T extends SessionFMPA$formateursAdditionnelsArgs<ExtArgs> = {}>(args?: Subset<T, SessionFMPA$formateursAdditionnelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionFMPAFormateurPayload<ExtArgs>, T, "findMany"> | Null>
    inscriptions<T extends SessionFMPA$inscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, SessionFMPA$inscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscriptionFMPAPayload<ExtArgs>, T, "findMany"> | Null>
    signatures<T extends SessionFMPA$signaturesArgs<ExtArgs> = {}>(args?: Subset<T, SessionFMPA$signaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignatureFMPAPayload<ExtArgs>, T, "findMany"> | Null>
    exportsTTA<T extends SessionFMPA$exportsTTAArgs<ExtArgs> = {}>(args?: Subset<T, SessionFMPA$exportsTTAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportTTAPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionFMPA model
   */ 
  interface SessionFMPAFieldRefs {
    readonly id: FieldRef<"SessionFMPA", 'Int'>
    readonly typeFMPAId: FieldRef<"SessionFMPA", 'Int'>
    readonly centreId: FieldRef<"SessionFMPA", 'Int'>
    readonly dateDebut: FieldRef<"SessionFMPA", 'DateTime'>
    readonly dateFin: FieldRef<"SessionFMPA", 'DateTime'>
    readonly lieu: FieldRef<"SessionFMPA", 'String'>
    readonly nombrePlacesMax: FieldRef<"SessionFMPA", 'Int'>
    readonly nombreInscrits: FieldRef<"SessionFMPA", 'Int'>
    readonly formateurPrincipalId: FieldRef<"SessionFMPA", 'Int'>
    readonly statut: FieldRef<"SessionFMPA", 'StatutSession'>
    readonly codeTTA: FieldRef<"SessionFMPA", 'String'>
    readonly tauxHoraire: FieldRef<"SessionFMPA", 'Float'>
    readonly commentaires: FieldRef<"SessionFMPA", 'String'>
    readonly createdAt: FieldRef<"SessionFMPA", 'DateTime'>
    readonly updatedAt: FieldRef<"SessionFMPA", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionFMPA findUnique
   */
  export type SessionFMPAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAInclude<ExtArgs> | null
    /**
     * Filter, which SessionFMPA to fetch.
     */
    where: SessionFMPAWhereUniqueInput
  }

  /**
   * SessionFMPA findUniqueOrThrow
   */
  export type SessionFMPAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAInclude<ExtArgs> | null
    /**
     * Filter, which SessionFMPA to fetch.
     */
    where: SessionFMPAWhereUniqueInput
  }

  /**
   * SessionFMPA findFirst
   */
  export type SessionFMPAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAInclude<ExtArgs> | null
    /**
     * Filter, which SessionFMPA to fetch.
     */
    where?: SessionFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionFMPAS to fetch.
     */
    orderBy?: SessionFMPAOrderByWithRelationInput | SessionFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionFMPAS.
     */
    cursor?: SessionFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionFMPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionFMPAS.
     */
    distinct?: SessionFMPAScalarFieldEnum | SessionFMPAScalarFieldEnum[]
  }

  /**
   * SessionFMPA findFirstOrThrow
   */
  export type SessionFMPAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAInclude<ExtArgs> | null
    /**
     * Filter, which SessionFMPA to fetch.
     */
    where?: SessionFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionFMPAS to fetch.
     */
    orderBy?: SessionFMPAOrderByWithRelationInput | SessionFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionFMPAS.
     */
    cursor?: SessionFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionFMPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionFMPAS.
     */
    distinct?: SessionFMPAScalarFieldEnum | SessionFMPAScalarFieldEnum[]
  }

  /**
   * SessionFMPA findMany
   */
  export type SessionFMPAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAInclude<ExtArgs> | null
    /**
     * Filter, which SessionFMPAS to fetch.
     */
    where?: SessionFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionFMPAS to fetch.
     */
    orderBy?: SessionFMPAOrderByWithRelationInput | SessionFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionFMPAS.
     */
    cursor?: SessionFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionFMPAS.
     */
    skip?: number
    distinct?: SessionFMPAScalarFieldEnum | SessionFMPAScalarFieldEnum[]
  }

  /**
   * SessionFMPA create
   */
  export type SessionFMPACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionFMPA.
     */
    data: XOR<SessionFMPACreateInput, SessionFMPAUncheckedCreateInput>
  }

  /**
   * SessionFMPA createMany
   */
  export type SessionFMPACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionFMPAS.
     */
    data: SessionFMPACreateManyInput | SessionFMPACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionFMPA createManyAndReturn
   */
  export type SessionFMPACreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionFMPAS.
     */
    data: SessionFMPACreateManyInput | SessionFMPACreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionFMPA update
   */
  export type SessionFMPAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionFMPA.
     */
    data: XOR<SessionFMPAUpdateInput, SessionFMPAUncheckedUpdateInput>
    /**
     * Choose, which SessionFMPA to update.
     */
    where: SessionFMPAWhereUniqueInput
  }

  /**
   * SessionFMPA updateMany
   */
  export type SessionFMPAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionFMPAS.
     */
    data: XOR<SessionFMPAUpdateManyMutationInput, SessionFMPAUncheckedUpdateManyInput>
    /**
     * Filter which SessionFMPAS to update
     */
    where?: SessionFMPAWhereInput
  }

  /**
   * SessionFMPA upsert
   */
  export type SessionFMPAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionFMPA to update in case it exists.
     */
    where: SessionFMPAWhereUniqueInput
    /**
     * In case the SessionFMPA found by the `where` argument doesn't exist, create a new SessionFMPA with this data.
     */
    create: XOR<SessionFMPACreateInput, SessionFMPAUncheckedCreateInput>
    /**
     * In case the SessionFMPA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionFMPAUpdateInput, SessionFMPAUncheckedUpdateInput>
  }

  /**
   * SessionFMPA delete
   */
  export type SessionFMPADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAInclude<ExtArgs> | null
    /**
     * Filter which SessionFMPA to delete.
     */
    where: SessionFMPAWhereUniqueInput
  }

  /**
   * SessionFMPA deleteMany
   */
  export type SessionFMPADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionFMPAS to delete
     */
    where?: SessionFMPAWhereInput
  }

  /**
   * SessionFMPA.centre
   */
  export type SessionFMPA$centreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
    where?: CentreWhereInput
  }

  /**
   * SessionFMPA.formateursAdditionnels
   */
  export type SessionFMPA$formateursAdditionnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPAFormateur
     */
    select?: SessionFMPAFormateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAFormateurInclude<ExtArgs> | null
    where?: SessionFMPAFormateurWhereInput
    orderBy?: SessionFMPAFormateurOrderByWithRelationInput | SessionFMPAFormateurOrderByWithRelationInput[]
    cursor?: SessionFMPAFormateurWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionFMPAFormateurScalarFieldEnum | SessionFMPAFormateurScalarFieldEnum[]
  }

  /**
   * SessionFMPA.inscriptions
   */
  export type SessionFMPA$inscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InscriptionFMPA
     */
    select?: InscriptionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscriptionFMPAInclude<ExtArgs> | null
    where?: InscriptionFMPAWhereInput
    orderBy?: InscriptionFMPAOrderByWithRelationInput | InscriptionFMPAOrderByWithRelationInput[]
    cursor?: InscriptionFMPAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscriptionFMPAScalarFieldEnum | InscriptionFMPAScalarFieldEnum[]
  }

  /**
   * SessionFMPA.signatures
   */
  export type SessionFMPA$signaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignatureFMPA
     */
    select?: SignatureFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureFMPAInclude<ExtArgs> | null
    where?: SignatureFMPAWhereInput
    orderBy?: SignatureFMPAOrderByWithRelationInput | SignatureFMPAOrderByWithRelationInput[]
    cursor?: SignatureFMPAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignatureFMPAScalarFieldEnum | SignatureFMPAScalarFieldEnum[]
  }

  /**
   * SessionFMPA.exportsTTA
   */
  export type SessionFMPA$exportsTTAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAInclude<ExtArgs> | null
    where?: ExportTTAWhereInput
    orderBy?: ExportTTAOrderByWithRelationInput | ExportTTAOrderByWithRelationInput[]
    cursor?: ExportTTAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExportTTAScalarFieldEnum | ExportTTAScalarFieldEnum[]
  }

  /**
   * SessionFMPA without action
   */
  export type SessionFMPADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAInclude<ExtArgs> | null
  }


  /**
   * Model SessionFMPAFormateur
   */

  export type AggregateSessionFMPAFormateur = {
    _count: SessionFMPAFormateurCountAggregateOutputType | null
    _avg: SessionFMPAFormateurAvgAggregateOutputType | null
    _sum: SessionFMPAFormateurSumAggregateOutputType | null
    _min: SessionFMPAFormateurMinAggregateOutputType | null
    _max: SessionFMPAFormateurMaxAggregateOutputType | null
  }

  export type SessionFMPAFormateurAvgAggregateOutputType = {
    sessionId: number | null
    personnelId: number | null
  }

  export type SessionFMPAFormateurSumAggregateOutputType = {
    sessionId: number | null
    personnelId: number | null
  }

  export type SessionFMPAFormateurMinAggregateOutputType = {
    sessionId: number | null
    personnelId: number | null
  }

  export type SessionFMPAFormateurMaxAggregateOutputType = {
    sessionId: number | null
    personnelId: number | null
  }

  export type SessionFMPAFormateurCountAggregateOutputType = {
    sessionId: number
    personnelId: number
    _all: number
  }


  export type SessionFMPAFormateurAvgAggregateInputType = {
    sessionId?: true
    personnelId?: true
  }

  export type SessionFMPAFormateurSumAggregateInputType = {
    sessionId?: true
    personnelId?: true
  }

  export type SessionFMPAFormateurMinAggregateInputType = {
    sessionId?: true
    personnelId?: true
  }

  export type SessionFMPAFormateurMaxAggregateInputType = {
    sessionId?: true
    personnelId?: true
  }

  export type SessionFMPAFormateurCountAggregateInputType = {
    sessionId?: true
    personnelId?: true
    _all?: true
  }

  export type SessionFMPAFormateurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionFMPAFormateur to aggregate.
     */
    where?: SessionFMPAFormateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionFMPAFormateurs to fetch.
     */
    orderBy?: SessionFMPAFormateurOrderByWithRelationInput | SessionFMPAFormateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionFMPAFormateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionFMPAFormateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionFMPAFormateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionFMPAFormateurs
    **/
    _count?: true | SessionFMPAFormateurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionFMPAFormateurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionFMPAFormateurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionFMPAFormateurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionFMPAFormateurMaxAggregateInputType
  }

  export type GetSessionFMPAFormateurAggregateType<T extends SessionFMPAFormateurAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionFMPAFormateur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionFMPAFormateur[P]>
      : GetScalarType<T[P], AggregateSessionFMPAFormateur[P]>
  }




  export type SessionFMPAFormateurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionFMPAFormateurWhereInput
    orderBy?: SessionFMPAFormateurOrderByWithAggregationInput | SessionFMPAFormateurOrderByWithAggregationInput[]
    by: SessionFMPAFormateurScalarFieldEnum[] | SessionFMPAFormateurScalarFieldEnum
    having?: SessionFMPAFormateurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionFMPAFormateurCountAggregateInputType | true
    _avg?: SessionFMPAFormateurAvgAggregateInputType
    _sum?: SessionFMPAFormateurSumAggregateInputType
    _min?: SessionFMPAFormateurMinAggregateInputType
    _max?: SessionFMPAFormateurMaxAggregateInputType
  }

  export type SessionFMPAFormateurGroupByOutputType = {
    sessionId: number
    personnelId: number
    _count: SessionFMPAFormateurCountAggregateOutputType | null
    _avg: SessionFMPAFormateurAvgAggregateOutputType | null
    _sum: SessionFMPAFormateurSumAggregateOutputType | null
    _min: SessionFMPAFormateurMinAggregateOutputType | null
    _max: SessionFMPAFormateurMaxAggregateOutputType | null
  }

  type GetSessionFMPAFormateurGroupByPayload<T extends SessionFMPAFormateurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionFMPAFormateurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionFMPAFormateurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionFMPAFormateurGroupByOutputType[P]>
            : GetScalarType<T[P], SessionFMPAFormateurGroupByOutputType[P]>
        }
      >
    >


  export type SessionFMPAFormateurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    personnelId?: boolean
    session?: boolean | SessionFMPADefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionFMPAFormateur"]>

  export type SessionFMPAFormateurSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    personnelId?: boolean
    session?: boolean | SessionFMPADefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionFMPAFormateur"]>

  export type SessionFMPAFormateurSelectScalar = {
    sessionId?: boolean
    personnelId?: boolean
  }

  export type SessionFMPAFormateurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionFMPADefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }
  export type SessionFMPAFormateurIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionFMPADefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }

  export type $SessionFMPAFormateurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionFMPAFormateur"
    objects: {
      session: Prisma.$SessionFMPAPayload<ExtArgs>
      personnel: Prisma.$PersonnelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionId: number
      personnelId: number
    }, ExtArgs["result"]["sessionFMPAFormateur"]>
    composites: {}
  }

  type SessionFMPAFormateurGetPayload<S extends boolean | null | undefined | SessionFMPAFormateurDefaultArgs> = $Result.GetResult<Prisma.$SessionFMPAFormateurPayload, S>

  type SessionFMPAFormateurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFMPAFormateurFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionFMPAFormateurCountAggregateInputType | true
    }

  export interface SessionFMPAFormateurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionFMPAFormateur'], meta: { name: 'SessionFMPAFormateur' } }
    /**
     * Find zero or one SessionFMPAFormateur that matches the filter.
     * @param {SessionFMPAFormateurFindUniqueArgs} args - Arguments to find a SessionFMPAFormateur
     * @example
     * // Get one SessionFMPAFormateur
     * const sessionFMPAFormateur = await prisma.sessionFMPAFormateur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFMPAFormateurFindUniqueArgs>(args: SelectSubset<T, SessionFMPAFormateurFindUniqueArgs<ExtArgs>>): Prisma__SessionFMPAFormateurClient<$Result.GetResult<Prisma.$SessionFMPAFormateurPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionFMPAFormateur that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFMPAFormateurFindUniqueOrThrowArgs} args - Arguments to find a SessionFMPAFormateur
     * @example
     * // Get one SessionFMPAFormateur
     * const sessionFMPAFormateur = await prisma.sessionFMPAFormateur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFMPAFormateurFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFMPAFormateurFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionFMPAFormateurClient<$Result.GetResult<Prisma.$SessionFMPAFormateurPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionFMPAFormateur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFMPAFormateurFindFirstArgs} args - Arguments to find a SessionFMPAFormateur
     * @example
     * // Get one SessionFMPAFormateur
     * const sessionFMPAFormateur = await prisma.sessionFMPAFormateur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFMPAFormateurFindFirstArgs>(args?: SelectSubset<T, SessionFMPAFormateurFindFirstArgs<ExtArgs>>): Prisma__SessionFMPAFormateurClient<$Result.GetResult<Prisma.$SessionFMPAFormateurPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionFMPAFormateur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFMPAFormateurFindFirstOrThrowArgs} args - Arguments to find a SessionFMPAFormateur
     * @example
     * // Get one SessionFMPAFormateur
     * const sessionFMPAFormateur = await prisma.sessionFMPAFormateur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFMPAFormateurFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFMPAFormateurFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionFMPAFormateurClient<$Result.GetResult<Prisma.$SessionFMPAFormateurPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionFMPAFormateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFMPAFormateurFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionFMPAFormateurs
     * const sessionFMPAFormateurs = await prisma.sessionFMPAFormateur.findMany()
     * 
     * // Get first 10 SessionFMPAFormateurs
     * const sessionFMPAFormateurs = await prisma.sessionFMPAFormateur.findMany({ take: 10 })
     * 
     * // Only select the `sessionId`
     * const sessionFMPAFormateurWithSessionIdOnly = await prisma.sessionFMPAFormateur.findMany({ select: { sessionId: true } })
     * 
     */
    findMany<T extends SessionFMPAFormateurFindManyArgs>(args?: SelectSubset<T, SessionFMPAFormateurFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionFMPAFormateurPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionFMPAFormateur.
     * @param {SessionFMPAFormateurCreateArgs} args - Arguments to create a SessionFMPAFormateur.
     * @example
     * // Create one SessionFMPAFormateur
     * const SessionFMPAFormateur = await prisma.sessionFMPAFormateur.create({
     *   data: {
     *     // ... data to create a SessionFMPAFormateur
     *   }
     * })
     * 
     */
    create<T extends SessionFMPAFormateurCreateArgs>(args: SelectSubset<T, SessionFMPAFormateurCreateArgs<ExtArgs>>): Prisma__SessionFMPAFormateurClient<$Result.GetResult<Prisma.$SessionFMPAFormateurPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionFMPAFormateurs.
     * @param {SessionFMPAFormateurCreateManyArgs} args - Arguments to create many SessionFMPAFormateurs.
     * @example
     * // Create many SessionFMPAFormateurs
     * const sessionFMPAFormateur = await prisma.sessionFMPAFormateur.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionFMPAFormateurCreateManyArgs>(args?: SelectSubset<T, SessionFMPAFormateurCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionFMPAFormateurs and returns the data saved in the database.
     * @param {SessionFMPAFormateurCreateManyAndReturnArgs} args - Arguments to create many SessionFMPAFormateurs.
     * @example
     * // Create many SessionFMPAFormateurs
     * const sessionFMPAFormateur = await prisma.sessionFMPAFormateur.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionFMPAFormateurs and only return the `sessionId`
     * const sessionFMPAFormateurWithSessionIdOnly = await prisma.sessionFMPAFormateur.createManyAndReturn({ 
     *   select: { sessionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionFMPAFormateurCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionFMPAFormateurCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionFMPAFormateurPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionFMPAFormateur.
     * @param {SessionFMPAFormateurDeleteArgs} args - Arguments to delete one SessionFMPAFormateur.
     * @example
     * // Delete one SessionFMPAFormateur
     * const SessionFMPAFormateur = await prisma.sessionFMPAFormateur.delete({
     *   where: {
     *     // ... filter to delete one SessionFMPAFormateur
     *   }
     * })
     * 
     */
    delete<T extends SessionFMPAFormateurDeleteArgs>(args: SelectSubset<T, SessionFMPAFormateurDeleteArgs<ExtArgs>>): Prisma__SessionFMPAFormateurClient<$Result.GetResult<Prisma.$SessionFMPAFormateurPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionFMPAFormateur.
     * @param {SessionFMPAFormateurUpdateArgs} args - Arguments to update one SessionFMPAFormateur.
     * @example
     * // Update one SessionFMPAFormateur
     * const sessionFMPAFormateur = await prisma.sessionFMPAFormateur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionFMPAFormateurUpdateArgs>(args: SelectSubset<T, SessionFMPAFormateurUpdateArgs<ExtArgs>>): Prisma__SessionFMPAFormateurClient<$Result.GetResult<Prisma.$SessionFMPAFormateurPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionFMPAFormateurs.
     * @param {SessionFMPAFormateurDeleteManyArgs} args - Arguments to filter SessionFMPAFormateurs to delete.
     * @example
     * // Delete a few SessionFMPAFormateurs
     * const { count } = await prisma.sessionFMPAFormateur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionFMPAFormateurDeleteManyArgs>(args?: SelectSubset<T, SessionFMPAFormateurDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionFMPAFormateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFMPAFormateurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionFMPAFormateurs
     * const sessionFMPAFormateur = await prisma.sessionFMPAFormateur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionFMPAFormateurUpdateManyArgs>(args: SelectSubset<T, SessionFMPAFormateurUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionFMPAFormateur.
     * @param {SessionFMPAFormateurUpsertArgs} args - Arguments to update or create a SessionFMPAFormateur.
     * @example
     * // Update or create a SessionFMPAFormateur
     * const sessionFMPAFormateur = await prisma.sessionFMPAFormateur.upsert({
     *   create: {
     *     // ... data to create a SessionFMPAFormateur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionFMPAFormateur we want to update
     *   }
     * })
     */
    upsert<T extends SessionFMPAFormateurUpsertArgs>(args: SelectSubset<T, SessionFMPAFormateurUpsertArgs<ExtArgs>>): Prisma__SessionFMPAFormateurClient<$Result.GetResult<Prisma.$SessionFMPAFormateurPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionFMPAFormateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFMPAFormateurCountArgs} args - Arguments to filter SessionFMPAFormateurs to count.
     * @example
     * // Count the number of SessionFMPAFormateurs
     * const count = await prisma.sessionFMPAFormateur.count({
     *   where: {
     *     // ... the filter for the SessionFMPAFormateurs we want to count
     *   }
     * })
    **/
    count<T extends SessionFMPAFormateurCountArgs>(
      args?: Subset<T, SessionFMPAFormateurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionFMPAFormateurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionFMPAFormateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFMPAFormateurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionFMPAFormateurAggregateArgs>(args: Subset<T, SessionFMPAFormateurAggregateArgs>): Prisma.PrismaPromise<GetSessionFMPAFormateurAggregateType<T>>

    /**
     * Group by SessionFMPAFormateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFMPAFormateurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionFMPAFormateurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionFMPAFormateurGroupByArgs['orderBy'] }
        : { orderBy?: SessionFMPAFormateurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionFMPAFormateurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionFMPAFormateurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionFMPAFormateur model
   */
  readonly fields: SessionFMPAFormateurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionFMPAFormateur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionFMPAFormateurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionFMPADefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionFMPADefaultArgs<ExtArgs>>): Prisma__SessionFMPAClient<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    personnel<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionFMPAFormateur model
   */ 
  interface SessionFMPAFormateurFieldRefs {
    readonly sessionId: FieldRef<"SessionFMPAFormateur", 'Int'>
    readonly personnelId: FieldRef<"SessionFMPAFormateur", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SessionFMPAFormateur findUnique
   */
  export type SessionFMPAFormateurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPAFormateur
     */
    select?: SessionFMPAFormateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAFormateurInclude<ExtArgs> | null
    /**
     * Filter, which SessionFMPAFormateur to fetch.
     */
    where: SessionFMPAFormateurWhereUniqueInput
  }

  /**
   * SessionFMPAFormateur findUniqueOrThrow
   */
  export type SessionFMPAFormateurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPAFormateur
     */
    select?: SessionFMPAFormateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAFormateurInclude<ExtArgs> | null
    /**
     * Filter, which SessionFMPAFormateur to fetch.
     */
    where: SessionFMPAFormateurWhereUniqueInput
  }

  /**
   * SessionFMPAFormateur findFirst
   */
  export type SessionFMPAFormateurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPAFormateur
     */
    select?: SessionFMPAFormateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAFormateurInclude<ExtArgs> | null
    /**
     * Filter, which SessionFMPAFormateur to fetch.
     */
    where?: SessionFMPAFormateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionFMPAFormateurs to fetch.
     */
    orderBy?: SessionFMPAFormateurOrderByWithRelationInput | SessionFMPAFormateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionFMPAFormateurs.
     */
    cursor?: SessionFMPAFormateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionFMPAFormateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionFMPAFormateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionFMPAFormateurs.
     */
    distinct?: SessionFMPAFormateurScalarFieldEnum | SessionFMPAFormateurScalarFieldEnum[]
  }

  /**
   * SessionFMPAFormateur findFirstOrThrow
   */
  export type SessionFMPAFormateurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPAFormateur
     */
    select?: SessionFMPAFormateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAFormateurInclude<ExtArgs> | null
    /**
     * Filter, which SessionFMPAFormateur to fetch.
     */
    where?: SessionFMPAFormateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionFMPAFormateurs to fetch.
     */
    orderBy?: SessionFMPAFormateurOrderByWithRelationInput | SessionFMPAFormateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionFMPAFormateurs.
     */
    cursor?: SessionFMPAFormateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionFMPAFormateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionFMPAFormateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionFMPAFormateurs.
     */
    distinct?: SessionFMPAFormateurScalarFieldEnum | SessionFMPAFormateurScalarFieldEnum[]
  }

  /**
   * SessionFMPAFormateur findMany
   */
  export type SessionFMPAFormateurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPAFormateur
     */
    select?: SessionFMPAFormateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAFormateurInclude<ExtArgs> | null
    /**
     * Filter, which SessionFMPAFormateurs to fetch.
     */
    where?: SessionFMPAFormateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionFMPAFormateurs to fetch.
     */
    orderBy?: SessionFMPAFormateurOrderByWithRelationInput | SessionFMPAFormateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionFMPAFormateurs.
     */
    cursor?: SessionFMPAFormateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionFMPAFormateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionFMPAFormateurs.
     */
    skip?: number
    distinct?: SessionFMPAFormateurScalarFieldEnum | SessionFMPAFormateurScalarFieldEnum[]
  }

  /**
   * SessionFMPAFormateur create
   */
  export type SessionFMPAFormateurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPAFormateur
     */
    select?: SessionFMPAFormateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAFormateurInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionFMPAFormateur.
     */
    data: XOR<SessionFMPAFormateurCreateInput, SessionFMPAFormateurUncheckedCreateInput>
  }

  /**
   * SessionFMPAFormateur createMany
   */
  export type SessionFMPAFormateurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionFMPAFormateurs.
     */
    data: SessionFMPAFormateurCreateManyInput | SessionFMPAFormateurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionFMPAFormateur createManyAndReturn
   */
  export type SessionFMPAFormateurCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPAFormateur
     */
    select?: SessionFMPAFormateurSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionFMPAFormateurs.
     */
    data: SessionFMPAFormateurCreateManyInput | SessionFMPAFormateurCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAFormateurIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionFMPAFormateur update
   */
  export type SessionFMPAFormateurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPAFormateur
     */
    select?: SessionFMPAFormateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAFormateurInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionFMPAFormateur.
     */
    data: XOR<SessionFMPAFormateurUpdateInput, SessionFMPAFormateurUncheckedUpdateInput>
    /**
     * Choose, which SessionFMPAFormateur to update.
     */
    where: SessionFMPAFormateurWhereUniqueInput
  }

  /**
   * SessionFMPAFormateur updateMany
   */
  export type SessionFMPAFormateurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionFMPAFormateurs.
     */
    data: XOR<SessionFMPAFormateurUpdateManyMutationInput, SessionFMPAFormateurUncheckedUpdateManyInput>
    /**
     * Filter which SessionFMPAFormateurs to update
     */
    where?: SessionFMPAFormateurWhereInput
  }

  /**
   * SessionFMPAFormateur upsert
   */
  export type SessionFMPAFormateurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPAFormateur
     */
    select?: SessionFMPAFormateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAFormateurInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionFMPAFormateur to update in case it exists.
     */
    where: SessionFMPAFormateurWhereUniqueInput
    /**
     * In case the SessionFMPAFormateur found by the `where` argument doesn't exist, create a new SessionFMPAFormateur with this data.
     */
    create: XOR<SessionFMPAFormateurCreateInput, SessionFMPAFormateurUncheckedCreateInput>
    /**
     * In case the SessionFMPAFormateur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionFMPAFormateurUpdateInput, SessionFMPAFormateurUncheckedUpdateInput>
  }

  /**
   * SessionFMPAFormateur delete
   */
  export type SessionFMPAFormateurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPAFormateur
     */
    select?: SessionFMPAFormateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAFormateurInclude<ExtArgs> | null
    /**
     * Filter which SessionFMPAFormateur to delete.
     */
    where: SessionFMPAFormateurWhereUniqueInput
  }

  /**
   * SessionFMPAFormateur deleteMany
   */
  export type SessionFMPAFormateurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionFMPAFormateurs to delete
     */
    where?: SessionFMPAFormateurWhereInput
  }

  /**
   * SessionFMPAFormateur without action
   */
  export type SessionFMPAFormateurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPAFormateur
     */
    select?: SessionFMPAFormateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAFormateurInclude<ExtArgs> | null
  }


  /**
   * Model InscriptionFMPA
   */

  export type AggregateInscriptionFMPA = {
    _count: InscriptionFMPACountAggregateOutputType | null
    _avg: InscriptionFMPAAvgAggregateOutputType | null
    _sum: InscriptionFMPASumAggregateOutputType | null
    _min: InscriptionFMPAMinAggregateOutputType | null
    _max: InscriptionFMPAMaxAggregateOutputType | null
  }

  export type InscriptionFMPAAvgAggregateOutputType = {
    id: number | null
    sessionFMPAId: number | null
    personnelId: number | null
    noteEvaluation: number | null
    heuresValidees: number | null
    montantTTA: number | null
  }

  export type InscriptionFMPASumAggregateOutputType = {
    id: number | null
    sessionFMPAId: number | null
    personnelId: number | null
    noteEvaluation: number | null
    heuresValidees: number | null
    montantTTA: number | null
  }

  export type InscriptionFMPAMinAggregateOutputType = {
    id: number | null
    sessionFMPAId: number | null
    personnelId: number | null
    dateInscription: Date | null
    statutInscription: $Enums.StatutInscription | null
    heureArrivee: Date | null
    heureDepart: Date | null
    signatureElectronique: string | null
    dateSignature: Date | null
    noteEvaluation: number | null
    acquis: boolean | null
    commentaireFormateur: string | null
    heuresValidees: number | null
    montantTTA: number | null
    exportePaie: boolean | null
    dateExportPaie: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InscriptionFMPAMaxAggregateOutputType = {
    id: number | null
    sessionFMPAId: number | null
    personnelId: number | null
    dateInscription: Date | null
    statutInscription: $Enums.StatutInscription | null
    heureArrivee: Date | null
    heureDepart: Date | null
    signatureElectronique: string | null
    dateSignature: Date | null
    noteEvaluation: number | null
    acquis: boolean | null
    commentaireFormateur: string | null
    heuresValidees: number | null
    montantTTA: number | null
    exportePaie: boolean | null
    dateExportPaie: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InscriptionFMPACountAggregateOutputType = {
    id: number
    sessionFMPAId: number
    personnelId: number
    dateInscription: number
    statutInscription: number
    heureArrivee: number
    heureDepart: number
    signatureElectronique: number
    dateSignature: number
    noteEvaluation: number
    acquis: number
    commentaireFormateur: number
    heuresValidees: number
    montantTTA: number
    exportePaie: number
    dateExportPaie: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InscriptionFMPAAvgAggregateInputType = {
    id?: true
    sessionFMPAId?: true
    personnelId?: true
    noteEvaluation?: true
    heuresValidees?: true
    montantTTA?: true
  }

  export type InscriptionFMPASumAggregateInputType = {
    id?: true
    sessionFMPAId?: true
    personnelId?: true
    noteEvaluation?: true
    heuresValidees?: true
    montantTTA?: true
  }

  export type InscriptionFMPAMinAggregateInputType = {
    id?: true
    sessionFMPAId?: true
    personnelId?: true
    dateInscription?: true
    statutInscription?: true
    heureArrivee?: true
    heureDepart?: true
    signatureElectronique?: true
    dateSignature?: true
    noteEvaluation?: true
    acquis?: true
    commentaireFormateur?: true
    heuresValidees?: true
    montantTTA?: true
    exportePaie?: true
    dateExportPaie?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InscriptionFMPAMaxAggregateInputType = {
    id?: true
    sessionFMPAId?: true
    personnelId?: true
    dateInscription?: true
    statutInscription?: true
    heureArrivee?: true
    heureDepart?: true
    signatureElectronique?: true
    dateSignature?: true
    noteEvaluation?: true
    acquis?: true
    commentaireFormateur?: true
    heuresValidees?: true
    montantTTA?: true
    exportePaie?: true
    dateExportPaie?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InscriptionFMPACountAggregateInputType = {
    id?: true
    sessionFMPAId?: true
    personnelId?: true
    dateInscription?: true
    statutInscription?: true
    heureArrivee?: true
    heureDepart?: true
    signatureElectronique?: true
    dateSignature?: true
    noteEvaluation?: true
    acquis?: true
    commentaireFormateur?: true
    heuresValidees?: true
    montantTTA?: true
    exportePaie?: true
    dateExportPaie?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InscriptionFMPAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InscriptionFMPA to aggregate.
     */
    where?: InscriptionFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InscriptionFMPAS to fetch.
     */
    orderBy?: InscriptionFMPAOrderByWithRelationInput | InscriptionFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InscriptionFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InscriptionFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InscriptionFMPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InscriptionFMPAS
    **/
    _count?: true | InscriptionFMPACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InscriptionFMPAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InscriptionFMPASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InscriptionFMPAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InscriptionFMPAMaxAggregateInputType
  }

  export type GetInscriptionFMPAAggregateType<T extends InscriptionFMPAAggregateArgs> = {
        [P in keyof T & keyof AggregateInscriptionFMPA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInscriptionFMPA[P]>
      : GetScalarType<T[P], AggregateInscriptionFMPA[P]>
  }




  export type InscriptionFMPAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InscriptionFMPAWhereInput
    orderBy?: InscriptionFMPAOrderByWithAggregationInput | InscriptionFMPAOrderByWithAggregationInput[]
    by: InscriptionFMPAScalarFieldEnum[] | InscriptionFMPAScalarFieldEnum
    having?: InscriptionFMPAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InscriptionFMPACountAggregateInputType | true
    _avg?: InscriptionFMPAAvgAggregateInputType
    _sum?: InscriptionFMPASumAggregateInputType
    _min?: InscriptionFMPAMinAggregateInputType
    _max?: InscriptionFMPAMaxAggregateInputType
  }

  export type InscriptionFMPAGroupByOutputType = {
    id: number
    sessionFMPAId: number
    personnelId: number
    dateInscription: Date
    statutInscription: $Enums.StatutInscription
    heureArrivee: Date | null
    heureDepart: Date | null
    signatureElectronique: string | null
    dateSignature: Date | null
    noteEvaluation: number | null
    acquis: boolean | null
    commentaireFormateur: string | null
    heuresValidees: number | null
    montantTTA: number | null
    exportePaie: boolean
    dateExportPaie: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InscriptionFMPACountAggregateOutputType | null
    _avg: InscriptionFMPAAvgAggregateOutputType | null
    _sum: InscriptionFMPASumAggregateOutputType | null
    _min: InscriptionFMPAMinAggregateOutputType | null
    _max: InscriptionFMPAMaxAggregateOutputType | null
  }

  type GetInscriptionFMPAGroupByPayload<T extends InscriptionFMPAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InscriptionFMPAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InscriptionFMPAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InscriptionFMPAGroupByOutputType[P]>
            : GetScalarType<T[P], InscriptionFMPAGroupByOutputType[P]>
        }
      >
    >


  export type InscriptionFMPASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionFMPAId?: boolean
    personnelId?: boolean
    dateInscription?: boolean
    statutInscription?: boolean
    heureArrivee?: boolean
    heureDepart?: boolean
    signatureElectronique?: boolean
    dateSignature?: boolean
    noteEvaluation?: boolean
    acquis?: boolean
    commentaireFormateur?: boolean
    heuresValidees?: boolean
    montantTTA?: boolean
    exportePaie?: boolean
    dateExportPaie?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SessionFMPADefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inscriptionFMPA"]>

  export type InscriptionFMPASelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionFMPAId?: boolean
    personnelId?: boolean
    dateInscription?: boolean
    statutInscription?: boolean
    heureArrivee?: boolean
    heureDepart?: boolean
    signatureElectronique?: boolean
    dateSignature?: boolean
    noteEvaluation?: boolean
    acquis?: boolean
    commentaireFormateur?: boolean
    heuresValidees?: boolean
    montantTTA?: boolean
    exportePaie?: boolean
    dateExportPaie?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SessionFMPADefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inscriptionFMPA"]>

  export type InscriptionFMPASelectScalar = {
    id?: boolean
    sessionFMPAId?: boolean
    personnelId?: boolean
    dateInscription?: boolean
    statutInscription?: boolean
    heureArrivee?: boolean
    heureDepart?: boolean
    signatureElectronique?: boolean
    dateSignature?: boolean
    noteEvaluation?: boolean
    acquis?: boolean
    commentaireFormateur?: boolean
    heuresValidees?: boolean
    montantTTA?: boolean
    exportePaie?: boolean
    dateExportPaie?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InscriptionFMPAInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionFMPADefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }
  export type InscriptionFMPAIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionFMPADefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }

  export type $InscriptionFMPAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InscriptionFMPA"
    objects: {
      session: Prisma.$SessionFMPAPayload<ExtArgs>
      personnel: Prisma.$PersonnelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionFMPAId: number
      personnelId: number
      dateInscription: Date
      statutInscription: $Enums.StatutInscription
      heureArrivee: Date | null
      heureDepart: Date | null
      signatureElectronique: string | null
      dateSignature: Date | null
      noteEvaluation: number | null
      acquis: boolean | null
      commentaireFormateur: string | null
      heuresValidees: number | null
      montantTTA: number | null
      exportePaie: boolean
      dateExportPaie: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inscriptionFMPA"]>
    composites: {}
  }

  type InscriptionFMPAGetPayload<S extends boolean | null | undefined | InscriptionFMPADefaultArgs> = $Result.GetResult<Prisma.$InscriptionFMPAPayload, S>

  type InscriptionFMPACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InscriptionFMPAFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InscriptionFMPACountAggregateInputType | true
    }

  export interface InscriptionFMPADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InscriptionFMPA'], meta: { name: 'InscriptionFMPA' } }
    /**
     * Find zero or one InscriptionFMPA that matches the filter.
     * @param {InscriptionFMPAFindUniqueArgs} args - Arguments to find a InscriptionFMPA
     * @example
     * // Get one InscriptionFMPA
     * const inscriptionFMPA = await prisma.inscriptionFMPA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InscriptionFMPAFindUniqueArgs>(args: SelectSubset<T, InscriptionFMPAFindUniqueArgs<ExtArgs>>): Prisma__InscriptionFMPAClient<$Result.GetResult<Prisma.$InscriptionFMPAPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InscriptionFMPA that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InscriptionFMPAFindUniqueOrThrowArgs} args - Arguments to find a InscriptionFMPA
     * @example
     * // Get one InscriptionFMPA
     * const inscriptionFMPA = await prisma.inscriptionFMPA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InscriptionFMPAFindUniqueOrThrowArgs>(args: SelectSubset<T, InscriptionFMPAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InscriptionFMPAClient<$Result.GetResult<Prisma.$InscriptionFMPAPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InscriptionFMPA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionFMPAFindFirstArgs} args - Arguments to find a InscriptionFMPA
     * @example
     * // Get one InscriptionFMPA
     * const inscriptionFMPA = await prisma.inscriptionFMPA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InscriptionFMPAFindFirstArgs>(args?: SelectSubset<T, InscriptionFMPAFindFirstArgs<ExtArgs>>): Prisma__InscriptionFMPAClient<$Result.GetResult<Prisma.$InscriptionFMPAPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InscriptionFMPA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionFMPAFindFirstOrThrowArgs} args - Arguments to find a InscriptionFMPA
     * @example
     * // Get one InscriptionFMPA
     * const inscriptionFMPA = await prisma.inscriptionFMPA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InscriptionFMPAFindFirstOrThrowArgs>(args?: SelectSubset<T, InscriptionFMPAFindFirstOrThrowArgs<ExtArgs>>): Prisma__InscriptionFMPAClient<$Result.GetResult<Prisma.$InscriptionFMPAPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InscriptionFMPAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionFMPAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InscriptionFMPAS
     * const inscriptionFMPAS = await prisma.inscriptionFMPA.findMany()
     * 
     * // Get first 10 InscriptionFMPAS
     * const inscriptionFMPAS = await prisma.inscriptionFMPA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inscriptionFMPAWithIdOnly = await prisma.inscriptionFMPA.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InscriptionFMPAFindManyArgs>(args?: SelectSubset<T, InscriptionFMPAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscriptionFMPAPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InscriptionFMPA.
     * @param {InscriptionFMPACreateArgs} args - Arguments to create a InscriptionFMPA.
     * @example
     * // Create one InscriptionFMPA
     * const InscriptionFMPA = await prisma.inscriptionFMPA.create({
     *   data: {
     *     // ... data to create a InscriptionFMPA
     *   }
     * })
     * 
     */
    create<T extends InscriptionFMPACreateArgs>(args: SelectSubset<T, InscriptionFMPACreateArgs<ExtArgs>>): Prisma__InscriptionFMPAClient<$Result.GetResult<Prisma.$InscriptionFMPAPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InscriptionFMPAS.
     * @param {InscriptionFMPACreateManyArgs} args - Arguments to create many InscriptionFMPAS.
     * @example
     * // Create many InscriptionFMPAS
     * const inscriptionFMPA = await prisma.inscriptionFMPA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InscriptionFMPACreateManyArgs>(args?: SelectSubset<T, InscriptionFMPACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InscriptionFMPAS and returns the data saved in the database.
     * @param {InscriptionFMPACreateManyAndReturnArgs} args - Arguments to create many InscriptionFMPAS.
     * @example
     * // Create many InscriptionFMPAS
     * const inscriptionFMPA = await prisma.inscriptionFMPA.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InscriptionFMPAS and only return the `id`
     * const inscriptionFMPAWithIdOnly = await prisma.inscriptionFMPA.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InscriptionFMPACreateManyAndReturnArgs>(args?: SelectSubset<T, InscriptionFMPACreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InscriptionFMPAPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InscriptionFMPA.
     * @param {InscriptionFMPADeleteArgs} args - Arguments to delete one InscriptionFMPA.
     * @example
     * // Delete one InscriptionFMPA
     * const InscriptionFMPA = await prisma.inscriptionFMPA.delete({
     *   where: {
     *     // ... filter to delete one InscriptionFMPA
     *   }
     * })
     * 
     */
    delete<T extends InscriptionFMPADeleteArgs>(args: SelectSubset<T, InscriptionFMPADeleteArgs<ExtArgs>>): Prisma__InscriptionFMPAClient<$Result.GetResult<Prisma.$InscriptionFMPAPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InscriptionFMPA.
     * @param {InscriptionFMPAUpdateArgs} args - Arguments to update one InscriptionFMPA.
     * @example
     * // Update one InscriptionFMPA
     * const inscriptionFMPA = await prisma.inscriptionFMPA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InscriptionFMPAUpdateArgs>(args: SelectSubset<T, InscriptionFMPAUpdateArgs<ExtArgs>>): Prisma__InscriptionFMPAClient<$Result.GetResult<Prisma.$InscriptionFMPAPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InscriptionFMPAS.
     * @param {InscriptionFMPADeleteManyArgs} args - Arguments to filter InscriptionFMPAS to delete.
     * @example
     * // Delete a few InscriptionFMPAS
     * const { count } = await prisma.inscriptionFMPA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InscriptionFMPADeleteManyArgs>(args?: SelectSubset<T, InscriptionFMPADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InscriptionFMPAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionFMPAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InscriptionFMPAS
     * const inscriptionFMPA = await prisma.inscriptionFMPA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InscriptionFMPAUpdateManyArgs>(args: SelectSubset<T, InscriptionFMPAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InscriptionFMPA.
     * @param {InscriptionFMPAUpsertArgs} args - Arguments to update or create a InscriptionFMPA.
     * @example
     * // Update or create a InscriptionFMPA
     * const inscriptionFMPA = await prisma.inscriptionFMPA.upsert({
     *   create: {
     *     // ... data to create a InscriptionFMPA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InscriptionFMPA we want to update
     *   }
     * })
     */
    upsert<T extends InscriptionFMPAUpsertArgs>(args: SelectSubset<T, InscriptionFMPAUpsertArgs<ExtArgs>>): Prisma__InscriptionFMPAClient<$Result.GetResult<Prisma.$InscriptionFMPAPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InscriptionFMPAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionFMPACountArgs} args - Arguments to filter InscriptionFMPAS to count.
     * @example
     * // Count the number of InscriptionFMPAS
     * const count = await prisma.inscriptionFMPA.count({
     *   where: {
     *     // ... the filter for the InscriptionFMPAS we want to count
     *   }
     * })
    **/
    count<T extends InscriptionFMPACountArgs>(
      args?: Subset<T, InscriptionFMPACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InscriptionFMPACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InscriptionFMPA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionFMPAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InscriptionFMPAAggregateArgs>(args: Subset<T, InscriptionFMPAAggregateArgs>): Prisma.PrismaPromise<GetInscriptionFMPAAggregateType<T>>

    /**
     * Group by InscriptionFMPA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscriptionFMPAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InscriptionFMPAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InscriptionFMPAGroupByArgs['orderBy'] }
        : { orderBy?: InscriptionFMPAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InscriptionFMPAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInscriptionFMPAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InscriptionFMPA model
   */
  readonly fields: InscriptionFMPAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InscriptionFMPA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InscriptionFMPAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionFMPADefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionFMPADefaultArgs<ExtArgs>>): Prisma__SessionFMPAClient<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    personnel<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InscriptionFMPA model
   */ 
  interface InscriptionFMPAFieldRefs {
    readonly id: FieldRef<"InscriptionFMPA", 'Int'>
    readonly sessionFMPAId: FieldRef<"InscriptionFMPA", 'Int'>
    readonly personnelId: FieldRef<"InscriptionFMPA", 'Int'>
    readonly dateInscription: FieldRef<"InscriptionFMPA", 'DateTime'>
    readonly statutInscription: FieldRef<"InscriptionFMPA", 'StatutInscription'>
    readonly heureArrivee: FieldRef<"InscriptionFMPA", 'DateTime'>
    readonly heureDepart: FieldRef<"InscriptionFMPA", 'DateTime'>
    readonly signatureElectronique: FieldRef<"InscriptionFMPA", 'String'>
    readonly dateSignature: FieldRef<"InscriptionFMPA", 'DateTime'>
    readonly noteEvaluation: FieldRef<"InscriptionFMPA", 'Float'>
    readonly acquis: FieldRef<"InscriptionFMPA", 'Boolean'>
    readonly commentaireFormateur: FieldRef<"InscriptionFMPA", 'String'>
    readonly heuresValidees: FieldRef<"InscriptionFMPA", 'Float'>
    readonly montantTTA: FieldRef<"InscriptionFMPA", 'Float'>
    readonly exportePaie: FieldRef<"InscriptionFMPA", 'Boolean'>
    readonly dateExportPaie: FieldRef<"InscriptionFMPA", 'DateTime'>
    readonly createdAt: FieldRef<"InscriptionFMPA", 'DateTime'>
    readonly updatedAt: FieldRef<"InscriptionFMPA", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InscriptionFMPA findUnique
   */
  export type InscriptionFMPAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InscriptionFMPA
     */
    select?: InscriptionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscriptionFMPAInclude<ExtArgs> | null
    /**
     * Filter, which InscriptionFMPA to fetch.
     */
    where: InscriptionFMPAWhereUniqueInput
  }

  /**
   * InscriptionFMPA findUniqueOrThrow
   */
  export type InscriptionFMPAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InscriptionFMPA
     */
    select?: InscriptionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscriptionFMPAInclude<ExtArgs> | null
    /**
     * Filter, which InscriptionFMPA to fetch.
     */
    where: InscriptionFMPAWhereUniqueInput
  }

  /**
   * InscriptionFMPA findFirst
   */
  export type InscriptionFMPAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InscriptionFMPA
     */
    select?: InscriptionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscriptionFMPAInclude<ExtArgs> | null
    /**
     * Filter, which InscriptionFMPA to fetch.
     */
    where?: InscriptionFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InscriptionFMPAS to fetch.
     */
    orderBy?: InscriptionFMPAOrderByWithRelationInput | InscriptionFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InscriptionFMPAS.
     */
    cursor?: InscriptionFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InscriptionFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InscriptionFMPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InscriptionFMPAS.
     */
    distinct?: InscriptionFMPAScalarFieldEnum | InscriptionFMPAScalarFieldEnum[]
  }

  /**
   * InscriptionFMPA findFirstOrThrow
   */
  export type InscriptionFMPAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InscriptionFMPA
     */
    select?: InscriptionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscriptionFMPAInclude<ExtArgs> | null
    /**
     * Filter, which InscriptionFMPA to fetch.
     */
    where?: InscriptionFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InscriptionFMPAS to fetch.
     */
    orderBy?: InscriptionFMPAOrderByWithRelationInput | InscriptionFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InscriptionFMPAS.
     */
    cursor?: InscriptionFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InscriptionFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InscriptionFMPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InscriptionFMPAS.
     */
    distinct?: InscriptionFMPAScalarFieldEnum | InscriptionFMPAScalarFieldEnum[]
  }

  /**
   * InscriptionFMPA findMany
   */
  export type InscriptionFMPAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InscriptionFMPA
     */
    select?: InscriptionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscriptionFMPAInclude<ExtArgs> | null
    /**
     * Filter, which InscriptionFMPAS to fetch.
     */
    where?: InscriptionFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InscriptionFMPAS to fetch.
     */
    orderBy?: InscriptionFMPAOrderByWithRelationInput | InscriptionFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InscriptionFMPAS.
     */
    cursor?: InscriptionFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InscriptionFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InscriptionFMPAS.
     */
    skip?: number
    distinct?: InscriptionFMPAScalarFieldEnum | InscriptionFMPAScalarFieldEnum[]
  }

  /**
   * InscriptionFMPA create
   */
  export type InscriptionFMPACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InscriptionFMPA
     */
    select?: InscriptionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscriptionFMPAInclude<ExtArgs> | null
    /**
     * The data needed to create a InscriptionFMPA.
     */
    data: XOR<InscriptionFMPACreateInput, InscriptionFMPAUncheckedCreateInput>
  }

  /**
   * InscriptionFMPA createMany
   */
  export type InscriptionFMPACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InscriptionFMPAS.
     */
    data: InscriptionFMPACreateManyInput | InscriptionFMPACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InscriptionFMPA createManyAndReturn
   */
  export type InscriptionFMPACreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InscriptionFMPA
     */
    select?: InscriptionFMPASelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InscriptionFMPAS.
     */
    data: InscriptionFMPACreateManyInput | InscriptionFMPACreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscriptionFMPAIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InscriptionFMPA update
   */
  export type InscriptionFMPAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InscriptionFMPA
     */
    select?: InscriptionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscriptionFMPAInclude<ExtArgs> | null
    /**
     * The data needed to update a InscriptionFMPA.
     */
    data: XOR<InscriptionFMPAUpdateInput, InscriptionFMPAUncheckedUpdateInput>
    /**
     * Choose, which InscriptionFMPA to update.
     */
    where: InscriptionFMPAWhereUniqueInput
  }

  /**
   * InscriptionFMPA updateMany
   */
  export type InscriptionFMPAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InscriptionFMPAS.
     */
    data: XOR<InscriptionFMPAUpdateManyMutationInput, InscriptionFMPAUncheckedUpdateManyInput>
    /**
     * Filter which InscriptionFMPAS to update
     */
    where?: InscriptionFMPAWhereInput
  }

  /**
   * InscriptionFMPA upsert
   */
  export type InscriptionFMPAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InscriptionFMPA
     */
    select?: InscriptionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscriptionFMPAInclude<ExtArgs> | null
    /**
     * The filter to search for the InscriptionFMPA to update in case it exists.
     */
    where: InscriptionFMPAWhereUniqueInput
    /**
     * In case the InscriptionFMPA found by the `where` argument doesn't exist, create a new InscriptionFMPA with this data.
     */
    create: XOR<InscriptionFMPACreateInput, InscriptionFMPAUncheckedCreateInput>
    /**
     * In case the InscriptionFMPA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InscriptionFMPAUpdateInput, InscriptionFMPAUncheckedUpdateInput>
  }

  /**
   * InscriptionFMPA delete
   */
  export type InscriptionFMPADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InscriptionFMPA
     */
    select?: InscriptionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscriptionFMPAInclude<ExtArgs> | null
    /**
     * Filter which InscriptionFMPA to delete.
     */
    where: InscriptionFMPAWhereUniqueInput
  }

  /**
   * InscriptionFMPA deleteMany
   */
  export type InscriptionFMPADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InscriptionFMPAS to delete
     */
    where?: InscriptionFMPAWhereInput
  }

  /**
   * InscriptionFMPA without action
   */
  export type InscriptionFMPADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InscriptionFMPA
     */
    select?: InscriptionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InscriptionFMPAInclude<ExtArgs> | null
  }


  /**
   * Model SignatureFMPA
   */

  export type AggregateSignatureFMPA = {
    _count: SignatureFMPACountAggregateOutputType | null
    _avg: SignatureFMPAAvgAggregateOutputType | null
    _sum: SignatureFMPASumAggregateOutputType | null
    _min: SignatureFMPAMinAggregateOutputType | null
    _max: SignatureFMPAMaxAggregateOutputType | null
  }

  export type SignatureFMPAAvgAggregateOutputType = {
    sessionFMPAId: number | null
    personnelId: number | null
  }

  export type SignatureFMPASumAggregateOutputType = {
    sessionFMPAId: number | null
    personnelId: number | null
  }

  export type SignatureFMPAMinAggregateOutputType = {
    id: string | null
    sessionFMPAId: number | null
    personnelId: number | null
    type: string | null
    signature: string | null
    dateSignature: Date | null
  }

  export type SignatureFMPAMaxAggregateOutputType = {
    id: string | null
    sessionFMPAId: number | null
    personnelId: number | null
    type: string | null
    signature: string | null
    dateSignature: Date | null
  }

  export type SignatureFMPACountAggregateOutputType = {
    id: number
    sessionFMPAId: number
    personnelId: number
    type: number
    signature: number
    dateSignature: number
    _all: number
  }


  export type SignatureFMPAAvgAggregateInputType = {
    sessionFMPAId?: true
    personnelId?: true
  }

  export type SignatureFMPASumAggregateInputType = {
    sessionFMPAId?: true
    personnelId?: true
  }

  export type SignatureFMPAMinAggregateInputType = {
    id?: true
    sessionFMPAId?: true
    personnelId?: true
    type?: true
    signature?: true
    dateSignature?: true
  }

  export type SignatureFMPAMaxAggregateInputType = {
    id?: true
    sessionFMPAId?: true
    personnelId?: true
    type?: true
    signature?: true
    dateSignature?: true
  }

  export type SignatureFMPACountAggregateInputType = {
    id?: true
    sessionFMPAId?: true
    personnelId?: true
    type?: true
    signature?: true
    dateSignature?: true
    _all?: true
  }

  export type SignatureFMPAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SignatureFMPA to aggregate.
     */
    where?: SignatureFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignatureFMPAS to fetch.
     */
    orderBy?: SignatureFMPAOrderByWithRelationInput | SignatureFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SignatureFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignatureFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignatureFMPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SignatureFMPAS
    **/
    _count?: true | SignatureFMPACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SignatureFMPAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SignatureFMPASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignatureFMPAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignatureFMPAMaxAggregateInputType
  }

  export type GetSignatureFMPAAggregateType<T extends SignatureFMPAAggregateArgs> = {
        [P in keyof T & keyof AggregateSignatureFMPA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignatureFMPA[P]>
      : GetScalarType<T[P], AggregateSignatureFMPA[P]>
  }




  export type SignatureFMPAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignatureFMPAWhereInput
    orderBy?: SignatureFMPAOrderByWithAggregationInput | SignatureFMPAOrderByWithAggregationInput[]
    by: SignatureFMPAScalarFieldEnum[] | SignatureFMPAScalarFieldEnum
    having?: SignatureFMPAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignatureFMPACountAggregateInputType | true
    _avg?: SignatureFMPAAvgAggregateInputType
    _sum?: SignatureFMPASumAggregateInputType
    _min?: SignatureFMPAMinAggregateInputType
    _max?: SignatureFMPAMaxAggregateInputType
  }

  export type SignatureFMPAGroupByOutputType = {
    id: string
    sessionFMPAId: number
    personnelId: number
    type: string
    signature: string
    dateSignature: Date
    _count: SignatureFMPACountAggregateOutputType | null
    _avg: SignatureFMPAAvgAggregateOutputType | null
    _sum: SignatureFMPASumAggregateOutputType | null
    _min: SignatureFMPAMinAggregateOutputType | null
    _max: SignatureFMPAMaxAggregateOutputType | null
  }

  type GetSignatureFMPAGroupByPayload<T extends SignatureFMPAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignatureFMPAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignatureFMPAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignatureFMPAGroupByOutputType[P]>
            : GetScalarType<T[P], SignatureFMPAGroupByOutputType[P]>
        }
      >
    >


  export type SignatureFMPASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionFMPAId?: boolean
    personnelId?: boolean
    type?: boolean
    signature?: boolean
    dateSignature?: boolean
    session?: boolean | SessionFMPADefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signatureFMPA"]>

  export type SignatureFMPASelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionFMPAId?: boolean
    personnelId?: boolean
    type?: boolean
    signature?: boolean
    dateSignature?: boolean
    session?: boolean | SessionFMPADefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signatureFMPA"]>

  export type SignatureFMPASelectScalar = {
    id?: boolean
    sessionFMPAId?: boolean
    personnelId?: boolean
    type?: boolean
    signature?: boolean
    dateSignature?: boolean
  }

  export type SignatureFMPAInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionFMPADefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }
  export type SignatureFMPAIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionFMPADefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }

  export type $SignatureFMPAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SignatureFMPA"
    objects: {
      session: Prisma.$SessionFMPAPayload<ExtArgs>
      personnel: Prisma.$PersonnelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionFMPAId: number
      personnelId: number
      type: string
      signature: string
      dateSignature: Date
    }, ExtArgs["result"]["signatureFMPA"]>
    composites: {}
  }

  type SignatureFMPAGetPayload<S extends boolean | null | undefined | SignatureFMPADefaultArgs> = $Result.GetResult<Prisma.$SignatureFMPAPayload, S>

  type SignatureFMPACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SignatureFMPAFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SignatureFMPACountAggregateInputType | true
    }

  export interface SignatureFMPADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SignatureFMPA'], meta: { name: 'SignatureFMPA' } }
    /**
     * Find zero or one SignatureFMPA that matches the filter.
     * @param {SignatureFMPAFindUniqueArgs} args - Arguments to find a SignatureFMPA
     * @example
     * // Get one SignatureFMPA
     * const signatureFMPA = await prisma.signatureFMPA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SignatureFMPAFindUniqueArgs>(args: SelectSubset<T, SignatureFMPAFindUniqueArgs<ExtArgs>>): Prisma__SignatureFMPAClient<$Result.GetResult<Prisma.$SignatureFMPAPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SignatureFMPA that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SignatureFMPAFindUniqueOrThrowArgs} args - Arguments to find a SignatureFMPA
     * @example
     * // Get one SignatureFMPA
     * const signatureFMPA = await prisma.signatureFMPA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SignatureFMPAFindUniqueOrThrowArgs>(args: SelectSubset<T, SignatureFMPAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SignatureFMPAClient<$Result.GetResult<Prisma.$SignatureFMPAPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SignatureFMPA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFMPAFindFirstArgs} args - Arguments to find a SignatureFMPA
     * @example
     * // Get one SignatureFMPA
     * const signatureFMPA = await prisma.signatureFMPA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SignatureFMPAFindFirstArgs>(args?: SelectSubset<T, SignatureFMPAFindFirstArgs<ExtArgs>>): Prisma__SignatureFMPAClient<$Result.GetResult<Prisma.$SignatureFMPAPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SignatureFMPA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFMPAFindFirstOrThrowArgs} args - Arguments to find a SignatureFMPA
     * @example
     * // Get one SignatureFMPA
     * const signatureFMPA = await prisma.signatureFMPA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SignatureFMPAFindFirstOrThrowArgs>(args?: SelectSubset<T, SignatureFMPAFindFirstOrThrowArgs<ExtArgs>>): Prisma__SignatureFMPAClient<$Result.GetResult<Prisma.$SignatureFMPAPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SignatureFMPAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFMPAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SignatureFMPAS
     * const signatureFMPAS = await prisma.signatureFMPA.findMany()
     * 
     * // Get first 10 SignatureFMPAS
     * const signatureFMPAS = await prisma.signatureFMPA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signatureFMPAWithIdOnly = await prisma.signatureFMPA.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SignatureFMPAFindManyArgs>(args?: SelectSubset<T, SignatureFMPAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignatureFMPAPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SignatureFMPA.
     * @param {SignatureFMPACreateArgs} args - Arguments to create a SignatureFMPA.
     * @example
     * // Create one SignatureFMPA
     * const SignatureFMPA = await prisma.signatureFMPA.create({
     *   data: {
     *     // ... data to create a SignatureFMPA
     *   }
     * })
     * 
     */
    create<T extends SignatureFMPACreateArgs>(args: SelectSubset<T, SignatureFMPACreateArgs<ExtArgs>>): Prisma__SignatureFMPAClient<$Result.GetResult<Prisma.$SignatureFMPAPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SignatureFMPAS.
     * @param {SignatureFMPACreateManyArgs} args - Arguments to create many SignatureFMPAS.
     * @example
     * // Create many SignatureFMPAS
     * const signatureFMPA = await prisma.signatureFMPA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SignatureFMPACreateManyArgs>(args?: SelectSubset<T, SignatureFMPACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SignatureFMPAS and returns the data saved in the database.
     * @param {SignatureFMPACreateManyAndReturnArgs} args - Arguments to create many SignatureFMPAS.
     * @example
     * // Create many SignatureFMPAS
     * const signatureFMPA = await prisma.signatureFMPA.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SignatureFMPAS and only return the `id`
     * const signatureFMPAWithIdOnly = await prisma.signatureFMPA.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SignatureFMPACreateManyAndReturnArgs>(args?: SelectSubset<T, SignatureFMPACreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignatureFMPAPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SignatureFMPA.
     * @param {SignatureFMPADeleteArgs} args - Arguments to delete one SignatureFMPA.
     * @example
     * // Delete one SignatureFMPA
     * const SignatureFMPA = await prisma.signatureFMPA.delete({
     *   where: {
     *     // ... filter to delete one SignatureFMPA
     *   }
     * })
     * 
     */
    delete<T extends SignatureFMPADeleteArgs>(args: SelectSubset<T, SignatureFMPADeleteArgs<ExtArgs>>): Prisma__SignatureFMPAClient<$Result.GetResult<Prisma.$SignatureFMPAPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SignatureFMPA.
     * @param {SignatureFMPAUpdateArgs} args - Arguments to update one SignatureFMPA.
     * @example
     * // Update one SignatureFMPA
     * const signatureFMPA = await prisma.signatureFMPA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SignatureFMPAUpdateArgs>(args: SelectSubset<T, SignatureFMPAUpdateArgs<ExtArgs>>): Prisma__SignatureFMPAClient<$Result.GetResult<Prisma.$SignatureFMPAPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SignatureFMPAS.
     * @param {SignatureFMPADeleteManyArgs} args - Arguments to filter SignatureFMPAS to delete.
     * @example
     * // Delete a few SignatureFMPAS
     * const { count } = await prisma.signatureFMPA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SignatureFMPADeleteManyArgs>(args?: SelectSubset<T, SignatureFMPADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SignatureFMPAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFMPAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SignatureFMPAS
     * const signatureFMPA = await prisma.signatureFMPA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SignatureFMPAUpdateManyArgs>(args: SelectSubset<T, SignatureFMPAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SignatureFMPA.
     * @param {SignatureFMPAUpsertArgs} args - Arguments to update or create a SignatureFMPA.
     * @example
     * // Update or create a SignatureFMPA
     * const signatureFMPA = await prisma.signatureFMPA.upsert({
     *   create: {
     *     // ... data to create a SignatureFMPA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SignatureFMPA we want to update
     *   }
     * })
     */
    upsert<T extends SignatureFMPAUpsertArgs>(args: SelectSubset<T, SignatureFMPAUpsertArgs<ExtArgs>>): Prisma__SignatureFMPAClient<$Result.GetResult<Prisma.$SignatureFMPAPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SignatureFMPAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFMPACountArgs} args - Arguments to filter SignatureFMPAS to count.
     * @example
     * // Count the number of SignatureFMPAS
     * const count = await prisma.signatureFMPA.count({
     *   where: {
     *     // ... the filter for the SignatureFMPAS we want to count
     *   }
     * })
    **/
    count<T extends SignatureFMPACountArgs>(
      args?: Subset<T, SignatureFMPACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignatureFMPACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SignatureFMPA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFMPAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignatureFMPAAggregateArgs>(args: Subset<T, SignatureFMPAAggregateArgs>): Prisma.PrismaPromise<GetSignatureFMPAAggregateType<T>>

    /**
     * Group by SignatureFMPA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFMPAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignatureFMPAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignatureFMPAGroupByArgs['orderBy'] }
        : { orderBy?: SignatureFMPAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignatureFMPAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignatureFMPAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SignatureFMPA model
   */
  readonly fields: SignatureFMPAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SignatureFMPA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SignatureFMPAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionFMPADefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionFMPADefaultArgs<ExtArgs>>): Prisma__SessionFMPAClient<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    personnel<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SignatureFMPA model
   */ 
  interface SignatureFMPAFieldRefs {
    readonly id: FieldRef<"SignatureFMPA", 'String'>
    readonly sessionFMPAId: FieldRef<"SignatureFMPA", 'Int'>
    readonly personnelId: FieldRef<"SignatureFMPA", 'Int'>
    readonly type: FieldRef<"SignatureFMPA", 'String'>
    readonly signature: FieldRef<"SignatureFMPA", 'String'>
    readonly dateSignature: FieldRef<"SignatureFMPA", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SignatureFMPA findUnique
   */
  export type SignatureFMPAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignatureFMPA
     */
    select?: SignatureFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureFMPAInclude<ExtArgs> | null
    /**
     * Filter, which SignatureFMPA to fetch.
     */
    where: SignatureFMPAWhereUniqueInput
  }

  /**
   * SignatureFMPA findUniqueOrThrow
   */
  export type SignatureFMPAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignatureFMPA
     */
    select?: SignatureFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureFMPAInclude<ExtArgs> | null
    /**
     * Filter, which SignatureFMPA to fetch.
     */
    where: SignatureFMPAWhereUniqueInput
  }

  /**
   * SignatureFMPA findFirst
   */
  export type SignatureFMPAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignatureFMPA
     */
    select?: SignatureFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureFMPAInclude<ExtArgs> | null
    /**
     * Filter, which SignatureFMPA to fetch.
     */
    where?: SignatureFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignatureFMPAS to fetch.
     */
    orderBy?: SignatureFMPAOrderByWithRelationInput | SignatureFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SignatureFMPAS.
     */
    cursor?: SignatureFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignatureFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignatureFMPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SignatureFMPAS.
     */
    distinct?: SignatureFMPAScalarFieldEnum | SignatureFMPAScalarFieldEnum[]
  }

  /**
   * SignatureFMPA findFirstOrThrow
   */
  export type SignatureFMPAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignatureFMPA
     */
    select?: SignatureFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureFMPAInclude<ExtArgs> | null
    /**
     * Filter, which SignatureFMPA to fetch.
     */
    where?: SignatureFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignatureFMPAS to fetch.
     */
    orderBy?: SignatureFMPAOrderByWithRelationInput | SignatureFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SignatureFMPAS.
     */
    cursor?: SignatureFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignatureFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignatureFMPAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SignatureFMPAS.
     */
    distinct?: SignatureFMPAScalarFieldEnum | SignatureFMPAScalarFieldEnum[]
  }

  /**
   * SignatureFMPA findMany
   */
  export type SignatureFMPAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignatureFMPA
     */
    select?: SignatureFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureFMPAInclude<ExtArgs> | null
    /**
     * Filter, which SignatureFMPAS to fetch.
     */
    where?: SignatureFMPAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SignatureFMPAS to fetch.
     */
    orderBy?: SignatureFMPAOrderByWithRelationInput | SignatureFMPAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SignatureFMPAS.
     */
    cursor?: SignatureFMPAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SignatureFMPAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SignatureFMPAS.
     */
    skip?: number
    distinct?: SignatureFMPAScalarFieldEnum | SignatureFMPAScalarFieldEnum[]
  }

  /**
   * SignatureFMPA create
   */
  export type SignatureFMPACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignatureFMPA
     */
    select?: SignatureFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureFMPAInclude<ExtArgs> | null
    /**
     * The data needed to create a SignatureFMPA.
     */
    data: XOR<SignatureFMPACreateInput, SignatureFMPAUncheckedCreateInput>
  }

  /**
   * SignatureFMPA createMany
   */
  export type SignatureFMPACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SignatureFMPAS.
     */
    data: SignatureFMPACreateManyInput | SignatureFMPACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SignatureFMPA createManyAndReturn
   */
  export type SignatureFMPACreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignatureFMPA
     */
    select?: SignatureFMPASelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SignatureFMPAS.
     */
    data: SignatureFMPACreateManyInput | SignatureFMPACreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureFMPAIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SignatureFMPA update
   */
  export type SignatureFMPAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignatureFMPA
     */
    select?: SignatureFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureFMPAInclude<ExtArgs> | null
    /**
     * The data needed to update a SignatureFMPA.
     */
    data: XOR<SignatureFMPAUpdateInput, SignatureFMPAUncheckedUpdateInput>
    /**
     * Choose, which SignatureFMPA to update.
     */
    where: SignatureFMPAWhereUniqueInput
  }

  /**
   * SignatureFMPA updateMany
   */
  export type SignatureFMPAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SignatureFMPAS.
     */
    data: XOR<SignatureFMPAUpdateManyMutationInput, SignatureFMPAUncheckedUpdateManyInput>
    /**
     * Filter which SignatureFMPAS to update
     */
    where?: SignatureFMPAWhereInput
  }

  /**
   * SignatureFMPA upsert
   */
  export type SignatureFMPAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignatureFMPA
     */
    select?: SignatureFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureFMPAInclude<ExtArgs> | null
    /**
     * The filter to search for the SignatureFMPA to update in case it exists.
     */
    where: SignatureFMPAWhereUniqueInput
    /**
     * In case the SignatureFMPA found by the `where` argument doesn't exist, create a new SignatureFMPA with this data.
     */
    create: XOR<SignatureFMPACreateInput, SignatureFMPAUncheckedCreateInput>
    /**
     * In case the SignatureFMPA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SignatureFMPAUpdateInput, SignatureFMPAUncheckedUpdateInput>
  }

  /**
   * SignatureFMPA delete
   */
  export type SignatureFMPADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignatureFMPA
     */
    select?: SignatureFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureFMPAInclude<ExtArgs> | null
    /**
     * Filter which SignatureFMPA to delete.
     */
    where: SignatureFMPAWhereUniqueInput
  }

  /**
   * SignatureFMPA deleteMany
   */
  export type SignatureFMPADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SignatureFMPAS to delete
     */
    where?: SignatureFMPAWhereInput
  }

  /**
   * SignatureFMPA without action
   */
  export type SignatureFMPADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SignatureFMPA
     */
    select?: SignatureFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureFMPAInclude<ExtArgs> | null
  }


  /**
   * Model CategorieMateriel
   */

  export type AggregateCategorieMateriel = {
    _count: CategorieMaterielCountAggregateOutputType | null
    _avg: CategorieMaterielAvgAggregateOutputType | null
    _sum: CategorieMaterielSumAggregateOutputType | null
    _min: CategorieMaterielMinAggregateOutputType | null
    _max: CategorieMaterielMaxAggregateOutputType | null
  }

  export type CategorieMaterielAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorieMaterielSumAggregateOutputType = {
    id: number | null
  }

  export type CategorieMaterielMinAggregateOutputType = {
    id: number | null
    code: string | null
    libelle: string | null
    description: string | null
    actif: boolean | null
  }

  export type CategorieMaterielMaxAggregateOutputType = {
    id: number | null
    code: string | null
    libelle: string | null
    description: string | null
    actif: boolean | null
  }

  export type CategorieMaterielCountAggregateOutputType = {
    id: number
    code: number
    libelle: number
    description: number
    actif: number
    _all: number
  }


  export type CategorieMaterielAvgAggregateInputType = {
    id?: true
  }

  export type CategorieMaterielSumAggregateInputType = {
    id?: true
  }

  export type CategorieMaterielMinAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    description?: true
    actif?: true
  }

  export type CategorieMaterielMaxAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    description?: true
    actif?: true
  }

  export type CategorieMaterielCountAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    description?: true
    actif?: true
    _all?: true
  }

  export type CategorieMaterielAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategorieMateriel to aggregate.
     */
    where?: CategorieMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategorieMateriels to fetch.
     */
    orderBy?: CategorieMaterielOrderByWithRelationInput | CategorieMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategorieMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategorieMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategorieMateriels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategorieMateriels
    **/
    _count?: true | CategorieMaterielCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategorieMaterielAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorieMaterielSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategorieMaterielMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategorieMaterielMaxAggregateInputType
  }

  export type GetCategorieMaterielAggregateType<T extends CategorieMaterielAggregateArgs> = {
        [P in keyof T & keyof AggregateCategorieMateriel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategorieMateriel[P]>
      : GetScalarType<T[P], AggregateCategorieMateriel[P]>
  }




  export type CategorieMaterielGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategorieMaterielWhereInput
    orderBy?: CategorieMaterielOrderByWithAggregationInput | CategorieMaterielOrderByWithAggregationInput[]
    by: CategorieMaterielScalarFieldEnum[] | CategorieMaterielScalarFieldEnum
    having?: CategorieMaterielScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategorieMaterielCountAggregateInputType | true
    _avg?: CategorieMaterielAvgAggregateInputType
    _sum?: CategorieMaterielSumAggregateInputType
    _min?: CategorieMaterielMinAggregateInputType
    _max?: CategorieMaterielMaxAggregateInputType
  }

  export type CategorieMaterielGroupByOutputType = {
    id: number
    code: string
    libelle: string
    description: string | null
    actif: boolean
    _count: CategorieMaterielCountAggregateOutputType | null
    _avg: CategorieMaterielAvgAggregateOutputType | null
    _sum: CategorieMaterielSumAggregateOutputType | null
    _min: CategorieMaterielMinAggregateOutputType | null
    _max: CategorieMaterielMaxAggregateOutputType | null
  }

  type GetCategorieMaterielGroupByPayload<T extends CategorieMaterielGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategorieMaterielGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategorieMaterielGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategorieMaterielGroupByOutputType[P]>
            : GetScalarType<T[P], CategorieMaterielGroupByOutputType[P]>
        }
      >
    >


  export type CategorieMaterielSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    description?: boolean
    actif?: boolean
    materiels?: boolean | CategorieMateriel$materielsArgs<ExtArgs>
    _count?: boolean | CategorieMaterielCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categorieMateriel"]>

  export type CategorieMaterielSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    description?: boolean
    actif?: boolean
  }, ExtArgs["result"]["categorieMateriel"]>

  export type CategorieMaterielSelectScalar = {
    id?: boolean
    code?: boolean
    libelle?: boolean
    description?: boolean
    actif?: boolean
  }

  export type CategorieMaterielInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materiels?: boolean | CategorieMateriel$materielsArgs<ExtArgs>
    _count?: boolean | CategorieMaterielCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategorieMaterielIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategorieMaterielPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CategorieMateriel"
    objects: {
      materiels: Prisma.$MaterielPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      libelle: string
      description: string | null
      actif: boolean
    }, ExtArgs["result"]["categorieMateriel"]>
    composites: {}
  }

  type CategorieMaterielGetPayload<S extends boolean | null | undefined | CategorieMaterielDefaultArgs> = $Result.GetResult<Prisma.$CategorieMaterielPayload, S>

  type CategorieMaterielCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategorieMaterielFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategorieMaterielCountAggregateInputType | true
    }

  export interface CategorieMaterielDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategorieMateriel'], meta: { name: 'CategorieMateriel' } }
    /**
     * Find zero or one CategorieMateriel that matches the filter.
     * @param {CategorieMaterielFindUniqueArgs} args - Arguments to find a CategorieMateriel
     * @example
     * // Get one CategorieMateriel
     * const categorieMateriel = await prisma.categorieMateriel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategorieMaterielFindUniqueArgs>(args: SelectSubset<T, CategorieMaterielFindUniqueArgs<ExtArgs>>): Prisma__CategorieMaterielClient<$Result.GetResult<Prisma.$CategorieMaterielPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CategorieMateriel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategorieMaterielFindUniqueOrThrowArgs} args - Arguments to find a CategorieMateriel
     * @example
     * // Get one CategorieMateriel
     * const categorieMateriel = await prisma.categorieMateriel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategorieMaterielFindUniqueOrThrowArgs>(args: SelectSubset<T, CategorieMaterielFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategorieMaterielClient<$Result.GetResult<Prisma.$CategorieMaterielPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CategorieMateriel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorieMaterielFindFirstArgs} args - Arguments to find a CategorieMateriel
     * @example
     * // Get one CategorieMateriel
     * const categorieMateriel = await prisma.categorieMateriel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategorieMaterielFindFirstArgs>(args?: SelectSubset<T, CategorieMaterielFindFirstArgs<ExtArgs>>): Prisma__CategorieMaterielClient<$Result.GetResult<Prisma.$CategorieMaterielPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CategorieMateriel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorieMaterielFindFirstOrThrowArgs} args - Arguments to find a CategorieMateriel
     * @example
     * // Get one CategorieMateriel
     * const categorieMateriel = await prisma.categorieMateriel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategorieMaterielFindFirstOrThrowArgs>(args?: SelectSubset<T, CategorieMaterielFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategorieMaterielClient<$Result.GetResult<Prisma.$CategorieMaterielPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CategorieMateriels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorieMaterielFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategorieMateriels
     * const categorieMateriels = await prisma.categorieMateriel.findMany()
     * 
     * // Get first 10 CategorieMateriels
     * const categorieMateriels = await prisma.categorieMateriel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categorieMaterielWithIdOnly = await prisma.categorieMateriel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategorieMaterielFindManyArgs>(args?: SelectSubset<T, CategorieMaterielFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategorieMaterielPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CategorieMateriel.
     * @param {CategorieMaterielCreateArgs} args - Arguments to create a CategorieMateriel.
     * @example
     * // Create one CategorieMateriel
     * const CategorieMateriel = await prisma.categorieMateriel.create({
     *   data: {
     *     // ... data to create a CategorieMateriel
     *   }
     * })
     * 
     */
    create<T extends CategorieMaterielCreateArgs>(args: SelectSubset<T, CategorieMaterielCreateArgs<ExtArgs>>): Prisma__CategorieMaterielClient<$Result.GetResult<Prisma.$CategorieMaterielPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CategorieMateriels.
     * @param {CategorieMaterielCreateManyArgs} args - Arguments to create many CategorieMateriels.
     * @example
     * // Create many CategorieMateriels
     * const categorieMateriel = await prisma.categorieMateriel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategorieMaterielCreateManyArgs>(args?: SelectSubset<T, CategorieMaterielCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CategorieMateriels and returns the data saved in the database.
     * @param {CategorieMaterielCreateManyAndReturnArgs} args - Arguments to create many CategorieMateriels.
     * @example
     * // Create many CategorieMateriels
     * const categorieMateriel = await prisma.categorieMateriel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CategorieMateriels and only return the `id`
     * const categorieMaterielWithIdOnly = await prisma.categorieMateriel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategorieMaterielCreateManyAndReturnArgs>(args?: SelectSubset<T, CategorieMaterielCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategorieMaterielPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CategorieMateriel.
     * @param {CategorieMaterielDeleteArgs} args - Arguments to delete one CategorieMateriel.
     * @example
     * // Delete one CategorieMateriel
     * const CategorieMateriel = await prisma.categorieMateriel.delete({
     *   where: {
     *     // ... filter to delete one CategorieMateriel
     *   }
     * })
     * 
     */
    delete<T extends CategorieMaterielDeleteArgs>(args: SelectSubset<T, CategorieMaterielDeleteArgs<ExtArgs>>): Prisma__CategorieMaterielClient<$Result.GetResult<Prisma.$CategorieMaterielPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CategorieMateriel.
     * @param {CategorieMaterielUpdateArgs} args - Arguments to update one CategorieMateriel.
     * @example
     * // Update one CategorieMateriel
     * const categorieMateriel = await prisma.categorieMateriel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategorieMaterielUpdateArgs>(args: SelectSubset<T, CategorieMaterielUpdateArgs<ExtArgs>>): Prisma__CategorieMaterielClient<$Result.GetResult<Prisma.$CategorieMaterielPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CategorieMateriels.
     * @param {CategorieMaterielDeleteManyArgs} args - Arguments to filter CategorieMateriels to delete.
     * @example
     * // Delete a few CategorieMateriels
     * const { count } = await prisma.categorieMateriel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategorieMaterielDeleteManyArgs>(args?: SelectSubset<T, CategorieMaterielDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategorieMateriels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorieMaterielUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategorieMateriels
     * const categorieMateriel = await prisma.categorieMateriel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategorieMaterielUpdateManyArgs>(args: SelectSubset<T, CategorieMaterielUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CategorieMateriel.
     * @param {CategorieMaterielUpsertArgs} args - Arguments to update or create a CategorieMateriel.
     * @example
     * // Update or create a CategorieMateriel
     * const categorieMateriel = await prisma.categorieMateriel.upsert({
     *   create: {
     *     // ... data to create a CategorieMateriel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategorieMateriel we want to update
     *   }
     * })
     */
    upsert<T extends CategorieMaterielUpsertArgs>(args: SelectSubset<T, CategorieMaterielUpsertArgs<ExtArgs>>): Prisma__CategorieMaterielClient<$Result.GetResult<Prisma.$CategorieMaterielPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CategorieMateriels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorieMaterielCountArgs} args - Arguments to filter CategorieMateriels to count.
     * @example
     * // Count the number of CategorieMateriels
     * const count = await prisma.categorieMateriel.count({
     *   where: {
     *     // ... the filter for the CategorieMateriels we want to count
     *   }
     * })
    **/
    count<T extends CategorieMaterielCountArgs>(
      args?: Subset<T, CategorieMaterielCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategorieMaterielCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategorieMateriel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorieMaterielAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategorieMaterielAggregateArgs>(args: Subset<T, CategorieMaterielAggregateArgs>): Prisma.PrismaPromise<GetCategorieMaterielAggregateType<T>>

    /**
     * Group by CategorieMateriel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategorieMaterielGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategorieMaterielGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategorieMaterielGroupByArgs['orderBy'] }
        : { orderBy?: CategorieMaterielGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategorieMaterielGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategorieMaterielGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategorieMateriel model
   */
  readonly fields: CategorieMaterielFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategorieMateriel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategorieMaterielClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    materiels<T extends CategorieMateriel$materielsArgs<ExtArgs> = {}>(args?: Subset<T, CategorieMateriel$materielsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CategorieMateriel model
   */ 
  interface CategorieMaterielFieldRefs {
    readonly id: FieldRef<"CategorieMateriel", 'Int'>
    readonly code: FieldRef<"CategorieMateriel", 'String'>
    readonly libelle: FieldRef<"CategorieMateriel", 'String'>
    readonly description: FieldRef<"CategorieMateriel", 'String'>
    readonly actif: FieldRef<"CategorieMateriel", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CategorieMateriel findUnique
   */
  export type CategorieMaterielFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorieMateriel
     */
    select?: CategorieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorieMaterielInclude<ExtArgs> | null
    /**
     * Filter, which CategorieMateriel to fetch.
     */
    where: CategorieMaterielWhereUniqueInput
  }

  /**
   * CategorieMateriel findUniqueOrThrow
   */
  export type CategorieMaterielFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorieMateriel
     */
    select?: CategorieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorieMaterielInclude<ExtArgs> | null
    /**
     * Filter, which CategorieMateriel to fetch.
     */
    where: CategorieMaterielWhereUniqueInput
  }

  /**
   * CategorieMateriel findFirst
   */
  export type CategorieMaterielFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorieMateriel
     */
    select?: CategorieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorieMaterielInclude<ExtArgs> | null
    /**
     * Filter, which CategorieMateriel to fetch.
     */
    where?: CategorieMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategorieMateriels to fetch.
     */
    orderBy?: CategorieMaterielOrderByWithRelationInput | CategorieMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategorieMateriels.
     */
    cursor?: CategorieMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategorieMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategorieMateriels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategorieMateriels.
     */
    distinct?: CategorieMaterielScalarFieldEnum | CategorieMaterielScalarFieldEnum[]
  }

  /**
   * CategorieMateriel findFirstOrThrow
   */
  export type CategorieMaterielFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorieMateriel
     */
    select?: CategorieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorieMaterielInclude<ExtArgs> | null
    /**
     * Filter, which CategorieMateriel to fetch.
     */
    where?: CategorieMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategorieMateriels to fetch.
     */
    orderBy?: CategorieMaterielOrderByWithRelationInput | CategorieMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategorieMateriels.
     */
    cursor?: CategorieMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategorieMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategorieMateriels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategorieMateriels.
     */
    distinct?: CategorieMaterielScalarFieldEnum | CategorieMaterielScalarFieldEnum[]
  }

  /**
   * CategorieMateriel findMany
   */
  export type CategorieMaterielFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorieMateriel
     */
    select?: CategorieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorieMaterielInclude<ExtArgs> | null
    /**
     * Filter, which CategorieMateriels to fetch.
     */
    where?: CategorieMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategorieMateriels to fetch.
     */
    orderBy?: CategorieMaterielOrderByWithRelationInput | CategorieMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategorieMateriels.
     */
    cursor?: CategorieMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategorieMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategorieMateriels.
     */
    skip?: number
    distinct?: CategorieMaterielScalarFieldEnum | CategorieMaterielScalarFieldEnum[]
  }

  /**
   * CategorieMateriel create
   */
  export type CategorieMaterielCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorieMateriel
     */
    select?: CategorieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorieMaterielInclude<ExtArgs> | null
    /**
     * The data needed to create a CategorieMateriel.
     */
    data: XOR<CategorieMaterielCreateInput, CategorieMaterielUncheckedCreateInput>
  }

  /**
   * CategorieMateriel createMany
   */
  export type CategorieMaterielCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategorieMateriels.
     */
    data: CategorieMaterielCreateManyInput | CategorieMaterielCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CategorieMateriel createManyAndReturn
   */
  export type CategorieMaterielCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorieMateriel
     */
    select?: CategorieMaterielSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CategorieMateriels.
     */
    data: CategorieMaterielCreateManyInput | CategorieMaterielCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CategorieMateriel update
   */
  export type CategorieMaterielUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorieMateriel
     */
    select?: CategorieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorieMaterielInclude<ExtArgs> | null
    /**
     * The data needed to update a CategorieMateriel.
     */
    data: XOR<CategorieMaterielUpdateInput, CategorieMaterielUncheckedUpdateInput>
    /**
     * Choose, which CategorieMateriel to update.
     */
    where: CategorieMaterielWhereUniqueInput
  }

  /**
   * CategorieMateriel updateMany
   */
  export type CategorieMaterielUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategorieMateriels.
     */
    data: XOR<CategorieMaterielUpdateManyMutationInput, CategorieMaterielUncheckedUpdateManyInput>
    /**
     * Filter which CategorieMateriels to update
     */
    where?: CategorieMaterielWhereInput
  }

  /**
   * CategorieMateriel upsert
   */
  export type CategorieMaterielUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorieMateriel
     */
    select?: CategorieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorieMaterielInclude<ExtArgs> | null
    /**
     * The filter to search for the CategorieMateriel to update in case it exists.
     */
    where: CategorieMaterielWhereUniqueInput
    /**
     * In case the CategorieMateriel found by the `where` argument doesn't exist, create a new CategorieMateriel with this data.
     */
    create: XOR<CategorieMaterielCreateInput, CategorieMaterielUncheckedCreateInput>
    /**
     * In case the CategorieMateriel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategorieMaterielUpdateInput, CategorieMaterielUncheckedUpdateInput>
  }

  /**
   * CategorieMateriel delete
   */
  export type CategorieMaterielDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorieMateriel
     */
    select?: CategorieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorieMaterielInclude<ExtArgs> | null
    /**
     * Filter which CategorieMateriel to delete.
     */
    where: CategorieMaterielWhereUniqueInput
  }

  /**
   * CategorieMateriel deleteMany
   */
  export type CategorieMaterielDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategorieMateriels to delete
     */
    where?: CategorieMaterielWhereInput
  }

  /**
   * CategorieMateriel.materiels
   */
  export type CategorieMateriel$materielsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    where?: MaterielWhereInput
    orderBy?: MaterielOrderByWithRelationInput | MaterielOrderByWithRelationInput[]
    cursor?: MaterielWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterielScalarFieldEnum | MaterielScalarFieldEnum[]
  }

  /**
   * CategorieMateriel without action
   */
  export type CategorieMaterielDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategorieMateriel
     */
    select?: CategorieMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategorieMaterielInclude<ExtArgs> | null
  }


  /**
   * Model Materiel
   */

  export type AggregateMateriel = {
    _count: MaterielCountAggregateOutputType | null
    _avg: MaterielAvgAggregateOutputType | null
    _sum: MaterielSumAggregateOutputType | null
    _min: MaterielMinAggregateOutputType | null
    _max: MaterielMaxAggregateOutputType | null
  }

  export type MaterielAvgAggregateOutputType = {
    id: number | null
    categorieId: number | null
    centreId: number | null
    periodiciteControleJours: number | null
    responsableId: number | null
    valeurAchat: number | null
  }

  export type MaterielSumAggregateOutputType = {
    id: number | null
    categorieId: number | null
    centreId: number | null
    periodiciteControleJours: number | null
    responsableId: number | null
    valeurAchat: number | null
  }

  export type MaterielMinAggregateOutputType = {
    id: number | null
    categorieId: number | null
    centreId: number | null
    codeInventaire: string | null
    libelle: string | null
    marque: string | null
    modele: string | null
    numeroSerie: string | null
    dateAcquisition: Date | null
    dateMiseService: Date | null
    dateReforme: Date | null
    etat: $Enums.EtatMateriel | null
    periodiciteControleJours: number | null
    dateDernierControle: Date | null
    dateProchainControle: Date | null
    localisation: string | null
    responsableId: number | null
    valeurAchat: number | null
    fournisseur: string | null
    numeroMarche: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterielMaxAggregateOutputType = {
    id: number | null
    categorieId: number | null
    centreId: number | null
    codeInventaire: string | null
    libelle: string | null
    marque: string | null
    modele: string | null
    numeroSerie: string | null
    dateAcquisition: Date | null
    dateMiseService: Date | null
    dateReforme: Date | null
    etat: $Enums.EtatMateriel | null
    periodiciteControleJours: number | null
    dateDernierControle: Date | null
    dateProchainControle: Date | null
    localisation: string | null
    responsableId: number | null
    valeurAchat: number | null
    fournisseur: string | null
    numeroMarche: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaterielCountAggregateOutputType = {
    id: number
    categorieId: number
    centreId: number
    codeInventaire: number
    libelle: number
    marque: number
    modele: number
    numeroSerie: number
    dateAcquisition: number
    dateMiseService: number
    dateReforme: number
    etat: number
    periodiciteControleJours: number
    dateDernierControle: number
    dateProchainControle: number
    localisation: number
    responsableId: number
    valeurAchat: number
    fournisseur: number
    numeroMarche: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaterielAvgAggregateInputType = {
    id?: true
    categorieId?: true
    centreId?: true
    periodiciteControleJours?: true
    responsableId?: true
    valeurAchat?: true
  }

  export type MaterielSumAggregateInputType = {
    id?: true
    categorieId?: true
    centreId?: true
    periodiciteControleJours?: true
    responsableId?: true
    valeurAchat?: true
  }

  export type MaterielMinAggregateInputType = {
    id?: true
    categorieId?: true
    centreId?: true
    codeInventaire?: true
    libelle?: true
    marque?: true
    modele?: true
    numeroSerie?: true
    dateAcquisition?: true
    dateMiseService?: true
    dateReforme?: true
    etat?: true
    periodiciteControleJours?: true
    dateDernierControle?: true
    dateProchainControle?: true
    localisation?: true
    responsableId?: true
    valeurAchat?: true
    fournisseur?: true
    numeroMarche?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterielMaxAggregateInputType = {
    id?: true
    categorieId?: true
    centreId?: true
    codeInventaire?: true
    libelle?: true
    marque?: true
    modele?: true
    numeroSerie?: true
    dateAcquisition?: true
    dateMiseService?: true
    dateReforme?: true
    etat?: true
    periodiciteControleJours?: true
    dateDernierControle?: true
    dateProchainControle?: true
    localisation?: true
    responsableId?: true
    valeurAchat?: true
    fournisseur?: true
    numeroMarche?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaterielCountAggregateInputType = {
    id?: true
    categorieId?: true
    centreId?: true
    codeInventaire?: true
    libelle?: true
    marque?: true
    modele?: true
    numeroSerie?: true
    dateAcquisition?: true
    dateMiseService?: true
    dateReforme?: true
    etat?: true
    periodiciteControleJours?: true
    dateDernierControle?: true
    dateProchainControle?: true
    localisation?: true
    responsableId?: true
    valeurAchat?: true
    fournisseur?: true
    numeroMarche?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaterielAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materiel to aggregate.
     */
    where?: MaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materiels to fetch.
     */
    orderBy?: MaterielOrderByWithRelationInput | MaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materiels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materiels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materiels
    **/
    _count?: true | MaterielCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterielAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterielSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterielMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterielMaxAggregateInputType
  }

  export type GetMaterielAggregateType<T extends MaterielAggregateArgs> = {
        [P in keyof T & keyof AggregateMateriel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMateriel[P]>
      : GetScalarType<T[P], AggregateMateriel[P]>
  }




  export type MaterielGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterielWhereInput
    orderBy?: MaterielOrderByWithAggregationInput | MaterielOrderByWithAggregationInput[]
    by: MaterielScalarFieldEnum[] | MaterielScalarFieldEnum
    having?: MaterielScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterielCountAggregateInputType | true
    _avg?: MaterielAvgAggregateInputType
    _sum?: MaterielSumAggregateInputType
    _min?: MaterielMinAggregateInputType
    _max?: MaterielMaxAggregateInputType
  }

  export type MaterielGroupByOutputType = {
    id: number
    categorieId: number
    centreId: number | null
    codeInventaire: string
    libelle: string
    marque: string | null
    modele: string | null
    numeroSerie: string | null
    dateAcquisition: Date | null
    dateMiseService: Date | null
    dateReforme: Date | null
    etat: $Enums.EtatMateriel
    periodiciteControleJours: number | null
    dateDernierControle: Date | null
    dateProchainControle: Date | null
    localisation: string | null
    responsableId: number | null
    valeurAchat: number | null
    fournisseur: string | null
    numeroMarche: string | null
    createdAt: Date
    updatedAt: Date
    _count: MaterielCountAggregateOutputType | null
    _avg: MaterielAvgAggregateOutputType | null
    _sum: MaterielSumAggregateOutputType | null
    _min: MaterielMinAggregateOutputType | null
    _max: MaterielMaxAggregateOutputType | null
  }

  type GetMaterielGroupByPayload<T extends MaterielGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterielGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterielGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterielGroupByOutputType[P]>
            : GetScalarType<T[P], MaterielGroupByOutputType[P]>
        }
      >
    >


  export type MaterielSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categorieId?: boolean
    centreId?: boolean
    codeInventaire?: boolean
    libelle?: boolean
    marque?: boolean
    modele?: boolean
    numeroSerie?: boolean
    dateAcquisition?: boolean
    dateMiseService?: boolean
    dateReforme?: boolean
    etat?: boolean
    periodiciteControleJours?: boolean
    dateDernierControle?: boolean
    dateProchainControle?: boolean
    localisation?: boolean
    responsableId?: boolean
    valeurAchat?: boolean
    fournisseur?: boolean
    numeroMarche?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categorie?: boolean | CategorieMaterielDefaultArgs<ExtArgs>
    centre?: boolean | Materiel$centreArgs<ExtArgs>
    responsable?: boolean | Materiel$responsableArgs<ExtArgs>
    incidents?: boolean | Materiel$incidentsArgs<ExtArgs>
    _count?: boolean | MaterielCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materiel"]>

  export type MaterielSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categorieId?: boolean
    centreId?: boolean
    codeInventaire?: boolean
    libelle?: boolean
    marque?: boolean
    modele?: boolean
    numeroSerie?: boolean
    dateAcquisition?: boolean
    dateMiseService?: boolean
    dateReforme?: boolean
    etat?: boolean
    periodiciteControleJours?: boolean
    dateDernierControle?: boolean
    dateProchainControle?: boolean
    localisation?: boolean
    responsableId?: boolean
    valeurAchat?: boolean
    fournisseur?: boolean
    numeroMarche?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categorie?: boolean | CategorieMaterielDefaultArgs<ExtArgs>
    centre?: boolean | Materiel$centreArgs<ExtArgs>
    responsable?: boolean | Materiel$responsableArgs<ExtArgs>
  }, ExtArgs["result"]["materiel"]>

  export type MaterielSelectScalar = {
    id?: boolean
    categorieId?: boolean
    centreId?: boolean
    codeInventaire?: boolean
    libelle?: boolean
    marque?: boolean
    modele?: boolean
    numeroSerie?: boolean
    dateAcquisition?: boolean
    dateMiseService?: boolean
    dateReforme?: boolean
    etat?: boolean
    periodiciteControleJours?: boolean
    dateDernierControle?: boolean
    dateProchainControle?: boolean
    localisation?: boolean
    responsableId?: boolean
    valeurAchat?: boolean
    fournisseur?: boolean
    numeroMarche?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaterielInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categorie?: boolean | CategorieMaterielDefaultArgs<ExtArgs>
    centre?: boolean | Materiel$centreArgs<ExtArgs>
    responsable?: boolean | Materiel$responsableArgs<ExtArgs>
    incidents?: boolean | Materiel$incidentsArgs<ExtArgs>
    _count?: boolean | MaterielCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaterielIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categorie?: boolean | CategorieMaterielDefaultArgs<ExtArgs>
    centre?: boolean | Materiel$centreArgs<ExtArgs>
    responsable?: boolean | Materiel$responsableArgs<ExtArgs>
  }

  export type $MaterielPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Materiel"
    objects: {
      categorie: Prisma.$CategorieMaterielPayload<ExtArgs>
      centre: Prisma.$CentrePayload<ExtArgs> | null
      responsable: Prisma.$PersonnelPayload<ExtArgs> | null
      incidents: Prisma.$IncidentMaterielPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      categorieId: number
      centreId: number | null
      codeInventaire: string
      libelle: string
      marque: string | null
      modele: string | null
      numeroSerie: string | null
      dateAcquisition: Date | null
      dateMiseService: Date | null
      dateReforme: Date | null
      etat: $Enums.EtatMateriel
      periodiciteControleJours: number | null
      dateDernierControle: Date | null
      dateProchainControle: Date | null
      localisation: string | null
      responsableId: number | null
      valeurAchat: number | null
      fournisseur: string | null
      numeroMarche: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["materiel"]>
    composites: {}
  }

  type MaterielGetPayload<S extends boolean | null | undefined | MaterielDefaultArgs> = $Result.GetResult<Prisma.$MaterielPayload, S>

  type MaterielCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterielFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterielCountAggregateInputType | true
    }

  export interface MaterielDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Materiel'], meta: { name: 'Materiel' } }
    /**
     * Find zero or one Materiel that matches the filter.
     * @param {MaterielFindUniqueArgs} args - Arguments to find a Materiel
     * @example
     * // Get one Materiel
     * const materiel = await prisma.materiel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterielFindUniqueArgs>(args: SelectSubset<T, MaterielFindUniqueArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Materiel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaterielFindUniqueOrThrowArgs} args - Arguments to find a Materiel
     * @example
     * // Get one Materiel
     * const materiel = await prisma.materiel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterielFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterielFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Materiel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterielFindFirstArgs} args - Arguments to find a Materiel
     * @example
     * // Get one Materiel
     * const materiel = await prisma.materiel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterielFindFirstArgs>(args?: SelectSubset<T, MaterielFindFirstArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Materiel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterielFindFirstOrThrowArgs} args - Arguments to find a Materiel
     * @example
     * // Get one Materiel
     * const materiel = await prisma.materiel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterielFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterielFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Materiels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterielFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materiels
     * const materiels = await prisma.materiel.findMany()
     * 
     * // Get first 10 Materiels
     * const materiels = await prisma.materiel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materielWithIdOnly = await prisma.materiel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterielFindManyArgs>(args?: SelectSubset<T, MaterielFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Materiel.
     * @param {MaterielCreateArgs} args - Arguments to create a Materiel.
     * @example
     * // Create one Materiel
     * const Materiel = await prisma.materiel.create({
     *   data: {
     *     // ... data to create a Materiel
     *   }
     * })
     * 
     */
    create<T extends MaterielCreateArgs>(args: SelectSubset<T, MaterielCreateArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Materiels.
     * @param {MaterielCreateManyArgs} args - Arguments to create many Materiels.
     * @example
     * // Create many Materiels
     * const materiel = await prisma.materiel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterielCreateManyArgs>(args?: SelectSubset<T, MaterielCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materiels and returns the data saved in the database.
     * @param {MaterielCreateManyAndReturnArgs} args - Arguments to create many Materiels.
     * @example
     * // Create many Materiels
     * const materiel = await prisma.materiel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materiels and only return the `id`
     * const materielWithIdOnly = await prisma.materiel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterielCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterielCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Materiel.
     * @param {MaterielDeleteArgs} args - Arguments to delete one Materiel.
     * @example
     * // Delete one Materiel
     * const Materiel = await prisma.materiel.delete({
     *   where: {
     *     // ... filter to delete one Materiel
     *   }
     * })
     * 
     */
    delete<T extends MaterielDeleteArgs>(args: SelectSubset<T, MaterielDeleteArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Materiel.
     * @param {MaterielUpdateArgs} args - Arguments to update one Materiel.
     * @example
     * // Update one Materiel
     * const materiel = await prisma.materiel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterielUpdateArgs>(args: SelectSubset<T, MaterielUpdateArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Materiels.
     * @param {MaterielDeleteManyArgs} args - Arguments to filter Materiels to delete.
     * @example
     * // Delete a few Materiels
     * const { count } = await prisma.materiel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterielDeleteManyArgs>(args?: SelectSubset<T, MaterielDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materiels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterielUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materiels
     * const materiel = await prisma.materiel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterielUpdateManyArgs>(args: SelectSubset<T, MaterielUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Materiel.
     * @param {MaterielUpsertArgs} args - Arguments to update or create a Materiel.
     * @example
     * // Update or create a Materiel
     * const materiel = await prisma.materiel.upsert({
     *   create: {
     *     // ... data to create a Materiel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materiel we want to update
     *   }
     * })
     */
    upsert<T extends MaterielUpsertArgs>(args: SelectSubset<T, MaterielUpsertArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Materiels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterielCountArgs} args - Arguments to filter Materiels to count.
     * @example
     * // Count the number of Materiels
     * const count = await prisma.materiel.count({
     *   where: {
     *     // ... the filter for the Materiels we want to count
     *   }
     * })
    **/
    count<T extends MaterielCountArgs>(
      args?: Subset<T, MaterielCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterielCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materiel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterielAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterielAggregateArgs>(args: Subset<T, MaterielAggregateArgs>): Prisma.PrismaPromise<GetMaterielAggregateType<T>>

    /**
     * Group by Materiel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterielGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterielGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterielGroupByArgs['orderBy'] }
        : { orderBy?: MaterielGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterielGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterielGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Materiel model
   */
  readonly fields: MaterielFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Materiel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterielClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categorie<T extends CategorieMaterielDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategorieMaterielDefaultArgs<ExtArgs>>): Prisma__CategorieMaterielClient<$Result.GetResult<Prisma.$CategorieMaterielPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    centre<T extends Materiel$centreArgs<ExtArgs> = {}>(args?: Subset<T, Materiel$centreArgs<ExtArgs>>): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    responsable<T extends Materiel$responsableArgs<ExtArgs> = {}>(args?: Subset<T, Materiel$responsableArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    incidents<T extends Materiel$incidentsArgs<ExtArgs> = {}>(args?: Subset<T, Materiel$incidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentMaterielPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Materiel model
   */ 
  interface MaterielFieldRefs {
    readonly id: FieldRef<"Materiel", 'Int'>
    readonly categorieId: FieldRef<"Materiel", 'Int'>
    readonly centreId: FieldRef<"Materiel", 'Int'>
    readonly codeInventaire: FieldRef<"Materiel", 'String'>
    readonly libelle: FieldRef<"Materiel", 'String'>
    readonly marque: FieldRef<"Materiel", 'String'>
    readonly modele: FieldRef<"Materiel", 'String'>
    readonly numeroSerie: FieldRef<"Materiel", 'String'>
    readonly dateAcquisition: FieldRef<"Materiel", 'DateTime'>
    readonly dateMiseService: FieldRef<"Materiel", 'DateTime'>
    readonly dateReforme: FieldRef<"Materiel", 'DateTime'>
    readonly etat: FieldRef<"Materiel", 'EtatMateriel'>
    readonly periodiciteControleJours: FieldRef<"Materiel", 'Int'>
    readonly dateDernierControle: FieldRef<"Materiel", 'DateTime'>
    readonly dateProchainControle: FieldRef<"Materiel", 'DateTime'>
    readonly localisation: FieldRef<"Materiel", 'String'>
    readonly responsableId: FieldRef<"Materiel", 'Int'>
    readonly valeurAchat: FieldRef<"Materiel", 'Float'>
    readonly fournisseur: FieldRef<"Materiel", 'String'>
    readonly numeroMarche: FieldRef<"Materiel", 'String'>
    readonly createdAt: FieldRef<"Materiel", 'DateTime'>
    readonly updatedAt: FieldRef<"Materiel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Materiel findUnique
   */
  export type MaterielFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * Filter, which Materiel to fetch.
     */
    where: MaterielWhereUniqueInput
  }

  /**
   * Materiel findUniqueOrThrow
   */
  export type MaterielFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * Filter, which Materiel to fetch.
     */
    where: MaterielWhereUniqueInput
  }

  /**
   * Materiel findFirst
   */
  export type MaterielFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * Filter, which Materiel to fetch.
     */
    where?: MaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materiels to fetch.
     */
    orderBy?: MaterielOrderByWithRelationInput | MaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materiels.
     */
    cursor?: MaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materiels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materiels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materiels.
     */
    distinct?: MaterielScalarFieldEnum | MaterielScalarFieldEnum[]
  }

  /**
   * Materiel findFirstOrThrow
   */
  export type MaterielFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * Filter, which Materiel to fetch.
     */
    where?: MaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materiels to fetch.
     */
    orderBy?: MaterielOrderByWithRelationInput | MaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materiels.
     */
    cursor?: MaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materiels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materiels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materiels.
     */
    distinct?: MaterielScalarFieldEnum | MaterielScalarFieldEnum[]
  }

  /**
   * Materiel findMany
   */
  export type MaterielFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * Filter, which Materiels to fetch.
     */
    where?: MaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materiels to fetch.
     */
    orderBy?: MaterielOrderByWithRelationInput | MaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materiels.
     */
    cursor?: MaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materiels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materiels.
     */
    skip?: number
    distinct?: MaterielScalarFieldEnum | MaterielScalarFieldEnum[]
  }

  /**
   * Materiel create
   */
  export type MaterielCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * The data needed to create a Materiel.
     */
    data: XOR<MaterielCreateInput, MaterielUncheckedCreateInput>
  }

  /**
   * Materiel createMany
   */
  export type MaterielCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materiels.
     */
    data: MaterielCreateManyInput | MaterielCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Materiel createManyAndReturn
   */
  export type MaterielCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Materiels.
     */
    data: MaterielCreateManyInput | MaterielCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Materiel update
   */
  export type MaterielUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * The data needed to update a Materiel.
     */
    data: XOR<MaterielUpdateInput, MaterielUncheckedUpdateInput>
    /**
     * Choose, which Materiel to update.
     */
    where: MaterielWhereUniqueInput
  }

  /**
   * Materiel updateMany
   */
  export type MaterielUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materiels.
     */
    data: XOR<MaterielUpdateManyMutationInput, MaterielUncheckedUpdateManyInput>
    /**
     * Filter which Materiels to update
     */
    where?: MaterielWhereInput
  }

  /**
   * Materiel upsert
   */
  export type MaterielUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * The filter to search for the Materiel to update in case it exists.
     */
    where: MaterielWhereUniqueInput
    /**
     * In case the Materiel found by the `where` argument doesn't exist, create a new Materiel with this data.
     */
    create: XOR<MaterielCreateInput, MaterielUncheckedCreateInput>
    /**
     * In case the Materiel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterielUpdateInput, MaterielUncheckedUpdateInput>
  }

  /**
   * Materiel delete
   */
  export type MaterielDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
    /**
     * Filter which Materiel to delete.
     */
    where: MaterielWhereUniqueInput
  }

  /**
   * Materiel deleteMany
   */
  export type MaterielDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materiels to delete
     */
    where?: MaterielWhereInput
  }

  /**
   * Materiel.centre
   */
  export type Materiel$centreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
    where?: CentreWhereInput
  }

  /**
   * Materiel.responsable
   */
  export type Materiel$responsableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    where?: PersonnelWhereInput
  }

  /**
   * Materiel.incidents
   */
  export type Materiel$incidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentMateriel
     */
    select?: IncidentMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentMaterielInclude<ExtArgs> | null
    where?: IncidentMaterielWhereInput
    orderBy?: IncidentMaterielOrderByWithRelationInput | IncidentMaterielOrderByWithRelationInput[]
    cursor?: IncidentMaterielWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentMaterielScalarFieldEnum | IncidentMaterielScalarFieldEnum[]
  }

  /**
   * Materiel without action
   */
  export type MaterielDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materiel
     */
    select?: MaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterielInclude<ExtArgs> | null
  }


  /**
   * Model IncidentMateriel
   */

  export type AggregateIncidentMateriel = {
    _count: IncidentMaterielCountAggregateOutputType | null
    _avg: IncidentMaterielAvgAggregateOutputType | null
    _sum: IncidentMaterielSumAggregateOutputType | null
    _min: IncidentMaterielMinAggregateOutputType | null
    _max: IncidentMaterielMaxAggregateOutputType | null
  }

  export type IncidentMaterielAvgAggregateOutputType = {
    id: number | null
    materielId: number | null
    signaleParId: number | null
    traiteParId: number | null
    coutReparation: number | null
  }

  export type IncidentMaterielSumAggregateOutputType = {
    id: number | null
    materielId: number | null
    signaleParId: number | null
    traiteParId: number | null
    coutReparation: number | null
  }

  export type IncidentMaterielMinAggregateOutputType = {
    id: number | null
    materielId: number | null
    signaleParId: number | null
    dateIncident: Date | null
    typeIncident: $Enums.TypeIncident | null
    gravite: $Enums.GraviteIncident | null
    description: string | null
    statut: $Enums.StatutIncident | null
    traiteParId: number | null
    dateResolution: Date | null
    actionsCorrectives: string | null
    coutReparation: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentMaterielMaxAggregateOutputType = {
    id: number | null
    materielId: number | null
    signaleParId: number | null
    dateIncident: Date | null
    typeIncident: $Enums.TypeIncident | null
    gravite: $Enums.GraviteIncident | null
    description: string | null
    statut: $Enums.StatutIncident | null
    traiteParId: number | null
    dateResolution: Date | null
    actionsCorrectives: string | null
    coutReparation: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentMaterielCountAggregateOutputType = {
    id: number
    materielId: number
    signaleParId: number
    dateIncident: number
    typeIncident: number
    gravite: number
    description: number
    photosUrls: number
    statut: number
    traiteParId: number
    dateResolution: number
    actionsCorrectives: number
    coutReparation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IncidentMaterielAvgAggregateInputType = {
    id?: true
    materielId?: true
    signaleParId?: true
    traiteParId?: true
    coutReparation?: true
  }

  export type IncidentMaterielSumAggregateInputType = {
    id?: true
    materielId?: true
    signaleParId?: true
    traiteParId?: true
    coutReparation?: true
  }

  export type IncidentMaterielMinAggregateInputType = {
    id?: true
    materielId?: true
    signaleParId?: true
    dateIncident?: true
    typeIncident?: true
    gravite?: true
    description?: true
    statut?: true
    traiteParId?: true
    dateResolution?: true
    actionsCorrectives?: true
    coutReparation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentMaterielMaxAggregateInputType = {
    id?: true
    materielId?: true
    signaleParId?: true
    dateIncident?: true
    typeIncident?: true
    gravite?: true
    description?: true
    statut?: true
    traiteParId?: true
    dateResolution?: true
    actionsCorrectives?: true
    coutReparation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentMaterielCountAggregateInputType = {
    id?: true
    materielId?: true
    signaleParId?: true
    dateIncident?: true
    typeIncident?: true
    gravite?: true
    description?: true
    photosUrls?: true
    statut?: true
    traiteParId?: true
    dateResolution?: true
    actionsCorrectives?: true
    coutReparation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IncidentMaterielAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentMateriel to aggregate.
     */
    where?: IncidentMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentMateriels to fetch.
     */
    orderBy?: IncidentMaterielOrderByWithRelationInput | IncidentMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentMateriels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncidentMateriels
    **/
    _count?: true | IncidentMaterielCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncidentMaterielAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncidentMaterielSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentMaterielMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentMaterielMaxAggregateInputType
  }

  export type GetIncidentMaterielAggregateType<T extends IncidentMaterielAggregateArgs> = {
        [P in keyof T & keyof AggregateIncidentMateriel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncidentMateriel[P]>
      : GetScalarType<T[P], AggregateIncidentMateriel[P]>
  }




  export type IncidentMaterielGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentMaterielWhereInput
    orderBy?: IncidentMaterielOrderByWithAggregationInput | IncidentMaterielOrderByWithAggregationInput[]
    by: IncidentMaterielScalarFieldEnum[] | IncidentMaterielScalarFieldEnum
    having?: IncidentMaterielScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentMaterielCountAggregateInputType | true
    _avg?: IncidentMaterielAvgAggregateInputType
    _sum?: IncidentMaterielSumAggregateInputType
    _min?: IncidentMaterielMinAggregateInputType
    _max?: IncidentMaterielMaxAggregateInputType
  }

  export type IncidentMaterielGroupByOutputType = {
    id: number
    materielId: number
    signaleParId: number
    dateIncident: Date
    typeIncident: $Enums.TypeIncident
    gravite: $Enums.GraviteIncident
    description: string
    photosUrls: string[]
    statut: $Enums.StatutIncident
    traiteParId: number | null
    dateResolution: Date | null
    actionsCorrectives: string | null
    coutReparation: number | null
    createdAt: Date
    updatedAt: Date
    _count: IncidentMaterielCountAggregateOutputType | null
    _avg: IncidentMaterielAvgAggregateOutputType | null
    _sum: IncidentMaterielSumAggregateOutputType | null
    _min: IncidentMaterielMinAggregateOutputType | null
    _max: IncidentMaterielMaxAggregateOutputType | null
  }

  type GetIncidentMaterielGroupByPayload<T extends IncidentMaterielGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentMaterielGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentMaterielGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentMaterielGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentMaterielGroupByOutputType[P]>
        }
      >
    >


  export type IncidentMaterielSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materielId?: boolean
    signaleParId?: boolean
    dateIncident?: boolean
    typeIncident?: boolean
    gravite?: boolean
    description?: boolean
    photosUrls?: boolean
    statut?: boolean
    traiteParId?: boolean
    dateResolution?: boolean
    actionsCorrectives?: boolean
    coutReparation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    materiel?: boolean | MaterielDefaultArgs<ExtArgs>
    signalePar?: boolean | PersonnelDefaultArgs<ExtArgs>
    traitePar?: boolean | IncidentMateriel$traiteParArgs<ExtArgs>
  }, ExtArgs["result"]["incidentMateriel"]>

  export type IncidentMaterielSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    materielId?: boolean
    signaleParId?: boolean
    dateIncident?: boolean
    typeIncident?: boolean
    gravite?: boolean
    description?: boolean
    photosUrls?: boolean
    statut?: boolean
    traiteParId?: boolean
    dateResolution?: boolean
    actionsCorrectives?: boolean
    coutReparation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    materiel?: boolean | MaterielDefaultArgs<ExtArgs>
    signalePar?: boolean | PersonnelDefaultArgs<ExtArgs>
    traitePar?: boolean | IncidentMateriel$traiteParArgs<ExtArgs>
  }, ExtArgs["result"]["incidentMateriel"]>

  export type IncidentMaterielSelectScalar = {
    id?: boolean
    materielId?: boolean
    signaleParId?: boolean
    dateIncident?: boolean
    typeIncident?: boolean
    gravite?: boolean
    description?: boolean
    photosUrls?: boolean
    statut?: boolean
    traiteParId?: boolean
    dateResolution?: boolean
    actionsCorrectives?: boolean
    coutReparation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IncidentMaterielInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materiel?: boolean | MaterielDefaultArgs<ExtArgs>
    signalePar?: boolean | PersonnelDefaultArgs<ExtArgs>
    traitePar?: boolean | IncidentMateriel$traiteParArgs<ExtArgs>
  }
  export type IncidentMaterielIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materiel?: boolean | MaterielDefaultArgs<ExtArgs>
    signalePar?: boolean | PersonnelDefaultArgs<ExtArgs>
    traitePar?: boolean | IncidentMateriel$traiteParArgs<ExtArgs>
  }

  export type $IncidentMaterielPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncidentMateriel"
    objects: {
      materiel: Prisma.$MaterielPayload<ExtArgs>
      signalePar: Prisma.$PersonnelPayload<ExtArgs>
      traitePar: Prisma.$PersonnelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      materielId: number
      signaleParId: number
      dateIncident: Date
      typeIncident: $Enums.TypeIncident
      gravite: $Enums.GraviteIncident
      description: string
      photosUrls: string[]
      statut: $Enums.StatutIncident
      traiteParId: number | null
      dateResolution: Date | null
      actionsCorrectives: string | null
      coutReparation: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["incidentMateriel"]>
    composites: {}
  }

  type IncidentMaterielGetPayload<S extends boolean | null | undefined | IncidentMaterielDefaultArgs> = $Result.GetResult<Prisma.$IncidentMaterielPayload, S>

  type IncidentMaterielCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncidentMaterielFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncidentMaterielCountAggregateInputType | true
    }

  export interface IncidentMaterielDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncidentMateriel'], meta: { name: 'IncidentMateriel' } }
    /**
     * Find zero or one IncidentMateriel that matches the filter.
     * @param {IncidentMaterielFindUniqueArgs} args - Arguments to find a IncidentMateriel
     * @example
     * // Get one IncidentMateriel
     * const incidentMateriel = await prisma.incidentMateriel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentMaterielFindUniqueArgs>(args: SelectSubset<T, IncidentMaterielFindUniqueArgs<ExtArgs>>): Prisma__IncidentMaterielClient<$Result.GetResult<Prisma.$IncidentMaterielPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IncidentMateriel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncidentMaterielFindUniqueOrThrowArgs} args - Arguments to find a IncidentMateriel
     * @example
     * // Get one IncidentMateriel
     * const incidentMateriel = await prisma.incidentMateriel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentMaterielFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentMaterielFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentMaterielClient<$Result.GetResult<Prisma.$IncidentMaterielPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IncidentMateriel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentMaterielFindFirstArgs} args - Arguments to find a IncidentMateriel
     * @example
     * // Get one IncidentMateriel
     * const incidentMateriel = await prisma.incidentMateriel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentMaterielFindFirstArgs>(args?: SelectSubset<T, IncidentMaterielFindFirstArgs<ExtArgs>>): Prisma__IncidentMaterielClient<$Result.GetResult<Prisma.$IncidentMaterielPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IncidentMateriel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentMaterielFindFirstOrThrowArgs} args - Arguments to find a IncidentMateriel
     * @example
     * // Get one IncidentMateriel
     * const incidentMateriel = await prisma.incidentMateriel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentMaterielFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentMaterielFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentMaterielClient<$Result.GetResult<Prisma.$IncidentMaterielPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IncidentMateriels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentMaterielFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncidentMateriels
     * const incidentMateriels = await prisma.incidentMateriel.findMany()
     * 
     * // Get first 10 IncidentMateriels
     * const incidentMateriels = await prisma.incidentMateriel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentMaterielWithIdOnly = await prisma.incidentMateriel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentMaterielFindManyArgs>(args?: SelectSubset<T, IncidentMaterielFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentMaterielPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IncidentMateriel.
     * @param {IncidentMaterielCreateArgs} args - Arguments to create a IncidentMateriel.
     * @example
     * // Create one IncidentMateriel
     * const IncidentMateriel = await prisma.incidentMateriel.create({
     *   data: {
     *     // ... data to create a IncidentMateriel
     *   }
     * })
     * 
     */
    create<T extends IncidentMaterielCreateArgs>(args: SelectSubset<T, IncidentMaterielCreateArgs<ExtArgs>>): Prisma__IncidentMaterielClient<$Result.GetResult<Prisma.$IncidentMaterielPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IncidentMateriels.
     * @param {IncidentMaterielCreateManyArgs} args - Arguments to create many IncidentMateriels.
     * @example
     * // Create many IncidentMateriels
     * const incidentMateriel = await prisma.incidentMateriel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentMaterielCreateManyArgs>(args?: SelectSubset<T, IncidentMaterielCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IncidentMateriels and returns the data saved in the database.
     * @param {IncidentMaterielCreateManyAndReturnArgs} args - Arguments to create many IncidentMateriels.
     * @example
     * // Create many IncidentMateriels
     * const incidentMateriel = await prisma.incidentMateriel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IncidentMateriels and only return the `id`
     * const incidentMaterielWithIdOnly = await prisma.incidentMateriel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncidentMaterielCreateManyAndReturnArgs>(args?: SelectSubset<T, IncidentMaterielCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentMaterielPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IncidentMateriel.
     * @param {IncidentMaterielDeleteArgs} args - Arguments to delete one IncidentMateriel.
     * @example
     * // Delete one IncidentMateriel
     * const IncidentMateriel = await prisma.incidentMateriel.delete({
     *   where: {
     *     // ... filter to delete one IncidentMateriel
     *   }
     * })
     * 
     */
    delete<T extends IncidentMaterielDeleteArgs>(args: SelectSubset<T, IncidentMaterielDeleteArgs<ExtArgs>>): Prisma__IncidentMaterielClient<$Result.GetResult<Prisma.$IncidentMaterielPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IncidentMateriel.
     * @param {IncidentMaterielUpdateArgs} args - Arguments to update one IncidentMateriel.
     * @example
     * // Update one IncidentMateriel
     * const incidentMateriel = await prisma.incidentMateriel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentMaterielUpdateArgs>(args: SelectSubset<T, IncidentMaterielUpdateArgs<ExtArgs>>): Prisma__IncidentMaterielClient<$Result.GetResult<Prisma.$IncidentMaterielPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IncidentMateriels.
     * @param {IncidentMaterielDeleteManyArgs} args - Arguments to filter IncidentMateriels to delete.
     * @example
     * // Delete a few IncidentMateriels
     * const { count } = await prisma.incidentMateriel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentMaterielDeleteManyArgs>(args?: SelectSubset<T, IncidentMaterielDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncidentMateriels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentMaterielUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncidentMateriels
     * const incidentMateriel = await prisma.incidentMateriel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentMaterielUpdateManyArgs>(args: SelectSubset<T, IncidentMaterielUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncidentMateriel.
     * @param {IncidentMaterielUpsertArgs} args - Arguments to update or create a IncidentMateriel.
     * @example
     * // Update or create a IncidentMateriel
     * const incidentMateriel = await prisma.incidentMateriel.upsert({
     *   create: {
     *     // ... data to create a IncidentMateriel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncidentMateriel we want to update
     *   }
     * })
     */
    upsert<T extends IncidentMaterielUpsertArgs>(args: SelectSubset<T, IncidentMaterielUpsertArgs<ExtArgs>>): Prisma__IncidentMaterielClient<$Result.GetResult<Prisma.$IncidentMaterielPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IncidentMateriels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentMaterielCountArgs} args - Arguments to filter IncidentMateriels to count.
     * @example
     * // Count the number of IncidentMateriels
     * const count = await prisma.incidentMateriel.count({
     *   where: {
     *     // ... the filter for the IncidentMateriels we want to count
     *   }
     * })
    **/
    count<T extends IncidentMaterielCountArgs>(
      args?: Subset<T, IncidentMaterielCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentMaterielCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncidentMateriel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentMaterielAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentMaterielAggregateArgs>(args: Subset<T, IncidentMaterielAggregateArgs>): Prisma.PrismaPromise<GetIncidentMaterielAggregateType<T>>

    /**
     * Group by IncidentMateriel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentMaterielGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentMaterielGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentMaterielGroupByArgs['orderBy'] }
        : { orderBy?: IncidentMaterielGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentMaterielGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentMaterielGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncidentMateriel model
   */
  readonly fields: IncidentMaterielFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncidentMateriel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentMaterielClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    materiel<T extends MaterielDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaterielDefaultArgs<ExtArgs>>): Prisma__MaterielClient<$Result.GetResult<Prisma.$MaterielPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    signalePar<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    traitePar<T extends IncidentMateriel$traiteParArgs<ExtArgs> = {}>(args?: Subset<T, IncidentMateriel$traiteParArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncidentMateriel model
   */ 
  interface IncidentMaterielFieldRefs {
    readonly id: FieldRef<"IncidentMateriel", 'Int'>
    readonly materielId: FieldRef<"IncidentMateriel", 'Int'>
    readonly signaleParId: FieldRef<"IncidentMateriel", 'Int'>
    readonly dateIncident: FieldRef<"IncidentMateriel", 'DateTime'>
    readonly typeIncident: FieldRef<"IncidentMateriel", 'TypeIncident'>
    readonly gravite: FieldRef<"IncidentMateriel", 'GraviteIncident'>
    readonly description: FieldRef<"IncidentMateriel", 'String'>
    readonly photosUrls: FieldRef<"IncidentMateriel", 'String[]'>
    readonly statut: FieldRef<"IncidentMateriel", 'StatutIncident'>
    readonly traiteParId: FieldRef<"IncidentMateriel", 'Int'>
    readonly dateResolution: FieldRef<"IncidentMateriel", 'DateTime'>
    readonly actionsCorrectives: FieldRef<"IncidentMateriel", 'String'>
    readonly coutReparation: FieldRef<"IncidentMateriel", 'Float'>
    readonly createdAt: FieldRef<"IncidentMateriel", 'DateTime'>
    readonly updatedAt: FieldRef<"IncidentMateriel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IncidentMateriel findUnique
   */
  export type IncidentMaterielFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentMateriel
     */
    select?: IncidentMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentMaterielInclude<ExtArgs> | null
    /**
     * Filter, which IncidentMateriel to fetch.
     */
    where: IncidentMaterielWhereUniqueInput
  }

  /**
   * IncidentMateriel findUniqueOrThrow
   */
  export type IncidentMaterielFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentMateriel
     */
    select?: IncidentMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentMaterielInclude<ExtArgs> | null
    /**
     * Filter, which IncidentMateriel to fetch.
     */
    where: IncidentMaterielWhereUniqueInput
  }

  /**
   * IncidentMateriel findFirst
   */
  export type IncidentMaterielFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentMateriel
     */
    select?: IncidentMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentMaterielInclude<ExtArgs> | null
    /**
     * Filter, which IncidentMateriel to fetch.
     */
    where?: IncidentMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentMateriels to fetch.
     */
    orderBy?: IncidentMaterielOrderByWithRelationInput | IncidentMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentMateriels.
     */
    cursor?: IncidentMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentMateriels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentMateriels.
     */
    distinct?: IncidentMaterielScalarFieldEnum | IncidentMaterielScalarFieldEnum[]
  }

  /**
   * IncidentMateriel findFirstOrThrow
   */
  export type IncidentMaterielFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentMateriel
     */
    select?: IncidentMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentMaterielInclude<ExtArgs> | null
    /**
     * Filter, which IncidentMateriel to fetch.
     */
    where?: IncidentMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentMateriels to fetch.
     */
    orderBy?: IncidentMaterielOrderByWithRelationInput | IncidentMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncidentMateriels.
     */
    cursor?: IncidentMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentMateriels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncidentMateriels.
     */
    distinct?: IncidentMaterielScalarFieldEnum | IncidentMaterielScalarFieldEnum[]
  }

  /**
   * IncidentMateriel findMany
   */
  export type IncidentMaterielFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentMateriel
     */
    select?: IncidentMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentMaterielInclude<ExtArgs> | null
    /**
     * Filter, which IncidentMateriels to fetch.
     */
    where?: IncidentMaterielWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncidentMateriels to fetch.
     */
    orderBy?: IncidentMaterielOrderByWithRelationInput | IncidentMaterielOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncidentMateriels.
     */
    cursor?: IncidentMaterielWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncidentMateriels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncidentMateriels.
     */
    skip?: number
    distinct?: IncidentMaterielScalarFieldEnum | IncidentMaterielScalarFieldEnum[]
  }

  /**
   * IncidentMateriel create
   */
  export type IncidentMaterielCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentMateriel
     */
    select?: IncidentMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentMaterielInclude<ExtArgs> | null
    /**
     * The data needed to create a IncidentMateriel.
     */
    data: XOR<IncidentMaterielCreateInput, IncidentMaterielUncheckedCreateInput>
  }

  /**
   * IncidentMateriel createMany
   */
  export type IncidentMaterielCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncidentMateriels.
     */
    data: IncidentMaterielCreateManyInput | IncidentMaterielCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncidentMateriel createManyAndReturn
   */
  export type IncidentMaterielCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentMateriel
     */
    select?: IncidentMaterielSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IncidentMateriels.
     */
    data: IncidentMaterielCreateManyInput | IncidentMaterielCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentMaterielIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncidentMateriel update
   */
  export type IncidentMaterielUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentMateriel
     */
    select?: IncidentMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentMaterielInclude<ExtArgs> | null
    /**
     * The data needed to update a IncidentMateriel.
     */
    data: XOR<IncidentMaterielUpdateInput, IncidentMaterielUncheckedUpdateInput>
    /**
     * Choose, which IncidentMateriel to update.
     */
    where: IncidentMaterielWhereUniqueInput
  }

  /**
   * IncidentMateriel updateMany
   */
  export type IncidentMaterielUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncidentMateriels.
     */
    data: XOR<IncidentMaterielUpdateManyMutationInput, IncidentMaterielUncheckedUpdateManyInput>
    /**
     * Filter which IncidentMateriels to update
     */
    where?: IncidentMaterielWhereInput
  }

  /**
   * IncidentMateriel upsert
   */
  export type IncidentMaterielUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentMateriel
     */
    select?: IncidentMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentMaterielInclude<ExtArgs> | null
    /**
     * The filter to search for the IncidentMateriel to update in case it exists.
     */
    where: IncidentMaterielWhereUniqueInput
    /**
     * In case the IncidentMateriel found by the `where` argument doesn't exist, create a new IncidentMateriel with this data.
     */
    create: XOR<IncidentMaterielCreateInput, IncidentMaterielUncheckedCreateInput>
    /**
     * In case the IncidentMateriel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentMaterielUpdateInput, IncidentMaterielUncheckedUpdateInput>
  }

  /**
   * IncidentMateriel delete
   */
  export type IncidentMaterielDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentMateriel
     */
    select?: IncidentMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentMaterielInclude<ExtArgs> | null
    /**
     * Filter which IncidentMateriel to delete.
     */
    where: IncidentMaterielWhereUniqueInput
  }

  /**
   * IncidentMateriel deleteMany
   */
  export type IncidentMaterielDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncidentMateriels to delete
     */
    where?: IncidentMaterielWhereInput
  }

  /**
   * IncidentMateriel.traitePar
   */
  export type IncidentMateriel$traiteParArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    where?: PersonnelWhereInput
  }

  /**
   * IncidentMateriel without action
   */
  export type IncidentMaterielDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncidentMateriel
     */
    select?: IncidentMaterielSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentMaterielInclude<ExtArgs> | null
  }


  /**
   * Model EPI
   */

  export type AggregateEPI = {
    _count: EPICountAggregateOutputType | null
    _avg: EPIAvgAggregateOutputType | null
    _sum: EPISumAggregateOutputType | null
    _min: EPIMinAggregateOutputType | null
    _max: EPIMaxAggregateOutputType | null
  }

  export type EPIAvgAggregateOutputType = {
    id: number | null
    personnelId: number | null
  }

  export type EPISumAggregateOutputType = {
    id: number | null
    personnelId: number | null
  }

  export type EPIMinAggregateOutputType = {
    id: number | null
    personnelId: number | null
    typeEPI: string | null
    taille: string | null
    numeroSerie: string | null
    dateAttribution: Date | null
    datePeremption: Date | null
    etat: $Enums.EtatEPI | null
    dateDernierControle: Date | null
    dateProchainControle: Date | null
    actif: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EPIMaxAggregateOutputType = {
    id: number | null
    personnelId: number | null
    typeEPI: string | null
    taille: string | null
    numeroSerie: string | null
    dateAttribution: Date | null
    datePeremption: Date | null
    etat: $Enums.EtatEPI | null
    dateDernierControle: Date | null
    dateProchainControle: Date | null
    actif: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EPICountAggregateOutputType = {
    id: number
    personnelId: number
    typeEPI: number
    taille: number
    numeroSerie: number
    dateAttribution: number
    datePeremption: number
    etat: number
    dateDernierControle: number
    dateProchainControle: number
    actif: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EPIAvgAggregateInputType = {
    id?: true
    personnelId?: true
  }

  export type EPISumAggregateInputType = {
    id?: true
    personnelId?: true
  }

  export type EPIMinAggregateInputType = {
    id?: true
    personnelId?: true
    typeEPI?: true
    taille?: true
    numeroSerie?: true
    dateAttribution?: true
    datePeremption?: true
    etat?: true
    dateDernierControle?: true
    dateProchainControle?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EPIMaxAggregateInputType = {
    id?: true
    personnelId?: true
    typeEPI?: true
    taille?: true
    numeroSerie?: true
    dateAttribution?: true
    datePeremption?: true
    etat?: true
    dateDernierControle?: true
    dateProchainControle?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EPICountAggregateInputType = {
    id?: true
    personnelId?: true
    typeEPI?: true
    taille?: true
    numeroSerie?: true
    dateAttribution?: true
    datePeremption?: true
    etat?: true
    dateDernierControle?: true
    dateProchainControle?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EPIAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EPI to aggregate.
     */
    where?: EPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EPIS to fetch.
     */
    orderBy?: EPIOrderByWithRelationInput | EPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EPIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EPIS
    **/
    _count?: true | EPICountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EPIAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EPISumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EPIMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EPIMaxAggregateInputType
  }

  export type GetEPIAggregateType<T extends EPIAggregateArgs> = {
        [P in keyof T & keyof AggregateEPI]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEPI[P]>
      : GetScalarType<T[P], AggregateEPI[P]>
  }




  export type EPIGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EPIWhereInput
    orderBy?: EPIOrderByWithAggregationInput | EPIOrderByWithAggregationInput[]
    by: EPIScalarFieldEnum[] | EPIScalarFieldEnum
    having?: EPIScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EPICountAggregateInputType | true
    _avg?: EPIAvgAggregateInputType
    _sum?: EPISumAggregateInputType
    _min?: EPIMinAggregateInputType
    _max?: EPIMaxAggregateInputType
  }

  export type EPIGroupByOutputType = {
    id: number
    personnelId: number
    typeEPI: string
    taille: string | null
    numeroSerie: string | null
    dateAttribution: Date
    datePeremption: Date | null
    etat: $Enums.EtatEPI
    dateDernierControle: Date | null
    dateProchainControle: Date | null
    actif: boolean
    createdAt: Date
    updatedAt: Date
    _count: EPICountAggregateOutputType | null
    _avg: EPIAvgAggregateOutputType | null
    _sum: EPISumAggregateOutputType | null
    _min: EPIMinAggregateOutputType | null
    _max: EPIMaxAggregateOutputType | null
  }

  type GetEPIGroupByPayload<T extends EPIGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EPIGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EPIGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EPIGroupByOutputType[P]>
            : GetScalarType<T[P], EPIGroupByOutputType[P]>
        }
      >
    >


  export type EPISelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personnelId?: boolean
    typeEPI?: boolean
    taille?: boolean
    numeroSerie?: boolean
    dateAttribution?: boolean
    datePeremption?: boolean
    etat?: boolean
    dateDernierControle?: boolean
    dateProchainControle?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ePI"]>

  export type EPISelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personnelId?: boolean
    typeEPI?: boolean
    taille?: boolean
    numeroSerie?: boolean
    dateAttribution?: boolean
    datePeremption?: boolean
    etat?: boolean
    dateDernierControle?: boolean
    dateProchainControle?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ePI"]>

  export type EPISelectScalar = {
    id?: boolean
    personnelId?: boolean
    typeEPI?: boolean
    taille?: boolean
    numeroSerie?: boolean
    dateAttribution?: boolean
    datePeremption?: boolean
    etat?: boolean
    dateDernierControle?: boolean
    dateProchainControle?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EPIInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }
  export type EPIIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }

  export type $EPIPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EPI"
    objects: {
      personnel: Prisma.$PersonnelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      personnelId: number
      typeEPI: string
      taille: string | null
      numeroSerie: string | null
      dateAttribution: Date
      datePeremption: Date | null
      etat: $Enums.EtatEPI
      dateDernierControle: Date | null
      dateProchainControle: Date | null
      actif: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ePI"]>
    composites: {}
  }

  type EPIGetPayload<S extends boolean | null | undefined | EPIDefaultArgs> = $Result.GetResult<Prisma.$EPIPayload, S>

  type EPICountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EPIFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EPICountAggregateInputType | true
    }

  export interface EPIDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EPI'], meta: { name: 'EPI' } }
    /**
     * Find zero or one EPI that matches the filter.
     * @param {EPIFindUniqueArgs} args - Arguments to find a EPI
     * @example
     * // Get one EPI
     * const ePI = await prisma.ePI.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EPIFindUniqueArgs>(args: SelectSubset<T, EPIFindUniqueArgs<ExtArgs>>): Prisma__EPIClient<$Result.GetResult<Prisma.$EPIPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EPI that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EPIFindUniqueOrThrowArgs} args - Arguments to find a EPI
     * @example
     * // Get one EPI
     * const ePI = await prisma.ePI.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EPIFindUniqueOrThrowArgs>(args: SelectSubset<T, EPIFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EPIClient<$Result.GetResult<Prisma.$EPIPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EPI that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EPIFindFirstArgs} args - Arguments to find a EPI
     * @example
     * // Get one EPI
     * const ePI = await prisma.ePI.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EPIFindFirstArgs>(args?: SelectSubset<T, EPIFindFirstArgs<ExtArgs>>): Prisma__EPIClient<$Result.GetResult<Prisma.$EPIPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EPI that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EPIFindFirstOrThrowArgs} args - Arguments to find a EPI
     * @example
     * // Get one EPI
     * const ePI = await prisma.ePI.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EPIFindFirstOrThrowArgs>(args?: SelectSubset<T, EPIFindFirstOrThrowArgs<ExtArgs>>): Prisma__EPIClient<$Result.GetResult<Prisma.$EPIPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EPIS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EPIFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EPIS
     * const ePIS = await prisma.ePI.findMany()
     * 
     * // Get first 10 EPIS
     * const ePIS = await prisma.ePI.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ePIWithIdOnly = await prisma.ePI.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EPIFindManyArgs>(args?: SelectSubset<T, EPIFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EPIPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EPI.
     * @param {EPICreateArgs} args - Arguments to create a EPI.
     * @example
     * // Create one EPI
     * const EPI = await prisma.ePI.create({
     *   data: {
     *     // ... data to create a EPI
     *   }
     * })
     * 
     */
    create<T extends EPICreateArgs>(args: SelectSubset<T, EPICreateArgs<ExtArgs>>): Prisma__EPIClient<$Result.GetResult<Prisma.$EPIPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EPIS.
     * @param {EPICreateManyArgs} args - Arguments to create many EPIS.
     * @example
     * // Create many EPIS
     * const ePI = await prisma.ePI.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EPICreateManyArgs>(args?: SelectSubset<T, EPICreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EPIS and returns the data saved in the database.
     * @param {EPICreateManyAndReturnArgs} args - Arguments to create many EPIS.
     * @example
     * // Create many EPIS
     * const ePI = await prisma.ePI.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EPIS and only return the `id`
     * const ePIWithIdOnly = await prisma.ePI.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EPICreateManyAndReturnArgs>(args?: SelectSubset<T, EPICreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EPIPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EPI.
     * @param {EPIDeleteArgs} args - Arguments to delete one EPI.
     * @example
     * // Delete one EPI
     * const EPI = await prisma.ePI.delete({
     *   where: {
     *     // ... filter to delete one EPI
     *   }
     * })
     * 
     */
    delete<T extends EPIDeleteArgs>(args: SelectSubset<T, EPIDeleteArgs<ExtArgs>>): Prisma__EPIClient<$Result.GetResult<Prisma.$EPIPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EPI.
     * @param {EPIUpdateArgs} args - Arguments to update one EPI.
     * @example
     * // Update one EPI
     * const ePI = await prisma.ePI.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EPIUpdateArgs>(args: SelectSubset<T, EPIUpdateArgs<ExtArgs>>): Prisma__EPIClient<$Result.GetResult<Prisma.$EPIPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EPIS.
     * @param {EPIDeleteManyArgs} args - Arguments to filter EPIS to delete.
     * @example
     * // Delete a few EPIS
     * const { count } = await prisma.ePI.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EPIDeleteManyArgs>(args?: SelectSubset<T, EPIDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EPIS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EPIUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EPIS
     * const ePI = await prisma.ePI.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EPIUpdateManyArgs>(args: SelectSubset<T, EPIUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EPI.
     * @param {EPIUpsertArgs} args - Arguments to update or create a EPI.
     * @example
     * // Update or create a EPI
     * const ePI = await prisma.ePI.upsert({
     *   create: {
     *     // ... data to create a EPI
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EPI we want to update
     *   }
     * })
     */
    upsert<T extends EPIUpsertArgs>(args: SelectSubset<T, EPIUpsertArgs<ExtArgs>>): Prisma__EPIClient<$Result.GetResult<Prisma.$EPIPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EPIS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EPICountArgs} args - Arguments to filter EPIS to count.
     * @example
     * // Count the number of EPIS
     * const count = await prisma.ePI.count({
     *   where: {
     *     // ... the filter for the EPIS we want to count
     *   }
     * })
    **/
    count<T extends EPICountArgs>(
      args?: Subset<T, EPICountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EPICountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EPI.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EPIAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EPIAggregateArgs>(args: Subset<T, EPIAggregateArgs>): Prisma.PrismaPromise<GetEPIAggregateType<T>>

    /**
     * Group by EPI.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EPIGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EPIGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EPIGroupByArgs['orderBy'] }
        : { orderBy?: EPIGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EPIGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEPIGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EPI model
   */
  readonly fields: EPIFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EPI.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EPIClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personnel<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EPI model
   */ 
  interface EPIFieldRefs {
    readonly id: FieldRef<"EPI", 'Int'>
    readonly personnelId: FieldRef<"EPI", 'Int'>
    readonly typeEPI: FieldRef<"EPI", 'String'>
    readonly taille: FieldRef<"EPI", 'String'>
    readonly numeroSerie: FieldRef<"EPI", 'String'>
    readonly dateAttribution: FieldRef<"EPI", 'DateTime'>
    readonly datePeremption: FieldRef<"EPI", 'DateTime'>
    readonly etat: FieldRef<"EPI", 'EtatEPI'>
    readonly dateDernierControle: FieldRef<"EPI", 'DateTime'>
    readonly dateProchainControle: FieldRef<"EPI", 'DateTime'>
    readonly actif: FieldRef<"EPI", 'Boolean'>
    readonly createdAt: FieldRef<"EPI", 'DateTime'>
    readonly updatedAt: FieldRef<"EPI", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EPI findUnique
   */
  export type EPIFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EPI
     */
    select?: EPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EPIInclude<ExtArgs> | null
    /**
     * Filter, which EPI to fetch.
     */
    where: EPIWhereUniqueInput
  }

  /**
   * EPI findUniqueOrThrow
   */
  export type EPIFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EPI
     */
    select?: EPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EPIInclude<ExtArgs> | null
    /**
     * Filter, which EPI to fetch.
     */
    where: EPIWhereUniqueInput
  }

  /**
   * EPI findFirst
   */
  export type EPIFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EPI
     */
    select?: EPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EPIInclude<ExtArgs> | null
    /**
     * Filter, which EPI to fetch.
     */
    where?: EPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EPIS to fetch.
     */
    orderBy?: EPIOrderByWithRelationInput | EPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EPIS.
     */
    cursor?: EPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EPIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EPIS.
     */
    distinct?: EPIScalarFieldEnum | EPIScalarFieldEnum[]
  }

  /**
   * EPI findFirstOrThrow
   */
  export type EPIFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EPI
     */
    select?: EPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EPIInclude<ExtArgs> | null
    /**
     * Filter, which EPI to fetch.
     */
    where?: EPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EPIS to fetch.
     */
    orderBy?: EPIOrderByWithRelationInput | EPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EPIS.
     */
    cursor?: EPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EPIS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EPIS.
     */
    distinct?: EPIScalarFieldEnum | EPIScalarFieldEnum[]
  }

  /**
   * EPI findMany
   */
  export type EPIFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EPI
     */
    select?: EPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EPIInclude<ExtArgs> | null
    /**
     * Filter, which EPIS to fetch.
     */
    where?: EPIWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EPIS to fetch.
     */
    orderBy?: EPIOrderByWithRelationInput | EPIOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EPIS.
     */
    cursor?: EPIWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EPIS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EPIS.
     */
    skip?: number
    distinct?: EPIScalarFieldEnum | EPIScalarFieldEnum[]
  }

  /**
   * EPI create
   */
  export type EPICreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EPI
     */
    select?: EPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EPIInclude<ExtArgs> | null
    /**
     * The data needed to create a EPI.
     */
    data: XOR<EPICreateInput, EPIUncheckedCreateInput>
  }

  /**
   * EPI createMany
   */
  export type EPICreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EPIS.
     */
    data: EPICreateManyInput | EPICreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EPI createManyAndReturn
   */
  export type EPICreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EPI
     */
    select?: EPISelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EPIS.
     */
    data: EPICreateManyInput | EPICreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EPIIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EPI update
   */
  export type EPIUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EPI
     */
    select?: EPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EPIInclude<ExtArgs> | null
    /**
     * The data needed to update a EPI.
     */
    data: XOR<EPIUpdateInput, EPIUncheckedUpdateInput>
    /**
     * Choose, which EPI to update.
     */
    where: EPIWhereUniqueInput
  }

  /**
   * EPI updateMany
   */
  export type EPIUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EPIS.
     */
    data: XOR<EPIUpdateManyMutationInput, EPIUncheckedUpdateManyInput>
    /**
     * Filter which EPIS to update
     */
    where?: EPIWhereInput
  }

  /**
   * EPI upsert
   */
  export type EPIUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EPI
     */
    select?: EPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EPIInclude<ExtArgs> | null
    /**
     * The filter to search for the EPI to update in case it exists.
     */
    where: EPIWhereUniqueInput
    /**
     * In case the EPI found by the `where` argument doesn't exist, create a new EPI with this data.
     */
    create: XOR<EPICreateInput, EPIUncheckedCreateInput>
    /**
     * In case the EPI was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EPIUpdateInput, EPIUncheckedUpdateInput>
  }

  /**
   * EPI delete
   */
  export type EPIDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EPI
     */
    select?: EPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EPIInclude<ExtArgs> | null
    /**
     * Filter which EPI to delete.
     */
    where: EPIWhereUniqueInput
  }

  /**
   * EPI deleteMany
   */
  export type EPIDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EPIS to delete
     */
    where?: EPIWhereInput
  }

  /**
   * EPI without action
   */
  export type EPIDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EPI
     */
    select?: EPISelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EPIInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type ConversationSumAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type ConversationMinAggregateOutputType = {
    id: number | null
    type: $Enums.TypeConversation | null
    nom: string | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: number | null
    type: $Enums.TypeConversation | null
    nom: string | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    type: number
    nom: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationAvgAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type ConversationSumAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type ConversationMinAggregateInputType = {
    id?: true
    type?: true
    nom?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    type?: true
    nom?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    type?: true
    nom?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _avg?: ConversationAvgAggregateInputType
    _sum?: ConversationSumAggregateInputType
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: number
    type: $Enums.TypeConversation
    nom: string | null
    createdById: number
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    nom?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | PersonnelDefaultArgs<ExtArgs>
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    nom?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    type?: boolean
    nom?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | PersonnelDefaultArgs<ExtArgs>
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | PersonnelDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      createdBy: Prisma.$PersonnelPayload<ExtArgs>
      participants: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.TypeConversation
      nom: string | null
      createdById: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    participants<T extends Conversation$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */ 
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'Int'>
    readonly type: FieldRef<"Conversation", 'TypeConversation'>
    readonly nom: FieldRef<"Conversation", 'String'>
    readonly createdById: FieldRef<"Conversation", 'Int'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation.participants
   */
  export type Conversation$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model ConversationParticipant
   */

  export type AggregateConversationParticipant = {
    _count: ConversationParticipantCountAggregateOutputType | null
    _avg: ConversationParticipantAvgAggregateOutputType | null
    _sum: ConversationParticipantSumAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  export type ConversationParticipantAvgAggregateOutputType = {
    conversationId: number | null
    personnelId: number | null
  }

  export type ConversationParticipantSumAggregateOutputType = {
    conversationId: number | null
    personnelId: number | null
  }

  export type ConversationParticipantMinAggregateOutputType = {
    conversationId: number | null
    personnelId: number | null
    dateAjout: Date | null
    dateSortie: Date | null
    role: $Enums.RoleConversation | null
    notificationsActives: boolean | null
  }

  export type ConversationParticipantMaxAggregateOutputType = {
    conversationId: number | null
    personnelId: number | null
    dateAjout: Date | null
    dateSortie: Date | null
    role: $Enums.RoleConversation | null
    notificationsActives: boolean | null
  }

  export type ConversationParticipantCountAggregateOutputType = {
    conversationId: number
    personnelId: number
    dateAjout: number
    dateSortie: number
    role: number
    notificationsActives: number
    _all: number
  }


  export type ConversationParticipantAvgAggregateInputType = {
    conversationId?: true
    personnelId?: true
  }

  export type ConversationParticipantSumAggregateInputType = {
    conversationId?: true
    personnelId?: true
  }

  export type ConversationParticipantMinAggregateInputType = {
    conversationId?: true
    personnelId?: true
    dateAjout?: true
    dateSortie?: true
    role?: true
    notificationsActives?: true
  }

  export type ConversationParticipantMaxAggregateInputType = {
    conversationId?: true
    personnelId?: true
    dateAjout?: true
    dateSortie?: true
    role?: true
    notificationsActives?: true
  }

  export type ConversationParticipantCountAggregateInputType = {
    conversationId?: true
    personnelId?: true
    dateAjout?: true
    dateSortie?: true
    role?: true
    notificationsActives?: true
    _all?: true
  }

  export type ConversationParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipant to aggregate.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationParticipants
    **/
    _count?: true | ConversationParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type GetConversationParticipantAggregateType<T extends ConversationParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationParticipant[P]>
      : GetScalarType<T[P], AggregateConversationParticipant[P]>
  }




  export type ConversationParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithAggregationInput | ConversationParticipantOrderByWithAggregationInput[]
    by: ConversationParticipantScalarFieldEnum[] | ConversationParticipantScalarFieldEnum
    having?: ConversationParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationParticipantCountAggregateInputType | true
    _avg?: ConversationParticipantAvgAggregateInputType
    _sum?: ConversationParticipantSumAggregateInputType
    _min?: ConversationParticipantMinAggregateInputType
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type ConversationParticipantGroupByOutputType = {
    conversationId: number
    personnelId: number
    dateAjout: Date
    dateSortie: Date | null
    role: $Enums.RoleConversation
    notificationsActives: boolean
    _count: ConversationParticipantCountAggregateOutputType | null
    _avg: ConversationParticipantAvgAggregateOutputType | null
    _sum: ConversationParticipantSumAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  type GetConversationParticipantGroupByPayload<T extends ConversationParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ConversationParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversationId?: boolean
    personnelId?: boolean
    dateAjout?: boolean
    dateSortie?: boolean
    role?: boolean
    notificationsActives?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversationId?: boolean
    personnelId?: boolean
    dateAjout?: boolean
    dateSortie?: boolean
    role?: boolean
    notificationsActives?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectScalar = {
    conversationId?: boolean
    personnelId?: boolean
    dateAjout?: boolean
    dateSortie?: boolean
    role?: boolean
    notificationsActives?: boolean
  }

  export type ConversationParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }
  export type ConversationParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }

  export type $ConversationParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationParticipant"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      personnel: Prisma.$PersonnelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      conversationId: number
      personnelId: number
      dateAjout: Date
      dateSortie: Date | null
      role: $Enums.RoleConversation
      notificationsActives: boolean
    }, ExtArgs["result"]["conversationParticipant"]>
    composites: {}
  }

  type ConversationParticipantGetPayload<S extends boolean | null | undefined | ConversationParticipantDefaultArgs> = $Result.GetResult<Prisma.$ConversationParticipantPayload, S>

  type ConversationParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationParticipantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationParticipantCountAggregateInputType | true
    }

  export interface ConversationParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationParticipant'], meta: { name: 'ConversationParticipant' } }
    /**
     * Find zero or one ConversationParticipant that matches the filter.
     * @param {ConversationParticipantFindUniqueArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationParticipantFindUniqueArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConversationParticipant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversationParticipantFindUniqueOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConversationParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationParticipantFindFirstArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConversationParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConversationParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany()
     * 
     * // Get first 10 ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany({ take: 10 })
     * 
     * // Only select the `conversationId`
     * const conversationParticipantWithConversationIdOnly = await prisma.conversationParticipant.findMany({ select: { conversationId: true } })
     * 
     */
    findMany<T extends ConversationParticipantFindManyArgs>(args?: SelectSubset<T, ConversationParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConversationParticipant.
     * @param {ConversationParticipantCreateArgs} args - Arguments to create a ConversationParticipant.
     * @example
     * // Create one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.create({
     *   data: {
     *     // ... data to create a ConversationParticipant
     *   }
     * })
     * 
     */
    create<T extends ConversationParticipantCreateArgs>(args: SelectSubset<T, ConversationParticipantCreateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConversationParticipants.
     * @param {ConversationParticipantCreateManyArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationParticipantCreateManyArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationParticipants and returns the data saved in the database.
     * @param {ConversationParticipantCreateManyAndReturnArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationParticipants and only return the `conversationId`
     * const conversationParticipantWithConversationIdOnly = await prisma.conversationParticipant.createManyAndReturn({ 
     *   select: { conversationId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConversationParticipant.
     * @param {ConversationParticipantDeleteArgs} args - Arguments to delete one ConversationParticipant.
     * @example
     * // Delete one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.delete({
     *   where: {
     *     // ... filter to delete one ConversationParticipant
     *   }
     * })
     * 
     */
    delete<T extends ConversationParticipantDeleteArgs>(args: SelectSubset<T, ConversationParticipantDeleteArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConversationParticipant.
     * @param {ConversationParticipantUpdateArgs} args - Arguments to update one ConversationParticipant.
     * @example
     * // Update one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationParticipantUpdateArgs>(args: SelectSubset<T, ConversationParticipantUpdateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConversationParticipants.
     * @param {ConversationParticipantDeleteManyArgs} args - Arguments to filter ConversationParticipants to delete.
     * @example
     * // Delete a few ConversationParticipants
     * const { count } = await prisma.conversationParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationParticipantDeleteManyArgs>(args?: SelectSubset<T, ConversationParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationParticipantUpdateManyArgs>(args: SelectSubset<T, ConversationParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConversationParticipant.
     * @param {ConversationParticipantUpsertArgs} args - Arguments to update or create a ConversationParticipant.
     * @example
     * // Update or create a ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.upsert({
     *   create: {
     *     // ... data to create a ConversationParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ConversationParticipantUpsertArgs>(args: SelectSubset<T, ConversationParticipantUpsertArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantCountArgs} args - Arguments to filter ConversationParticipants to count.
     * @example
     * // Count the number of ConversationParticipants
     * const count = await prisma.conversationParticipant.count({
     *   where: {
     *     // ... the filter for the ConversationParticipants we want to count
     *   }
     * })
    **/
    count<T extends ConversationParticipantCountArgs>(
      args?: Subset<T, ConversationParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationParticipantAggregateArgs>(args: Subset<T, ConversationParticipantAggregateArgs>): Prisma.PrismaPromise<GetConversationParticipantAggregateType<T>>

    /**
     * Group by ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ConversationParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationParticipant model
   */
  readonly fields: ConversationParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    personnel<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationParticipant model
   */ 
  interface ConversationParticipantFieldRefs {
    readonly conversationId: FieldRef<"ConversationParticipant", 'Int'>
    readonly personnelId: FieldRef<"ConversationParticipant", 'Int'>
    readonly dateAjout: FieldRef<"ConversationParticipant", 'DateTime'>
    readonly dateSortie: FieldRef<"ConversationParticipant", 'DateTime'>
    readonly role: FieldRef<"ConversationParticipant", 'RoleConversation'>
    readonly notificationsActives: FieldRef<"ConversationParticipant", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ConversationParticipant findUnique
   */
  export type ConversationParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findUniqueOrThrow
   */
  export type ConversationParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findFirst
   */
  export type ConversationParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findFirstOrThrow
   */
  export type ConversationParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findMany
   */
  export type ConversationParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipants to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant create
   */
  export type ConversationParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationParticipant.
     */
    data: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
  }

  /**
   * ConversationParticipant createMany
   */
  export type ConversationParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationParticipant createManyAndReturn
   */
  export type ConversationParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationParticipant update
   */
  export type ConversationParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationParticipant.
     */
    data: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
    /**
     * Choose, which ConversationParticipant to update.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant updateMany
   */
  export type ConversationParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationParticipants.
     */
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ConversationParticipants to update
     */
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationParticipant upsert
   */
  export type ConversationParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationParticipant to update in case it exists.
     */
    where: ConversationParticipantWhereUniqueInput
    /**
     * In case the ConversationParticipant found by the `where` argument doesn't exist, create a new ConversationParticipant with this data.
     */
    create: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
    /**
     * In case the ConversationParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
  }

  /**
   * ConversationParticipant delete
   */
  export type ConversationParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter which ConversationParticipant to delete.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant deleteMany
   */
  export type ConversationParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipants to delete
     */
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationParticipant without action
   */
  export type ConversationParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    conversationId: number | null
    expediteurId: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    conversationId: number | null
    expediteurId: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    conversationId: number | null
    expediteurId: number | null
    contenu: string | null
    typeMessage: $Enums.TypeMessage | null
    fichierUrl: string | null
    typeInteractif: string | null
    createdAt: Date | null
    editedAt: Date | null
    deletedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    conversationId: number | null
    expediteurId: number | null
    contenu: string | null
    typeMessage: $Enums.TypeMessage | null
    fichierUrl: string | null
    typeInteractif: string | null
    createdAt: Date | null
    editedAt: Date | null
    deletedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    expediteurId: number
    contenu: number
    typeMessage: number
    fichierUrl: number
    typeInteractif: number
    donneesInteractives: number
    createdAt: number
    editedAt: number
    deletedAt: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    conversationId?: true
    expediteurId?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    conversationId?: true
    expediteurId?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    expediteurId?: true
    contenu?: true
    typeMessage?: true
    fichierUrl?: true
    typeInteractif?: true
    createdAt?: true
    editedAt?: true
    deletedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    expediteurId?: true
    contenu?: true
    typeMessage?: true
    fichierUrl?: true
    typeInteractif?: true
    createdAt?: true
    editedAt?: true
    deletedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    expediteurId?: true
    contenu?: true
    typeMessage?: true
    fichierUrl?: true
    typeInteractif?: true
    donneesInteractives?: true
    createdAt?: true
    editedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    conversationId: number
    expediteurId: number
    contenu: string
    typeMessage: $Enums.TypeMessage
    fichierUrl: string | null
    typeInteractif: string | null
    donneesInteractives: JsonValue | null
    createdAt: Date
    editedAt: Date | null
    deletedAt: Date | null
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    expediteurId?: boolean
    contenu?: boolean
    typeMessage?: boolean
    fichierUrl?: boolean
    typeInteractif?: boolean
    donneesInteractives?: boolean
    createdAt?: boolean
    editedAt?: boolean
    deletedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    expediteur?: boolean | PersonnelDefaultArgs<ExtArgs>
    messagesLus?: boolean | Message$messagesLusArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    expediteurId?: boolean
    contenu?: boolean
    typeMessage?: boolean
    fichierUrl?: boolean
    typeInteractif?: boolean
    donneesInteractives?: boolean
    createdAt?: boolean
    editedAt?: boolean
    deletedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    expediteur?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    expediteurId?: boolean
    contenu?: boolean
    typeMessage?: boolean
    fichierUrl?: boolean
    typeInteractif?: boolean
    donneesInteractives?: boolean
    createdAt?: boolean
    editedAt?: boolean
    deletedAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    expediteur?: boolean | PersonnelDefaultArgs<ExtArgs>
    messagesLus?: boolean | Message$messagesLusArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    expediteur?: boolean | PersonnelDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      expediteur: Prisma.$PersonnelPayload<ExtArgs>
      messagesLus: Prisma.$MessageLuPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conversationId: number
      expediteurId: number
      contenu: string
      typeMessage: $Enums.TypeMessage
      fichierUrl: string | null
      typeInteractif: string | null
      donneesInteractives: Prisma.JsonValue | null
      createdAt: Date
      editedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    expediteur<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messagesLus<T extends Message$messagesLusArgs<ExtArgs> = {}>(args?: Subset<T, Message$messagesLusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLuPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'Int'>
    readonly conversationId: FieldRef<"Message", 'Int'>
    readonly expediteurId: FieldRef<"Message", 'Int'>
    readonly contenu: FieldRef<"Message", 'String'>
    readonly typeMessage: FieldRef<"Message", 'TypeMessage'>
    readonly fichierUrl: FieldRef<"Message", 'String'>
    readonly typeInteractif: FieldRef<"Message", 'String'>
    readonly donneesInteractives: FieldRef<"Message", 'Json'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly editedAt: FieldRef<"Message", 'DateTime'>
    readonly deletedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.messagesLus
   */
  export type Message$messagesLusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLu
     */
    select?: MessageLuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLuInclude<ExtArgs> | null
    where?: MessageLuWhereInput
    orderBy?: MessageLuOrderByWithRelationInput | MessageLuOrderByWithRelationInput[]
    cursor?: MessageLuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageLuScalarFieldEnum | MessageLuScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model MessageLu
   */

  export type AggregateMessageLu = {
    _count: MessageLuCountAggregateOutputType | null
    _avg: MessageLuAvgAggregateOutputType | null
    _sum: MessageLuSumAggregateOutputType | null
    _min: MessageLuMinAggregateOutputType | null
    _max: MessageLuMaxAggregateOutputType | null
  }

  export type MessageLuAvgAggregateOutputType = {
    messageId: number | null
    personnelId: number | null
  }

  export type MessageLuSumAggregateOutputType = {
    messageId: number | null
    personnelId: number | null
  }

  export type MessageLuMinAggregateOutputType = {
    messageId: number | null
    personnelId: number | null
    dateLecture: Date | null
  }

  export type MessageLuMaxAggregateOutputType = {
    messageId: number | null
    personnelId: number | null
    dateLecture: Date | null
  }

  export type MessageLuCountAggregateOutputType = {
    messageId: number
    personnelId: number
    dateLecture: number
    _all: number
  }


  export type MessageLuAvgAggregateInputType = {
    messageId?: true
    personnelId?: true
  }

  export type MessageLuSumAggregateInputType = {
    messageId?: true
    personnelId?: true
  }

  export type MessageLuMinAggregateInputType = {
    messageId?: true
    personnelId?: true
    dateLecture?: true
  }

  export type MessageLuMaxAggregateInputType = {
    messageId?: true
    personnelId?: true
    dateLecture?: true
  }

  export type MessageLuCountAggregateInputType = {
    messageId?: true
    personnelId?: true
    dateLecture?: true
    _all?: true
  }

  export type MessageLuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageLu to aggregate.
     */
    where?: MessageLuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLus to fetch.
     */
    orderBy?: MessageLuOrderByWithRelationInput | MessageLuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageLuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageLus
    **/
    _count?: true | MessageLuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageLuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageLuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageLuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageLuMaxAggregateInputType
  }

  export type GetMessageLuAggregateType<T extends MessageLuAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageLu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageLu[P]>
      : GetScalarType<T[P], AggregateMessageLu[P]>
  }




  export type MessageLuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageLuWhereInput
    orderBy?: MessageLuOrderByWithAggregationInput | MessageLuOrderByWithAggregationInput[]
    by: MessageLuScalarFieldEnum[] | MessageLuScalarFieldEnum
    having?: MessageLuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageLuCountAggregateInputType | true
    _avg?: MessageLuAvgAggregateInputType
    _sum?: MessageLuSumAggregateInputType
    _min?: MessageLuMinAggregateInputType
    _max?: MessageLuMaxAggregateInputType
  }

  export type MessageLuGroupByOutputType = {
    messageId: number
    personnelId: number
    dateLecture: Date
    _count: MessageLuCountAggregateOutputType | null
    _avg: MessageLuAvgAggregateOutputType | null
    _sum: MessageLuSumAggregateOutputType | null
    _min: MessageLuMinAggregateOutputType | null
    _max: MessageLuMaxAggregateOutputType | null
  }

  type GetMessageLuGroupByPayload<T extends MessageLuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageLuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageLuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageLuGroupByOutputType[P]>
            : GetScalarType<T[P], MessageLuGroupByOutputType[P]>
        }
      >
    >


  export type MessageLuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    personnelId?: boolean
    dateLecture?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageLu"]>

  export type MessageLuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    personnelId?: boolean
    dateLecture?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageLu"]>

  export type MessageLuSelectScalar = {
    messageId?: boolean
    personnelId?: boolean
    dateLecture?: boolean
  }

  export type MessageLuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }
  export type MessageLuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }

  export type $MessageLuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageLu"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      personnel: Prisma.$PersonnelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      messageId: number
      personnelId: number
      dateLecture: Date
    }, ExtArgs["result"]["messageLu"]>
    composites: {}
  }

  type MessageLuGetPayload<S extends boolean | null | undefined | MessageLuDefaultArgs> = $Result.GetResult<Prisma.$MessageLuPayload, S>

  type MessageLuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageLuFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageLuCountAggregateInputType | true
    }

  export interface MessageLuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageLu'], meta: { name: 'MessageLu' } }
    /**
     * Find zero or one MessageLu that matches the filter.
     * @param {MessageLuFindUniqueArgs} args - Arguments to find a MessageLu
     * @example
     * // Get one MessageLu
     * const messageLu = await prisma.messageLu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageLuFindUniqueArgs>(args: SelectSubset<T, MessageLuFindUniqueArgs<ExtArgs>>): Prisma__MessageLuClient<$Result.GetResult<Prisma.$MessageLuPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageLu that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageLuFindUniqueOrThrowArgs} args - Arguments to find a MessageLu
     * @example
     * // Get one MessageLu
     * const messageLu = await prisma.messageLu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageLuFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageLuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageLuClient<$Result.GetResult<Prisma.$MessageLuPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageLu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLuFindFirstArgs} args - Arguments to find a MessageLu
     * @example
     * // Get one MessageLu
     * const messageLu = await prisma.messageLu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageLuFindFirstArgs>(args?: SelectSubset<T, MessageLuFindFirstArgs<ExtArgs>>): Prisma__MessageLuClient<$Result.GetResult<Prisma.$MessageLuPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageLu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLuFindFirstOrThrowArgs} args - Arguments to find a MessageLu
     * @example
     * // Get one MessageLu
     * const messageLu = await prisma.messageLu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageLuFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageLuFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageLuClient<$Result.GetResult<Prisma.$MessageLuPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageLus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageLus
     * const messageLus = await prisma.messageLu.findMany()
     * 
     * // Get first 10 MessageLus
     * const messageLus = await prisma.messageLu.findMany({ take: 10 })
     * 
     * // Only select the `messageId`
     * const messageLuWithMessageIdOnly = await prisma.messageLu.findMany({ select: { messageId: true } })
     * 
     */
    findMany<T extends MessageLuFindManyArgs>(args?: SelectSubset<T, MessageLuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLuPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageLu.
     * @param {MessageLuCreateArgs} args - Arguments to create a MessageLu.
     * @example
     * // Create one MessageLu
     * const MessageLu = await prisma.messageLu.create({
     *   data: {
     *     // ... data to create a MessageLu
     *   }
     * })
     * 
     */
    create<T extends MessageLuCreateArgs>(args: SelectSubset<T, MessageLuCreateArgs<ExtArgs>>): Prisma__MessageLuClient<$Result.GetResult<Prisma.$MessageLuPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageLus.
     * @param {MessageLuCreateManyArgs} args - Arguments to create many MessageLus.
     * @example
     * // Create many MessageLus
     * const messageLu = await prisma.messageLu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageLuCreateManyArgs>(args?: SelectSubset<T, MessageLuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageLus and returns the data saved in the database.
     * @param {MessageLuCreateManyAndReturnArgs} args - Arguments to create many MessageLus.
     * @example
     * // Create many MessageLus
     * const messageLu = await prisma.messageLu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageLus and only return the `messageId`
     * const messageLuWithMessageIdOnly = await prisma.messageLu.createManyAndReturn({ 
     *   select: { messageId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageLuCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageLuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLuPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MessageLu.
     * @param {MessageLuDeleteArgs} args - Arguments to delete one MessageLu.
     * @example
     * // Delete one MessageLu
     * const MessageLu = await prisma.messageLu.delete({
     *   where: {
     *     // ... filter to delete one MessageLu
     *   }
     * })
     * 
     */
    delete<T extends MessageLuDeleteArgs>(args: SelectSubset<T, MessageLuDeleteArgs<ExtArgs>>): Prisma__MessageLuClient<$Result.GetResult<Prisma.$MessageLuPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageLu.
     * @param {MessageLuUpdateArgs} args - Arguments to update one MessageLu.
     * @example
     * // Update one MessageLu
     * const messageLu = await prisma.messageLu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageLuUpdateArgs>(args: SelectSubset<T, MessageLuUpdateArgs<ExtArgs>>): Prisma__MessageLuClient<$Result.GetResult<Prisma.$MessageLuPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageLus.
     * @param {MessageLuDeleteManyArgs} args - Arguments to filter MessageLus to delete.
     * @example
     * // Delete a few MessageLus
     * const { count } = await prisma.messageLu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageLuDeleteManyArgs>(args?: SelectSubset<T, MessageLuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageLus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageLus
     * const messageLu = await prisma.messageLu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageLuUpdateManyArgs>(args: SelectSubset<T, MessageLuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageLu.
     * @param {MessageLuUpsertArgs} args - Arguments to update or create a MessageLu.
     * @example
     * // Update or create a MessageLu
     * const messageLu = await prisma.messageLu.upsert({
     *   create: {
     *     // ... data to create a MessageLu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageLu we want to update
     *   }
     * })
     */
    upsert<T extends MessageLuUpsertArgs>(args: SelectSubset<T, MessageLuUpsertArgs<ExtArgs>>): Prisma__MessageLuClient<$Result.GetResult<Prisma.$MessageLuPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageLus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLuCountArgs} args - Arguments to filter MessageLus to count.
     * @example
     * // Count the number of MessageLus
     * const count = await prisma.messageLu.count({
     *   where: {
     *     // ... the filter for the MessageLus we want to count
     *   }
     * })
    **/
    count<T extends MessageLuCountArgs>(
      args?: Subset<T, MessageLuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageLuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageLu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageLuAggregateArgs>(args: Subset<T, MessageLuAggregateArgs>): Prisma.PrismaPromise<GetMessageLuAggregateType<T>>

    /**
     * Group by MessageLu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageLuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageLuGroupByArgs['orderBy'] }
        : { orderBy?: MessageLuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageLuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageLuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageLu model
   */
  readonly fields: MessageLuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageLu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageLuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    personnel<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageLu model
   */ 
  interface MessageLuFieldRefs {
    readonly messageId: FieldRef<"MessageLu", 'Int'>
    readonly personnelId: FieldRef<"MessageLu", 'Int'>
    readonly dateLecture: FieldRef<"MessageLu", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageLu findUnique
   */
  export type MessageLuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLu
     */
    select?: MessageLuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLuInclude<ExtArgs> | null
    /**
     * Filter, which MessageLu to fetch.
     */
    where: MessageLuWhereUniqueInput
  }

  /**
   * MessageLu findUniqueOrThrow
   */
  export type MessageLuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLu
     */
    select?: MessageLuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLuInclude<ExtArgs> | null
    /**
     * Filter, which MessageLu to fetch.
     */
    where: MessageLuWhereUniqueInput
  }

  /**
   * MessageLu findFirst
   */
  export type MessageLuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLu
     */
    select?: MessageLuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLuInclude<ExtArgs> | null
    /**
     * Filter, which MessageLu to fetch.
     */
    where?: MessageLuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLus to fetch.
     */
    orderBy?: MessageLuOrderByWithRelationInput | MessageLuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageLus.
     */
    cursor?: MessageLuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageLus.
     */
    distinct?: MessageLuScalarFieldEnum | MessageLuScalarFieldEnum[]
  }

  /**
   * MessageLu findFirstOrThrow
   */
  export type MessageLuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLu
     */
    select?: MessageLuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLuInclude<ExtArgs> | null
    /**
     * Filter, which MessageLu to fetch.
     */
    where?: MessageLuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLus to fetch.
     */
    orderBy?: MessageLuOrderByWithRelationInput | MessageLuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageLus.
     */
    cursor?: MessageLuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageLus.
     */
    distinct?: MessageLuScalarFieldEnum | MessageLuScalarFieldEnum[]
  }

  /**
   * MessageLu findMany
   */
  export type MessageLuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLu
     */
    select?: MessageLuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLuInclude<ExtArgs> | null
    /**
     * Filter, which MessageLus to fetch.
     */
    where?: MessageLuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLus to fetch.
     */
    orderBy?: MessageLuOrderByWithRelationInput | MessageLuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageLus.
     */
    cursor?: MessageLuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLus.
     */
    skip?: number
    distinct?: MessageLuScalarFieldEnum | MessageLuScalarFieldEnum[]
  }

  /**
   * MessageLu create
   */
  export type MessageLuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLu
     */
    select?: MessageLuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLuInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageLu.
     */
    data: XOR<MessageLuCreateInput, MessageLuUncheckedCreateInput>
  }

  /**
   * MessageLu createMany
   */
  export type MessageLuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageLus.
     */
    data: MessageLuCreateManyInput | MessageLuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageLu createManyAndReturn
   */
  export type MessageLuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLu
     */
    select?: MessageLuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MessageLus.
     */
    data: MessageLuCreateManyInput | MessageLuCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLuIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageLu update
   */
  export type MessageLuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLu
     */
    select?: MessageLuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLuInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageLu.
     */
    data: XOR<MessageLuUpdateInput, MessageLuUncheckedUpdateInput>
    /**
     * Choose, which MessageLu to update.
     */
    where: MessageLuWhereUniqueInput
  }

  /**
   * MessageLu updateMany
   */
  export type MessageLuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageLus.
     */
    data: XOR<MessageLuUpdateManyMutationInput, MessageLuUncheckedUpdateManyInput>
    /**
     * Filter which MessageLus to update
     */
    where?: MessageLuWhereInput
  }

  /**
   * MessageLu upsert
   */
  export type MessageLuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLu
     */
    select?: MessageLuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLuInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageLu to update in case it exists.
     */
    where: MessageLuWhereUniqueInput
    /**
     * In case the MessageLu found by the `where` argument doesn't exist, create a new MessageLu with this data.
     */
    create: XOR<MessageLuCreateInput, MessageLuUncheckedCreateInput>
    /**
     * In case the MessageLu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageLuUpdateInput, MessageLuUncheckedUpdateInput>
  }

  /**
   * MessageLu delete
   */
  export type MessageLuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLu
     */
    select?: MessageLuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLuInclude<ExtArgs> | null
    /**
     * Filter which MessageLu to delete.
     */
    where: MessageLuWhereUniqueInput
  }

  /**
   * MessageLu deleteMany
   */
  export type MessageLuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageLus to delete
     */
    where?: MessageLuWhereInput
  }

  /**
   * MessageLu without action
   */
  export type MessageLuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLu
     */
    select?: MessageLuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLuInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    destinataireId: number | null
    entiteId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    destinataireId: number | null
    entiteId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    destinataireId: number | null
    typeNotification: string | null
    titre: string | null
    message: string | null
    niveau: $Enums.NiveauNotification | null
    entiteType: string | null
    entiteId: number | null
    lue: boolean | null
    dateLecture: Date | null
    envoyeePush: boolean | null
    envoyeeEmail: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    destinataireId: number | null
    typeNotification: string | null
    titre: string | null
    message: string | null
    niveau: $Enums.NiveauNotification | null
    entiteType: string | null
    entiteId: number | null
    lue: boolean | null
    dateLecture: Date | null
    envoyeePush: boolean | null
    envoyeeEmail: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    destinataireId: number
    typeNotification: number
    titre: number
    message: number
    niveau: number
    entiteType: number
    entiteId: number
    donneesSupplementaires: number
    lue: number
    dateLecture: number
    envoyeePush: number
    envoyeeEmail: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    destinataireId?: true
    entiteId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    destinataireId?: true
    entiteId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    destinataireId?: true
    typeNotification?: true
    titre?: true
    message?: true
    niveau?: true
    entiteType?: true
    entiteId?: true
    lue?: true
    dateLecture?: true
    envoyeePush?: true
    envoyeeEmail?: true
    createdAt?: true
    expiresAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    destinataireId?: true
    typeNotification?: true
    titre?: true
    message?: true
    niveau?: true
    entiteType?: true
    entiteId?: true
    lue?: true
    dateLecture?: true
    envoyeePush?: true
    envoyeeEmail?: true
    createdAt?: true
    expiresAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    destinataireId?: true
    typeNotification?: true
    titre?: true
    message?: true
    niveau?: true
    entiteType?: true
    entiteId?: true
    donneesSupplementaires?: true
    lue?: true
    dateLecture?: true
    envoyeePush?: true
    envoyeeEmail?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    destinataireId: number
    typeNotification: string
    titre: string
    message: string
    niveau: $Enums.NiveauNotification
    entiteType: string | null
    entiteId: number | null
    donneesSupplementaires: JsonValue | null
    lue: boolean
    dateLecture: Date | null
    envoyeePush: boolean
    envoyeeEmail: boolean
    createdAt: Date
    expiresAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    destinataireId?: boolean
    typeNotification?: boolean
    titre?: boolean
    message?: boolean
    niveau?: boolean
    entiteType?: boolean
    entiteId?: boolean
    donneesSupplementaires?: boolean
    lue?: boolean
    dateLecture?: boolean
    envoyeePush?: boolean
    envoyeeEmail?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    destinataire?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    destinataireId?: boolean
    typeNotification?: boolean
    titre?: boolean
    message?: boolean
    niveau?: boolean
    entiteType?: boolean
    entiteId?: boolean
    donneesSupplementaires?: boolean
    lue?: boolean
    dateLecture?: boolean
    envoyeePush?: boolean
    envoyeeEmail?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    destinataire?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    destinataireId?: boolean
    typeNotification?: boolean
    titre?: boolean
    message?: boolean
    niveau?: boolean
    entiteType?: boolean
    entiteId?: boolean
    donneesSupplementaires?: boolean
    lue?: boolean
    dateLecture?: boolean
    envoyeePush?: boolean
    envoyeeEmail?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destinataire?: boolean | PersonnelDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destinataire?: boolean | PersonnelDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      destinataire: Prisma.$PersonnelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      destinataireId: number
      typeNotification: string
      titre: string
      message: string
      niveau: $Enums.NiveauNotification
      entiteType: string | null
      entiteId: number | null
      donneesSupplementaires: Prisma.JsonValue | null
      lue: boolean
      dateLecture: Date | null
      envoyeePush: boolean
      envoyeeEmail: boolean
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    destinataire<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly destinataireId: FieldRef<"Notification", 'Int'>
    readonly typeNotification: FieldRef<"Notification", 'String'>
    readonly titre: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly niveau: FieldRef<"Notification", 'NiveauNotification'>
    readonly entiteType: FieldRef<"Notification", 'String'>
    readonly entiteId: FieldRef<"Notification", 'Int'>
    readonly donneesSupplementaires: FieldRef<"Notification", 'Json'>
    readonly lue: FieldRef<"Notification", 'Boolean'>
    readonly dateLecture: FieldRef<"Notification", 'DateTime'>
    readonly envoyeePush: FieldRef<"Notification", 'Boolean'>
    readonly envoyeeEmail: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly expiresAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Evenement
   */

  export type AggregateEvenement = {
    _count: EvenementCountAggregateOutputType | null
    _avg: EvenementAvgAggregateOutputType | null
    _sum: EvenementSumAggregateOutputType | null
    _min: EvenementMinAggregateOutputType | null
    _max: EvenementMaxAggregateOutputType | null
  }

  export type EvenementAvgAggregateOutputType = {
    id: number | null
    createurId: number | null
    centreId: number | null
  }

  export type EvenementSumAggregateOutputType = {
    id: number | null
    createurId: number | null
    centreId: number | null
  }

  export type EvenementMinAggregateOutputType = {
    id: number | null
    createurId: number | null
    centreId: number | null
    titre: string | null
    description: string | null
    lieu: string | null
    dateDebut: Date | null
    dateFin: Date | null
    journeeEntiere: boolean | null
    typeEvenement: string | null
    visibilite: $Enums.VisibiliteEvenement | null
    recurrent: boolean | null
    couleur: string | null
    annule: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvenementMaxAggregateOutputType = {
    id: number | null
    createurId: number | null
    centreId: number | null
    titre: string | null
    description: string | null
    lieu: string | null
    dateDebut: Date | null
    dateFin: Date | null
    journeeEntiere: boolean | null
    typeEvenement: string | null
    visibilite: $Enums.VisibiliteEvenement | null
    recurrent: boolean | null
    couleur: string | null
    annule: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvenementCountAggregateOutputType = {
    id: number
    createurId: number
    centreId: number
    titre: number
    description: number
    lieu: number
    dateDebut: number
    dateFin: number
    journeeEntiere: number
    typeEvenement: number
    visibilite: number
    recurrent: number
    patternRecurrence: number
    couleur: number
    rappels: number
    annule: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EvenementAvgAggregateInputType = {
    id?: true
    createurId?: true
    centreId?: true
  }

  export type EvenementSumAggregateInputType = {
    id?: true
    createurId?: true
    centreId?: true
  }

  export type EvenementMinAggregateInputType = {
    id?: true
    createurId?: true
    centreId?: true
    titre?: true
    description?: true
    lieu?: true
    dateDebut?: true
    dateFin?: true
    journeeEntiere?: true
    typeEvenement?: true
    visibilite?: true
    recurrent?: true
    couleur?: true
    annule?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvenementMaxAggregateInputType = {
    id?: true
    createurId?: true
    centreId?: true
    titre?: true
    description?: true
    lieu?: true
    dateDebut?: true
    dateFin?: true
    journeeEntiere?: true
    typeEvenement?: true
    visibilite?: true
    recurrent?: true
    couleur?: true
    annule?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvenementCountAggregateInputType = {
    id?: true
    createurId?: true
    centreId?: true
    titre?: true
    description?: true
    lieu?: true
    dateDebut?: true
    dateFin?: true
    journeeEntiere?: true
    typeEvenement?: true
    visibilite?: true
    recurrent?: true
    patternRecurrence?: true
    couleur?: true
    rappels?: true
    annule?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EvenementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evenement to aggregate.
     */
    where?: EvenementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evenements to fetch.
     */
    orderBy?: EvenementOrderByWithRelationInput | EvenementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvenementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evenements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evenements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evenements
    **/
    _count?: true | EvenementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvenementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvenementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvenementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvenementMaxAggregateInputType
  }

  export type GetEvenementAggregateType<T extends EvenementAggregateArgs> = {
        [P in keyof T & keyof AggregateEvenement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvenement[P]>
      : GetScalarType<T[P], AggregateEvenement[P]>
  }




  export type EvenementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvenementWhereInput
    orderBy?: EvenementOrderByWithAggregationInput | EvenementOrderByWithAggregationInput[]
    by: EvenementScalarFieldEnum[] | EvenementScalarFieldEnum
    having?: EvenementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvenementCountAggregateInputType | true
    _avg?: EvenementAvgAggregateInputType
    _sum?: EvenementSumAggregateInputType
    _min?: EvenementMinAggregateInputType
    _max?: EvenementMaxAggregateInputType
  }

  export type EvenementGroupByOutputType = {
    id: number
    createurId: number
    centreId: number | null
    titre: string
    description: string | null
    lieu: string | null
    dateDebut: Date
    dateFin: Date
    journeeEntiere: boolean
    typeEvenement: string | null
    visibilite: $Enums.VisibiliteEvenement
    recurrent: boolean
    patternRecurrence: JsonValue | null
    couleur: string | null
    rappels: JsonValue
    annule: boolean
    createdAt: Date
    updatedAt: Date
    _count: EvenementCountAggregateOutputType | null
    _avg: EvenementAvgAggregateOutputType | null
    _sum: EvenementSumAggregateOutputType | null
    _min: EvenementMinAggregateOutputType | null
    _max: EvenementMaxAggregateOutputType | null
  }

  type GetEvenementGroupByPayload<T extends EvenementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvenementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvenementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvenementGroupByOutputType[P]>
            : GetScalarType<T[P], EvenementGroupByOutputType[P]>
        }
      >
    >


  export type EvenementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createurId?: boolean
    centreId?: boolean
    titre?: boolean
    description?: boolean
    lieu?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    journeeEntiere?: boolean
    typeEvenement?: boolean
    visibilite?: boolean
    recurrent?: boolean
    patternRecurrence?: boolean
    couleur?: boolean
    rappels?: boolean
    annule?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createur?: boolean | PersonnelDefaultArgs<ExtArgs>
    centre?: boolean | Evenement$centreArgs<ExtArgs>
    participants?: boolean | Evenement$participantsArgs<ExtArgs>
    _count?: boolean | EvenementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evenement"]>

  export type EvenementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createurId?: boolean
    centreId?: boolean
    titre?: boolean
    description?: boolean
    lieu?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    journeeEntiere?: boolean
    typeEvenement?: boolean
    visibilite?: boolean
    recurrent?: boolean
    patternRecurrence?: boolean
    couleur?: boolean
    rappels?: boolean
    annule?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createur?: boolean | PersonnelDefaultArgs<ExtArgs>
    centre?: boolean | Evenement$centreArgs<ExtArgs>
  }, ExtArgs["result"]["evenement"]>

  export type EvenementSelectScalar = {
    id?: boolean
    createurId?: boolean
    centreId?: boolean
    titre?: boolean
    description?: boolean
    lieu?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    journeeEntiere?: boolean
    typeEvenement?: boolean
    visibilite?: boolean
    recurrent?: boolean
    patternRecurrence?: boolean
    couleur?: boolean
    rappels?: boolean
    annule?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EvenementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createur?: boolean | PersonnelDefaultArgs<ExtArgs>
    centre?: boolean | Evenement$centreArgs<ExtArgs>
    participants?: boolean | Evenement$participantsArgs<ExtArgs>
    _count?: boolean | EvenementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EvenementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createur?: boolean | PersonnelDefaultArgs<ExtArgs>
    centre?: boolean | Evenement$centreArgs<ExtArgs>
  }

  export type $EvenementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evenement"
    objects: {
      createur: Prisma.$PersonnelPayload<ExtArgs>
      centre: Prisma.$CentrePayload<ExtArgs> | null
      participants: Prisma.$EvenementParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createurId: number
      centreId: number | null
      titre: string
      description: string | null
      lieu: string | null
      dateDebut: Date
      dateFin: Date
      journeeEntiere: boolean
      typeEvenement: string | null
      visibilite: $Enums.VisibiliteEvenement
      recurrent: boolean
      patternRecurrence: Prisma.JsonValue | null
      couleur: string | null
      rappels: Prisma.JsonValue
      annule: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evenement"]>
    composites: {}
  }

  type EvenementGetPayload<S extends boolean | null | undefined | EvenementDefaultArgs> = $Result.GetResult<Prisma.$EvenementPayload, S>

  type EvenementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvenementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvenementCountAggregateInputType | true
    }

  export interface EvenementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evenement'], meta: { name: 'Evenement' } }
    /**
     * Find zero or one Evenement that matches the filter.
     * @param {EvenementFindUniqueArgs} args - Arguments to find a Evenement
     * @example
     * // Get one Evenement
     * const evenement = await prisma.evenement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvenementFindUniqueArgs>(args: SelectSubset<T, EvenementFindUniqueArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Evenement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvenementFindUniqueOrThrowArgs} args - Arguments to find a Evenement
     * @example
     * // Get one Evenement
     * const evenement = await prisma.evenement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvenementFindUniqueOrThrowArgs>(args: SelectSubset<T, EvenementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Evenement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementFindFirstArgs} args - Arguments to find a Evenement
     * @example
     * // Get one Evenement
     * const evenement = await prisma.evenement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvenementFindFirstArgs>(args?: SelectSubset<T, EvenementFindFirstArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Evenement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementFindFirstOrThrowArgs} args - Arguments to find a Evenement
     * @example
     * // Get one Evenement
     * const evenement = await prisma.evenement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvenementFindFirstOrThrowArgs>(args?: SelectSubset<T, EvenementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Evenements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evenements
     * const evenements = await prisma.evenement.findMany()
     * 
     * // Get first 10 Evenements
     * const evenements = await prisma.evenement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evenementWithIdOnly = await prisma.evenement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvenementFindManyArgs>(args?: SelectSubset<T, EvenementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Evenement.
     * @param {EvenementCreateArgs} args - Arguments to create a Evenement.
     * @example
     * // Create one Evenement
     * const Evenement = await prisma.evenement.create({
     *   data: {
     *     // ... data to create a Evenement
     *   }
     * })
     * 
     */
    create<T extends EvenementCreateArgs>(args: SelectSubset<T, EvenementCreateArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Evenements.
     * @param {EvenementCreateManyArgs} args - Arguments to create many Evenements.
     * @example
     * // Create many Evenements
     * const evenement = await prisma.evenement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvenementCreateManyArgs>(args?: SelectSubset<T, EvenementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evenements and returns the data saved in the database.
     * @param {EvenementCreateManyAndReturnArgs} args - Arguments to create many Evenements.
     * @example
     * // Create many Evenements
     * const evenement = await prisma.evenement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evenements and only return the `id`
     * const evenementWithIdOnly = await prisma.evenement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvenementCreateManyAndReturnArgs>(args?: SelectSubset<T, EvenementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Evenement.
     * @param {EvenementDeleteArgs} args - Arguments to delete one Evenement.
     * @example
     * // Delete one Evenement
     * const Evenement = await prisma.evenement.delete({
     *   where: {
     *     // ... filter to delete one Evenement
     *   }
     * })
     * 
     */
    delete<T extends EvenementDeleteArgs>(args: SelectSubset<T, EvenementDeleteArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Evenement.
     * @param {EvenementUpdateArgs} args - Arguments to update one Evenement.
     * @example
     * // Update one Evenement
     * const evenement = await prisma.evenement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvenementUpdateArgs>(args: SelectSubset<T, EvenementUpdateArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Evenements.
     * @param {EvenementDeleteManyArgs} args - Arguments to filter Evenements to delete.
     * @example
     * // Delete a few Evenements
     * const { count } = await prisma.evenement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvenementDeleteManyArgs>(args?: SelectSubset<T, EvenementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evenements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evenements
     * const evenement = await prisma.evenement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvenementUpdateManyArgs>(args: SelectSubset<T, EvenementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evenement.
     * @param {EvenementUpsertArgs} args - Arguments to update or create a Evenement.
     * @example
     * // Update or create a Evenement
     * const evenement = await prisma.evenement.upsert({
     *   create: {
     *     // ... data to create a Evenement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evenement we want to update
     *   }
     * })
     */
    upsert<T extends EvenementUpsertArgs>(args: SelectSubset<T, EvenementUpsertArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Evenements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementCountArgs} args - Arguments to filter Evenements to count.
     * @example
     * // Count the number of Evenements
     * const count = await prisma.evenement.count({
     *   where: {
     *     // ... the filter for the Evenements we want to count
     *   }
     * })
    **/
    count<T extends EvenementCountArgs>(
      args?: Subset<T, EvenementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvenementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evenement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvenementAggregateArgs>(args: Subset<T, EvenementAggregateArgs>): Prisma.PrismaPromise<GetEvenementAggregateType<T>>

    /**
     * Group by Evenement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvenementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvenementGroupByArgs['orderBy'] }
        : { orderBy?: EvenementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvenementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvenementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evenement model
   */
  readonly fields: EvenementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evenement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvenementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createur<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    centre<T extends Evenement$centreArgs<ExtArgs> = {}>(args?: Subset<T, Evenement$centreArgs<ExtArgs>>): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    participants<T extends Evenement$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Evenement$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evenement model
   */ 
  interface EvenementFieldRefs {
    readonly id: FieldRef<"Evenement", 'Int'>
    readonly createurId: FieldRef<"Evenement", 'Int'>
    readonly centreId: FieldRef<"Evenement", 'Int'>
    readonly titre: FieldRef<"Evenement", 'String'>
    readonly description: FieldRef<"Evenement", 'String'>
    readonly lieu: FieldRef<"Evenement", 'String'>
    readonly dateDebut: FieldRef<"Evenement", 'DateTime'>
    readonly dateFin: FieldRef<"Evenement", 'DateTime'>
    readonly journeeEntiere: FieldRef<"Evenement", 'Boolean'>
    readonly typeEvenement: FieldRef<"Evenement", 'String'>
    readonly visibilite: FieldRef<"Evenement", 'VisibiliteEvenement'>
    readonly recurrent: FieldRef<"Evenement", 'Boolean'>
    readonly patternRecurrence: FieldRef<"Evenement", 'Json'>
    readonly couleur: FieldRef<"Evenement", 'String'>
    readonly rappels: FieldRef<"Evenement", 'Json'>
    readonly annule: FieldRef<"Evenement", 'Boolean'>
    readonly createdAt: FieldRef<"Evenement", 'DateTime'>
    readonly updatedAt: FieldRef<"Evenement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evenement findUnique
   */
  export type EvenementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * Filter, which Evenement to fetch.
     */
    where: EvenementWhereUniqueInput
  }

  /**
   * Evenement findUniqueOrThrow
   */
  export type EvenementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * Filter, which Evenement to fetch.
     */
    where: EvenementWhereUniqueInput
  }

  /**
   * Evenement findFirst
   */
  export type EvenementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * Filter, which Evenement to fetch.
     */
    where?: EvenementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evenements to fetch.
     */
    orderBy?: EvenementOrderByWithRelationInput | EvenementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evenements.
     */
    cursor?: EvenementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evenements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evenements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evenements.
     */
    distinct?: EvenementScalarFieldEnum | EvenementScalarFieldEnum[]
  }

  /**
   * Evenement findFirstOrThrow
   */
  export type EvenementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * Filter, which Evenement to fetch.
     */
    where?: EvenementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evenements to fetch.
     */
    orderBy?: EvenementOrderByWithRelationInput | EvenementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evenements.
     */
    cursor?: EvenementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evenements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evenements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evenements.
     */
    distinct?: EvenementScalarFieldEnum | EvenementScalarFieldEnum[]
  }

  /**
   * Evenement findMany
   */
  export type EvenementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * Filter, which Evenements to fetch.
     */
    where?: EvenementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evenements to fetch.
     */
    orderBy?: EvenementOrderByWithRelationInput | EvenementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evenements.
     */
    cursor?: EvenementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evenements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evenements.
     */
    skip?: number
    distinct?: EvenementScalarFieldEnum | EvenementScalarFieldEnum[]
  }

  /**
   * Evenement create
   */
  export type EvenementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * The data needed to create a Evenement.
     */
    data: XOR<EvenementCreateInput, EvenementUncheckedCreateInput>
  }

  /**
   * Evenement createMany
   */
  export type EvenementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evenements.
     */
    data: EvenementCreateManyInput | EvenementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evenement createManyAndReturn
   */
  export type EvenementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Evenements.
     */
    data: EvenementCreateManyInput | EvenementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evenement update
   */
  export type EvenementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * The data needed to update a Evenement.
     */
    data: XOR<EvenementUpdateInput, EvenementUncheckedUpdateInput>
    /**
     * Choose, which Evenement to update.
     */
    where: EvenementWhereUniqueInput
  }

  /**
   * Evenement updateMany
   */
  export type EvenementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evenements.
     */
    data: XOR<EvenementUpdateManyMutationInput, EvenementUncheckedUpdateManyInput>
    /**
     * Filter which Evenements to update
     */
    where?: EvenementWhereInput
  }

  /**
   * Evenement upsert
   */
  export type EvenementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * The filter to search for the Evenement to update in case it exists.
     */
    where: EvenementWhereUniqueInput
    /**
     * In case the Evenement found by the `where` argument doesn't exist, create a new Evenement with this data.
     */
    create: XOR<EvenementCreateInput, EvenementUncheckedCreateInput>
    /**
     * In case the Evenement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvenementUpdateInput, EvenementUncheckedUpdateInput>
  }

  /**
   * Evenement delete
   */
  export type EvenementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
    /**
     * Filter which Evenement to delete.
     */
    where: EvenementWhereUniqueInput
  }

  /**
   * Evenement deleteMany
   */
  export type EvenementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evenements to delete
     */
    where?: EvenementWhereInput
  }

  /**
   * Evenement.centre
   */
  export type Evenement$centreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
    where?: CentreWhereInput
  }

  /**
   * Evenement.participants
   */
  export type Evenement$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementParticipant
     */
    select?: EvenementParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementParticipantInclude<ExtArgs> | null
    where?: EvenementParticipantWhereInput
    orderBy?: EvenementParticipantOrderByWithRelationInput | EvenementParticipantOrderByWithRelationInput[]
    cursor?: EvenementParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvenementParticipantScalarFieldEnum | EvenementParticipantScalarFieldEnum[]
  }

  /**
   * Evenement without action
   */
  export type EvenementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evenement
     */
    select?: EvenementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementInclude<ExtArgs> | null
  }


  /**
   * Model EvenementParticipant
   */

  export type AggregateEvenementParticipant = {
    _count: EvenementParticipantCountAggregateOutputType | null
    _avg: EvenementParticipantAvgAggregateOutputType | null
    _sum: EvenementParticipantSumAggregateOutputType | null
    _min: EvenementParticipantMinAggregateOutputType | null
    _max: EvenementParticipantMaxAggregateOutputType | null
  }

  export type EvenementParticipantAvgAggregateOutputType = {
    evenementId: number | null
    personnelId: number | null
  }

  export type EvenementParticipantSumAggregateOutputType = {
    evenementId: number | null
    personnelId: number | null
  }

  export type EvenementParticipantMinAggregateOutputType = {
    evenementId: number | null
    personnelId: number | null
    statutInvitation: $Enums.StatutInvitation | null
    obligatoire: boolean | null
    dateReponse: Date | null
    commentaire: string | null
  }

  export type EvenementParticipantMaxAggregateOutputType = {
    evenementId: number | null
    personnelId: number | null
    statutInvitation: $Enums.StatutInvitation | null
    obligatoire: boolean | null
    dateReponse: Date | null
    commentaire: string | null
  }

  export type EvenementParticipantCountAggregateOutputType = {
    evenementId: number
    personnelId: number
    statutInvitation: number
    obligatoire: number
    dateReponse: number
    commentaire: number
    _all: number
  }


  export type EvenementParticipantAvgAggregateInputType = {
    evenementId?: true
    personnelId?: true
  }

  export type EvenementParticipantSumAggregateInputType = {
    evenementId?: true
    personnelId?: true
  }

  export type EvenementParticipantMinAggregateInputType = {
    evenementId?: true
    personnelId?: true
    statutInvitation?: true
    obligatoire?: true
    dateReponse?: true
    commentaire?: true
  }

  export type EvenementParticipantMaxAggregateInputType = {
    evenementId?: true
    personnelId?: true
    statutInvitation?: true
    obligatoire?: true
    dateReponse?: true
    commentaire?: true
  }

  export type EvenementParticipantCountAggregateInputType = {
    evenementId?: true
    personnelId?: true
    statutInvitation?: true
    obligatoire?: true
    dateReponse?: true
    commentaire?: true
    _all?: true
  }

  export type EvenementParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvenementParticipant to aggregate.
     */
    where?: EvenementParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvenementParticipants to fetch.
     */
    orderBy?: EvenementParticipantOrderByWithRelationInput | EvenementParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvenementParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvenementParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvenementParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvenementParticipants
    **/
    _count?: true | EvenementParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvenementParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvenementParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvenementParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvenementParticipantMaxAggregateInputType
  }

  export type GetEvenementParticipantAggregateType<T extends EvenementParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateEvenementParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvenementParticipant[P]>
      : GetScalarType<T[P], AggregateEvenementParticipant[P]>
  }




  export type EvenementParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvenementParticipantWhereInput
    orderBy?: EvenementParticipantOrderByWithAggregationInput | EvenementParticipantOrderByWithAggregationInput[]
    by: EvenementParticipantScalarFieldEnum[] | EvenementParticipantScalarFieldEnum
    having?: EvenementParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvenementParticipantCountAggregateInputType | true
    _avg?: EvenementParticipantAvgAggregateInputType
    _sum?: EvenementParticipantSumAggregateInputType
    _min?: EvenementParticipantMinAggregateInputType
    _max?: EvenementParticipantMaxAggregateInputType
  }

  export type EvenementParticipantGroupByOutputType = {
    evenementId: number
    personnelId: number
    statutInvitation: $Enums.StatutInvitation
    obligatoire: boolean
    dateReponse: Date | null
    commentaire: string | null
    _count: EvenementParticipantCountAggregateOutputType | null
    _avg: EvenementParticipantAvgAggregateOutputType | null
    _sum: EvenementParticipantSumAggregateOutputType | null
    _min: EvenementParticipantMinAggregateOutputType | null
    _max: EvenementParticipantMaxAggregateOutputType | null
  }

  type GetEvenementParticipantGroupByPayload<T extends EvenementParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvenementParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvenementParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvenementParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], EvenementParticipantGroupByOutputType[P]>
        }
      >
    >


  export type EvenementParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    evenementId?: boolean
    personnelId?: boolean
    statutInvitation?: boolean
    obligatoire?: boolean
    dateReponse?: boolean
    commentaire?: boolean
    evenement?: boolean | EvenementDefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evenementParticipant"]>

  export type EvenementParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    evenementId?: boolean
    personnelId?: boolean
    statutInvitation?: boolean
    obligatoire?: boolean
    dateReponse?: boolean
    commentaire?: boolean
    evenement?: boolean | EvenementDefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evenementParticipant"]>

  export type EvenementParticipantSelectScalar = {
    evenementId?: boolean
    personnelId?: boolean
    statutInvitation?: boolean
    obligatoire?: boolean
    dateReponse?: boolean
    commentaire?: boolean
  }

  export type EvenementParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evenement?: boolean | EvenementDefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }
  export type EvenementParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evenement?: boolean | EvenementDefaultArgs<ExtArgs>
    personnel?: boolean | PersonnelDefaultArgs<ExtArgs>
  }

  export type $EvenementParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvenementParticipant"
    objects: {
      evenement: Prisma.$EvenementPayload<ExtArgs>
      personnel: Prisma.$PersonnelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      evenementId: number
      personnelId: number
      statutInvitation: $Enums.StatutInvitation
      obligatoire: boolean
      dateReponse: Date | null
      commentaire: string | null
    }, ExtArgs["result"]["evenementParticipant"]>
    composites: {}
  }

  type EvenementParticipantGetPayload<S extends boolean | null | undefined | EvenementParticipantDefaultArgs> = $Result.GetResult<Prisma.$EvenementParticipantPayload, S>

  type EvenementParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvenementParticipantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvenementParticipantCountAggregateInputType | true
    }

  export interface EvenementParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvenementParticipant'], meta: { name: 'EvenementParticipant' } }
    /**
     * Find zero or one EvenementParticipant that matches the filter.
     * @param {EvenementParticipantFindUniqueArgs} args - Arguments to find a EvenementParticipant
     * @example
     * // Get one EvenementParticipant
     * const evenementParticipant = await prisma.evenementParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvenementParticipantFindUniqueArgs>(args: SelectSubset<T, EvenementParticipantFindUniqueArgs<ExtArgs>>): Prisma__EvenementParticipantClient<$Result.GetResult<Prisma.$EvenementParticipantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EvenementParticipant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvenementParticipantFindUniqueOrThrowArgs} args - Arguments to find a EvenementParticipant
     * @example
     * // Get one EvenementParticipant
     * const evenementParticipant = await prisma.evenementParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvenementParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, EvenementParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvenementParticipantClient<$Result.GetResult<Prisma.$EvenementParticipantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EvenementParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementParticipantFindFirstArgs} args - Arguments to find a EvenementParticipant
     * @example
     * // Get one EvenementParticipant
     * const evenementParticipant = await prisma.evenementParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvenementParticipantFindFirstArgs>(args?: SelectSubset<T, EvenementParticipantFindFirstArgs<ExtArgs>>): Prisma__EvenementParticipantClient<$Result.GetResult<Prisma.$EvenementParticipantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EvenementParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementParticipantFindFirstOrThrowArgs} args - Arguments to find a EvenementParticipant
     * @example
     * // Get one EvenementParticipant
     * const evenementParticipant = await prisma.evenementParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvenementParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, EvenementParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvenementParticipantClient<$Result.GetResult<Prisma.$EvenementParticipantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EvenementParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvenementParticipants
     * const evenementParticipants = await prisma.evenementParticipant.findMany()
     * 
     * // Get first 10 EvenementParticipants
     * const evenementParticipants = await prisma.evenementParticipant.findMany({ take: 10 })
     * 
     * // Only select the `evenementId`
     * const evenementParticipantWithEvenementIdOnly = await prisma.evenementParticipant.findMany({ select: { evenementId: true } })
     * 
     */
    findMany<T extends EvenementParticipantFindManyArgs>(args?: SelectSubset<T, EvenementParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementParticipantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EvenementParticipant.
     * @param {EvenementParticipantCreateArgs} args - Arguments to create a EvenementParticipant.
     * @example
     * // Create one EvenementParticipant
     * const EvenementParticipant = await prisma.evenementParticipant.create({
     *   data: {
     *     // ... data to create a EvenementParticipant
     *   }
     * })
     * 
     */
    create<T extends EvenementParticipantCreateArgs>(args: SelectSubset<T, EvenementParticipantCreateArgs<ExtArgs>>): Prisma__EvenementParticipantClient<$Result.GetResult<Prisma.$EvenementParticipantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EvenementParticipants.
     * @param {EvenementParticipantCreateManyArgs} args - Arguments to create many EvenementParticipants.
     * @example
     * // Create many EvenementParticipants
     * const evenementParticipant = await prisma.evenementParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvenementParticipantCreateManyArgs>(args?: SelectSubset<T, EvenementParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvenementParticipants and returns the data saved in the database.
     * @param {EvenementParticipantCreateManyAndReturnArgs} args - Arguments to create many EvenementParticipants.
     * @example
     * // Create many EvenementParticipants
     * const evenementParticipant = await prisma.evenementParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvenementParticipants and only return the `evenementId`
     * const evenementParticipantWithEvenementIdOnly = await prisma.evenementParticipant.createManyAndReturn({ 
     *   select: { evenementId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvenementParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, EvenementParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementParticipantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EvenementParticipant.
     * @param {EvenementParticipantDeleteArgs} args - Arguments to delete one EvenementParticipant.
     * @example
     * // Delete one EvenementParticipant
     * const EvenementParticipant = await prisma.evenementParticipant.delete({
     *   where: {
     *     // ... filter to delete one EvenementParticipant
     *   }
     * })
     * 
     */
    delete<T extends EvenementParticipantDeleteArgs>(args: SelectSubset<T, EvenementParticipantDeleteArgs<ExtArgs>>): Prisma__EvenementParticipantClient<$Result.GetResult<Prisma.$EvenementParticipantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EvenementParticipant.
     * @param {EvenementParticipantUpdateArgs} args - Arguments to update one EvenementParticipant.
     * @example
     * // Update one EvenementParticipant
     * const evenementParticipant = await prisma.evenementParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvenementParticipantUpdateArgs>(args: SelectSubset<T, EvenementParticipantUpdateArgs<ExtArgs>>): Prisma__EvenementParticipantClient<$Result.GetResult<Prisma.$EvenementParticipantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EvenementParticipants.
     * @param {EvenementParticipantDeleteManyArgs} args - Arguments to filter EvenementParticipants to delete.
     * @example
     * // Delete a few EvenementParticipants
     * const { count } = await prisma.evenementParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvenementParticipantDeleteManyArgs>(args?: SelectSubset<T, EvenementParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvenementParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvenementParticipants
     * const evenementParticipant = await prisma.evenementParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvenementParticipantUpdateManyArgs>(args: SelectSubset<T, EvenementParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvenementParticipant.
     * @param {EvenementParticipantUpsertArgs} args - Arguments to update or create a EvenementParticipant.
     * @example
     * // Update or create a EvenementParticipant
     * const evenementParticipant = await prisma.evenementParticipant.upsert({
     *   create: {
     *     // ... data to create a EvenementParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvenementParticipant we want to update
     *   }
     * })
     */
    upsert<T extends EvenementParticipantUpsertArgs>(args: SelectSubset<T, EvenementParticipantUpsertArgs<ExtArgs>>): Prisma__EvenementParticipantClient<$Result.GetResult<Prisma.$EvenementParticipantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EvenementParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementParticipantCountArgs} args - Arguments to filter EvenementParticipants to count.
     * @example
     * // Count the number of EvenementParticipants
     * const count = await prisma.evenementParticipant.count({
     *   where: {
     *     // ... the filter for the EvenementParticipants we want to count
     *   }
     * })
    **/
    count<T extends EvenementParticipantCountArgs>(
      args?: Subset<T, EvenementParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvenementParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvenementParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvenementParticipantAggregateArgs>(args: Subset<T, EvenementParticipantAggregateArgs>): Prisma.PrismaPromise<GetEvenementParticipantAggregateType<T>>

    /**
     * Group by EvenementParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvenementParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvenementParticipantGroupByArgs['orderBy'] }
        : { orderBy?: EvenementParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvenementParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvenementParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvenementParticipant model
   */
  readonly fields: EvenementParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvenementParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvenementParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evenement<T extends EvenementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvenementDefaultArgs<ExtArgs>>): Prisma__EvenementClient<$Result.GetResult<Prisma.$EvenementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    personnel<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvenementParticipant model
   */ 
  interface EvenementParticipantFieldRefs {
    readonly evenementId: FieldRef<"EvenementParticipant", 'Int'>
    readonly personnelId: FieldRef<"EvenementParticipant", 'Int'>
    readonly statutInvitation: FieldRef<"EvenementParticipant", 'StatutInvitation'>
    readonly obligatoire: FieldRef<"EvenementParticipant", 'Boolean'>
    readonly dateReponse: FieldRef<"EvenementParticipant", 'DateTime'>
    readonly commentaire: FieldRef<"EvenementParticipant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EvenementParticipant findUnique
   */
  export type EvenementParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementParticipant
     */
    select?: EvenementParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EvenementParticipant to fetch.
     */
    where: EvenementParticipantWhereUniqueInput
  }

  /**
   * EvenementParticipant findUniqueOrThrow
   */
  export type EvenementParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementParticipant
     */
    select?: EvenementParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EvenementParticipant to fetch.
     */
    where: EvenementParticipantWhereUniqueInput
  }

  /**
   * EvenementParticipant findFirst
   */
  export type EvenementParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementParticipant
     */
    select?: EvenementParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EvenementParticipant to fetch.
     */
    where?: EvenementParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvenementParticipants to fetch.
     */
    orderBy?: EvenementParticipantOrderByWithRelationInput | EvenementParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvenementParticipants.
     */
    cursor?: EvenementParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvenementParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvenementParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvenementParticipants.
     */
    distinct?: EvenementParticipantScalarFieldEnum | EvenementParticipantScalarFieldEnum[]
  }

  /**
   * EvenementParticipant findFirstOrThrow
   */
  export type EvenementParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementParticipant
     */
    select?: EvenementParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EvenementParticipant to fetch.
     */
    where?: EvenementParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvenementParticipants to fetch.
     */
    orderBy?: EvenementParticipantOrderByWithRelationInput | EvenementParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvenementParticipants.
     */
    cursor?: EvenementParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvenementParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvenementParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvenementParticipants.
     */
    distinct?: EvenementParticipantScalarFieldEnum | EvenementParticipantScalarFieldEnum[]
  }

  /**
   * EvenementParticipant findMany
   */
  export type EvenementParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementParticipant
     */
    select?: EvenementParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EvenementParticipants to fetch.
     */
    where?: EvenementParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvenementParticipants to fetch.
     */
    orderBy?: EvenementParticipantOrderByWithRelationInput | EvenementParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvenementParticipants.
     */
    cursor?: EvenementParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvenementParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvenementParticipants.
     */
    skip?: number
    distinct?: EvenementParticipantScalarFieldEnum | EvenementParticipantScalarFieldEnum[]
  }

  /**
   * EvenementParticipant create
   */
  export type EvenementParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementParticipant
     */
    select?: EvenementParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a EvenementParticipant.
     */
    data: XOR<EvenementParticipantCreateInput, EvenementParticipantUncheckedCreateInput>
  }

  /**
   * EvenementParticipant createMany
   */
  export type EvenementParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvenementParticipants.
     */
    data: EvenementParticipantCreateManyInput | EvenementParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvenementParticipant createManyAndReturn
   */
  export type EvenementParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementParticipant
     */
    select?: EvenementParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EvenementParticipants.
     */
    data: EvenementParticipantCreateManyInput | EvenementParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvenementParticipant update
   */
  export type EvenementParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementParticipant
     */
    select?: EvenementParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a EvenementParticipant.
     */
    data: XOR<EvenementParticipantUpdateInput, EvenementParticipantUncheckedUpdateInput>
    /**
     * Choose, which EvenementParticipant to update.
     */
    where: EvenementParticipantWhereUniqueInput
  }

  /**
   * EvenementParticipant updateMany
   */
  export type EvenementParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvenementParticipants.
     */
    data: XOR<EvenementParticipantUpdateManyMutationInput, EvenementParticipantUncheckedUpdateManyInput>
    /**
     * Filter which EvenementParticipants to update
     */
    where?: EvenementParticipantWhereInput
  }

  /**
   * EvenementParticipant upsert
   */
  export type EvenementParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementParticipant
     */
    select?: EvenementParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the EvenementParticipant to update in case it exists.
     */
    where: EvenementParticipantWhereUniqueInput
    /**
     * In case the EvenementParticipant found by the `where` argument doesn't exist, create a new EvenementParticipant with this data.
     */
    create: XOR<EvenementParticipantCreateInput, EvenementParticipantUncheckedCreateInput>
    /**
     * In case the EvenementParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvenementParticipantUpdateInput, EvenementParticipantUncheckedUpdateInput>
  }

  /**
   * EvenementParticipant delete
   */
  export type EvenementParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementParticipant
     */
    select?: EvenementParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementParticipantInclude<ExtArgs> | null
    /**
     * Filter which EvenementParticipant to delete.
     */
    where: EvenementParticipantWhereUniqueInput
  }

  /**
   * EvenementParticipant deleteMany
   */
  export type EvenementParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvenementParticipants to delete
     */
    where?: EvenementParticipantWhereInput
  }

  /**
   * EvenementParticipant without action
   */
  export type EvenementParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementParticipant
     */
    select?: EvenementParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvenementParticipantInclude<ExtArgs> | null
  }


  /**
   * Model ExportTTA
   */

  export type AggregateExportTTA = {
    _count: ExportTTACountAggregateOutputType | null
    _avg: ExportTTAAvgAggregateOutputType | null
    _sum: ExportTTASumAggregateOutputType | null
    _min: ExportTTAMinAggregateOutputType | null
    _max: ExportTTAMaxAggregateOutputType | null
  }

  export type ExportTTAAvgAggregateOutputType = {
    id: number | null
    centreId: number | null
    genereParId: number | null
    nombreLignes: number | null
    montantTotal: number | null
    valideParId: number | null
    sessionId: number | null
  }

  export type ExportTTASumAggregateOutputType = {
    id: number | null
    centreId: number | null
    genereParId: number | null
    nombreLignes: number | null
    montantTotal: number | null
    valideParId: number | null
    sessionId: number | null
  }

  export type ExportTTAMinAggregateOutputType = {
    id: number | null
    periodeDebut: Date | null
    periodeFin: Date | null
    centreId: number | null
    genereParId: number | null
    dateGeneration: Date | null
    nombreLignes: number | null
    montantTotal: number | null
    fichierUrl: string | null
    formatExport: $Enums.FormatExport | null
    statut: $Enums.StatutExport | null
    dateValidation: Date | null
    valideParId: number | null
    dateTransmission: Date | null
    numeroBordereau: string | null
    commentaires: string | null
    sessionId: number | null
  }

  export type ExportTTAMaxAggregateOutputType = {
    id: number | null
    periodeDebut: Date | null
    periodeFin: Date | null
    centreId: number | null
    genereParId: number | null
    dateGeneration: Date | null
    nombreLignes: number | null
    montantTotal: number | null
    fichierUrl: string | null
    formatExport: $Enums.FormatExport | null
    statut: $Enums.StatutExport | null
    dateValidation: Date | null
    valideParId: number | null
    dateTransmission: Date | null
    numeroBordereau: string | null
    commentaires: string | null
    sessionId: number | null
  }

  export type ExportTTACountAggregateOutputType = {
    id: number
    periodeDebut: number
    periodeFin: number
    centreId: number
    genereParId: number
    dateGeneration: number
    nombreLignes: number
    montantTotal: number
    fichierUrl: number
    formatExport: number
    statut: number
    dateValidation: number
    valideParId: number
    dateTransmission: number
    numeroBordereau: number
    commentaires: number
    sessionId: number
    _all: number
  }


  export type ExportTTAAvgAggregateInputType = {
    id?: true
    centreId?: true
    genereParId?: true
    nombreLignes?: true
    montantTotal?: true
    valideParId?: true
    sessionId?: true
  }

  export type ExportTTASumAggregateInputType = {
    id?: true
    centreId?: true
    genereParId?: true
    nombreLignes?: true
    montantTotal?: true
    valideParId?: true
    sessionId?: true
  }

  export type ExportTTAMinAggregateInputType = {
    id?: true
    periodeDebut?: true
    periodeFin?: true
    centreId?: true
    genereParId?: true
    dateGeneration?: true
    nombreLignes?: true
    montantTotal?: true
    fichierUrl?: true
    formatExport?: true
    statut?: true
    dateValidation?: true
    valideParId?: true
    dateTransmission?: true
    numeroBordereau?: true
    commentaires?: true
    sessionId?: true
  }

  export type ExportTTAMaxAggregateInputType = {
    id?: true
    periodeDebut?: true
    periodeFin?: true
    centreId?: true
    genereParId?: true
    dateGeneration?: true
    nombreLignes?: true
    montantTotal?: true
    fichierUrl?: true
    formatExport?: true
    statut?: true
    dateValidation?: true
    valideParId?: true
    dateTransmission?: true
    numeroBordereau?: true
    commentaires?: true
    sessionId?: true
  }

  export type ExportTTACountAggregateInputType = {
    id?: true
    periodeDebut?: true
    periodeFin?: true
    centreId?: true
    genereParId?: true
    dateGeneration?: true
    nombreLignes?: true
    montantTotal?: true
    fichierUrl?: true
    formatExport?: true
    statut?: true
    dateValidation?: true
    valideParId?: true
    dateTransmission?: true
    numeroBordereau?: true
    commentaires?: true
    sessionId?: true
    _all?: true
  }

  export type ExportTTAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportTTA to aggregate.
     */
    where?: ExportTTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportTTAS to fetch.
     */
    orderBy?: ExportTTAOrderByWithRelationInput | ExportTTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExportTTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportTTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportTTAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExportTTAS
    **/
    _count?: true | ExportTTACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExportTTAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExportTTASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExportTTAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExportTTAMaxAggregateInputType
  }

  export type GetExportTTAAggregateType<T extends ExportTTAAggregateArgs> = {
        [P in keyof T & keyof AggregateExportTTA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExportTTA[P]>
      : GetScalarType<T[P], AggregateExportTTA[P]>
  }




  export type ExportTTAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportTTAWhereInput
    orderBy?: ExportTTAOrderByWithAggregationInput | ExportTTAOrderByWithAggregationInput[]
    by: ExportTTAScalarFieldEnum[] | ExportTTAScalarFieldEnum
    having?: ExportTTAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExportTTACountAggregateInputType | true
    _avg?: ExportTTAAvgAggregateInputType
    _sum?: ExportTTASumAggregateInputType
    _min?: ExportTTAMinAggregateInputType
    _max?: ExportTTAMaxAggregateInputType
  }

  export type ExportTTAGroupByOutputType = {
    id: number
    periodeDebut: Date
    periodeFin: Date
    centreId: number | null
    genereParId: number
    dateGeneration: Date
    nombreLignes: number | null
    montantTotal: number | null
    fichierUrl: string | null
    formatExport: $Enums.FormatExport
    statut: $Enums.StatutExport
    dateValidation: Date | null
    valideParId: number | null
    dateTransmission: Date | null
    numeroBordereau: string | null
    commentaires: string | null
    sessionId: number | null
    _count: ExportTTACountAggregateOutputType | null
    _avg: ExportTTAAvgAggregateOutputType | null
    _sum: ExportTTASumAggregateOutputType | null
    _min: ExportTTAMinAggregateOutputType | null
    _max: ExportTTAMaxAggregateOutputType | null
  }

  type GetExportTTAGroupByPayload<T extends ExportTTAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExportTTAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExportTTAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExportTTAGroupByOutputType[P]>
            : GetScalarType<T[P], ExportTTAGroupByOutputType[P]>
        }
      >
    >


  export type ExportTTASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodeDebut?: boolean
    periodeFin?: boolean
    centreId?: boolean
    genereParId?: boolean
    dateGeneration?: boolean
    nombreLignes?: boolean
    montantTotal?: boolean
    fichierUrl?: boolean
    formatExport?: boolean
    statut?: boolean
    dateValidation?: boolean
    valideParId?: boolean
    dateTransmission?: boolean
    numeroBordereau?: boolean
    commentaires?: boolean
    sessionId?: boolean
    centre?: boolean | ExportTTA$centreArgs<ExtArgs>
    generePar?: boolean | PersonnelDefaultArgs<ExtArgs>
    validePar?: boolean | ExportTTA$valideParArgs<ExtArgs>
    session?: boolean | ExportTTA$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["exportTTA"]>

  export type ExportTTASelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodeDebut?: boolean
    periodeFin?: boolean
    centreId?: boolean
    genereParId?: boolean
    dateGeneration?: boolean
    nombreLignes?: boolean
    montantTotal?: boolean
    fichierUrl?: boolean
    formatExport?: boolean
    statut?: boolean
    dateValidation?: boolean
    valideParId?: boolean
    dateTransmission?: boolean
    numeroBordereau?: boolean
    commentaires?: boolean
    sessionId?: boolean
    centre?: boolean | ExportTTA$centreArgs<ExtArgs>
    generePar?: boolean | PersonnelDefaultArgs<ExtArgs>
    validePar?: boolean | ExportTTA$valideParArgs<ExtArgs>
    session?: boolean | ExportTTA$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["exportTTA"]>

  export type ExportTTASelectScalar = {
    id?: boolean
    periodeDebut?: boolean
    periodeFin?: boolean
    centreId?: boolean
    genereParId?: boolean
    dateGeneration?: boolean
    nombreLignes?: boolean
    montantTotal?: boolean
    fichierUrl?: boolean
    formatExport?: boolean
    statut?: boolean
    dateValidation?: boolean
    valideParId?: boolean
    dateTransmission?: boolean
    numeroBordereau?: boolean
    commentaires?: boolean
    sessionId?: boolean
  }

  export type ExportTTAInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    centre?: boolean | ExportTTA$centreArgs<ExtArgs>
    generePar?: boolean | PersonnelDefaultArgs<ExtArgs>
    validePar?: boolean | ExportTTA$valideParArgs<ExtArgs>
    session?: boolean | ExportTTA$sessionArgs<ExtArgs>
  }
  export type ExportTTAIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    centre?: boolean | ExportTTA$centreArgs<ExtArgs>
    generePar?: boolean | PersonnelDefaultArgs<ExtArgs>
    validePar?: boolean | ExportTTA$valideParArgs<ExtArgs>
    session?: boolean | ExportTTA$sessionArgs<ExtArgs>
  }

  export type $ExportTTAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExportTTA"
    objects: {
      centre: Prisma.$CentrePayload<ExtArgs> | null
      generePar: Prisma.$PersonnelPayload<ExtArgs>
      validePar: Prisma.$PersonnelPayload<ExtArgs> | null
      session: Prisma.$SessionFMPAPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      periodeDebut: Date
      periodeFin: Date
      centreId: number | null
      genereParId: number
      dateGeneration: Date
      nombreLignes: number | null
      montantTotal: number | null
      fichierUrl: string | null
      formatExport: $Enums.FormatExport
      statut: $Enums.StatutExport
      dateValidation: Date | null
      valideParId: number | null
      dateTransmission: Date | null
      numeroBordereau: string | null
      commentaires: string | null
      sessionId: number | null
    }, ExtArgs["result"]["exportTTA"]>
    composites: {}
  }

  type ExportTTAGetPayload<S extends boolean | null | undefined | ExportTTADefaultArgs> = $Result.GetResult<Prisma.$ExportTTAPayload, S>

  type ExportTTACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExportTTAFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExportTTACountAggregateInputType | true
    }

  export interface ExportTTADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExportTTA'], meta: { name: 'ExportTTA' } }
    /**
     * Find zero or one ExportTTA that matches the filter.
     * @param {ExportTTAFindUniqueArgs} args - Arguments to find a ExportTTA
     * @example
     * // Get one ExportTTA
     * const exportTTA = await prisma.exportTTA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExportTTAFindUniqueArgs>(args: SelectSubset<T, ExportTTAFindUniqueArgs<ExtArgs>>): Prisma__ExportTTAClient<$Result.GetResult<Prisma.$ExportTTAPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExportTTA that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExportTTAFindUniqueOrThrowArgs} args - Arguments to find a ExportTTA
     * @example
     * // Get one ExportTTA
     * const exportTTA = await prisma.exportTTA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExportTTAFindUniqueOrThrowArgs>(args: SelectSubset<T, ExportTTAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExportTTAClient<$Result.GetResult<Prisma.$ExportTTAPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExportTTA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportTTAFindFirstArgs} args - Arguments to find a ExportTTA
     * @example
     * // Get one ExportTTA
     * const exportTTA = await prisma.exportTTA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExportTTAFindFirstArgs>(args?: SelectSubset<T, ExportTTAFindFirstArgs<ExtArgs>>): Prisma__ExportTTAClient<$Result.GetResult<Prisma.$ExportTTAPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExportTTA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportTTAFindFirstOrThrowArgs} args - Arguments to find a ExportTTA
     * @example
     * // Get one ExportTTA
     * const exportTTA = await prisma.exportTTA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExportTTAFindFirstOrThrowArgs>(args?: SelectSubset<T, ExportTTAFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExportTTAClient<$Result.GetResult<Prisma.$ExportTTAPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExportTTAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportTTAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExportTTAS
     * const exportTTAS = await prisma.exportTTA.findMany()
     * 
     * // Get first 10 ExportTTAS
     * const exportTTAS = await prisma.exportTTA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exportTTAWithIdOnly = await prisma.exportTTA.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExportTTAFindManyArgs>(args?: SelectSubset<T, ExportTTAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportTTAPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExportTTA.
     * @param {ExportTTACreateArgs} args - Arguments to create a ExportTTA.
     * @example
     * // Create one ExportTTA
     * const ExportTTA = await prisma.exportTTA.create({
     *   data: {
     *     // ... data to create a ExportTTA
     *   }
     * })
     * 
     */
    create<T extends ExportTTACreateArgs>(args: SelectSubset<T, ExportTTACreateArgs<ExtArgs>>): Prisma__ExportTTAClient<$Result.GetResult<Prisma.$ExportTTAPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExportTTAS.
     * @param {ExportTTACreateManyArgs} args - Arguments to create many ExportTTAS.
     * @example
     * // Create many ExportTTAS
     * const exportTTA = await prisma.exportTTA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExportTTACreateManyArgs>(args?: SelectSubset<T, ExportTTACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExportTTAS and returns the data saved in the database.
     * @param {ExportTTACreateManyAndReturnArgs} args - Arguments to create many ExportTTAS.
     * @example
     * // Create many ExportTTAS
     * const exportTTA = await prisma.exportTTA.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExportTTAS and only return the `id`
     * const exportTTAWithIdOnly = await prisma.exportTTA.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExportTTACreateManyAndReturnArgs>(args?: SelectSubset<T, ExportTTACreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportTTAPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExportTTA.
     * @param {ExportTTADeleteArgs} args - Arguments to delete one ExportTTA.
     * @example
     * // Delete one ExportTTA
     * const ExportTTA = await prisma.exportTTA.delete({
     *   where: {
     *     // ... filter to delete one ExportTTA
     *   }
     * })
     * 
     */
    delete<T extends ExportTTADeleteArgs>(args: SelectSubset<T, ExportTTADeleteArgs<ExtArgs>>): Prisma__ExportTTAClient<$Result.GetResult<Prisma.$ExportTTAPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExportTTA.
     * @param {ExportTTAUpdateArgs} args - Arguments to update one ExportTTA.
     * @example
     * // Update one ExportTTA
     * const exportTTA = await prisma.exportTTA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExportTTAUpdateArgs>(args: SelectSubset<T, ExportTTAUpdateArgs<ExtArgs>>): Prisma__ExportTTAClient<$Result.GetResult<Prisma.$ExportTTAPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExportTTAS.
     * @param {ExportTTADeleteManyArgs} args - Arguments to filter ExportTTAS to delete.
     * @example
     * // Delete a few ExportTTAS
     * const { count } = await prisma.exportTTA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExportTTADeleteManyArgs>(args?: SelectSubset<T, ExportTTADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExportTTAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportTTAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExportTTAS
     * const exportTTA = await prisma.exportTTA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExportTTAUpdateManyArgs>(args: SelectSubset<T, ExportTTAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExportTTA.
     * @param {ExportTTAUpsertArgs} args - Arguments to update or create a ExportTTA.
     * @example
     * // Update or create a ExportTTA
     * const exportTTA = await prisma.exportTTA.upsert({
     *   create: {
     *     // ... data to create a ExportTTA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExportTTA we want to update
     *   }
     * })
     */
    upsert<T extends ExportTTAUpsertArgs>(args: SelectSubset<T, ExportTTAUpsertArgs<ExtArgs>>): Prisma__ExportTTAClient<$Result.GetResult<Prisma.$ExportTTAPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExportTTAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportTTACountArgs} args - Arguments to filter ExportTTAS to count.
     * @example
     * // Count the number of ExportTTAS
     * const count = await prisma.exportTTA.count({
     *   where: {
     *     // ... the filter for the ExportTTAS we want to count
     *   }
     * })
    **/
    count<T extends ExportTTACountArgs>(
      args?: Subset<T, ExportTTACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExportTTACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExportTTA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportTTAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExportTTAAggregateArgs>(args: Subset<T, ExportTTAAggregateArgs>): Prisma.PrismaPromise<GetExportTTAAggregateType<T>>

    /**
     * Group by ExportTTA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportTTAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExportTTAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExportTTAGroupByArgs['orderBy'] }
        : { orderBy?: ExportTTAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExportTTAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExportTTAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExportTTA model
   */
  readonly fields: ExportTTAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExportTTA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExportTTAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    centre<T extends ExportTTA$centreArgs<ExtArgs> = {}>(args?: Subset<T, ExportTTA$centreArgs<ExtArgs>>): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    generePar<T extends PersonnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonnelDefaultArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    validePar<T extends ExportTTA$valideParArgs<ExtArgs> = {}>(args?: Subset<T, ExportTTA$valideParArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    session<T extends ExportTTA$sessionArgs<ExtArgs> = {}>(args?: Subset<T, ExportTTA$sessionArgs<ExtArgs>>): Prisma__SessionFMPAClient<$Result.GetResult<Prisma.$SessionFMPAPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExportTTA model
   */ 
  interface ExportTTAFieldRefs {
    readonly id: FieldRef<"ExportTTA", 'Int'>
    readonly periodeDebut: FieldRef<"ExportTTA", 'DateTime'>
    readonly periodeFin: FieldRef<"ExportTTA", 'DateTime'>
    readonly centreId: FieldRef<"ExportTTA", 'Int'>
    readonly genereParId: FieldRef<"ExportTTA", 'Int'>
    readonly dateGeneration: FieldRef<"ExportTTA", 'DateTime'>
    readonly nombreLignes: FieldRef<"ExportTTA", 'Int'>
    readonly montantTotal: FieldRef<"ExportTTA", 'Float'>
    readonly fichierUrl: FieldRef<"ExportTTA", 'String'>
    readonly formatExport: FieldRef<"ExportTTA", 'FormatExport'>
    readonly statut: FieldRef<"ExportTTA", 'StatutExport'>
    readonly dateValidation: FieldRef<"ExportTTA", 'DateTime'>
    readonly valideParId: FieldRef<"ExportTTA", 'Int'>
    readonly dateTransmission: FieldRef<"ExportTTA", 'DateTime'>
    readonly numeroBordereau: FieldRef<"ExportTTA", 'String'>
    readonly commentaires: FieldRef<"ExportTTA", 'String'>
    readonly sessionId: FieldRef<"ExportTTA", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ExportTTA findUnique
   */
  export type ExportTTAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAInclude<ExtArgs> | null
    /**
     * Filter, which ExportTTA to fetch.
     */
    where: ExportTTAWhereUniqueInput
  }

  /**
   * ExportTTA findUniqueOrThrow
   */
  export type ExportTTAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAInclude<ExtArgs> | null
    /**
     * Filter, which ExportTTA to fetch.
     */
    where: ExportTTAWhereUniqueInput
  }

  /**
   * ExportTTA findFirst
   */
  export type ExportTTAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAInclude<ExtArgs> | null
    /**
     * Filter, which ExportTTA to fetch.
     */
    where?: ExportTTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportTTAS to fetch.
     */
    orderBy?: ExportTTAOrderByWithRelationInput | ExportTTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportTTAS.
     */
    cursor?: ExportTTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportTTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportTTAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportTTAS.
     */
    distinct?: ExportTTAScalarFieldEnum | ExportTTAScalarFieldEnum[]
  }

  /**
   * ExportTTA findFirstOrThrow
   */
  export type ExportTTAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAInclude<ExtArgs> | null
    /**
     * Filter, which ExportTTA to fetch.
     */
    where?: ExportTTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportTTAS to fetch.
     */
    orderBy?: ExportTTAOrderByWithRelationInput | ExportTTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportTTAS.
     */
    cursor?: ExportTTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportTTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportTTAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportTTAS.
     */
    distinct?: ExportTTAScalarFieldEnum | ExportTTAScalarFieldEnum[]
  }

  /**
   * ExportTTA findMany
   */
  export type ExportTTAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAInclude<ExtArgs> | null
    /**
     * Filter, which ExportTTAS to fetch.
     */
    where?: ExportTTAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportTTAS to fetch.
     */
    orderBy?: ExportTTAOrderByWithRelationInput | ExportTTAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExportTTAS.
     */
    cursor?: ExportTTAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportTTAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportTTAS.
     */
    skip?: number
    distinct?: ExportTTAScalarFieldEnum | ExportTTAScalarFieldEnum[]
  }

  /**
   * ExportTTA create
   */
  export type ExportTTACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAInclude<ExtArgs> | null
    /**
     * The data needed to create a ExportTTA.
     */
    data: XOR<ExportTTACreateInput, ExportTTAUncheckedCreateInput>
  }

  /**
   * ExportTTA createMany
   */
  export type ExportTTACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExportTTAS.
     */
    data: ExportTTACreateManyInput | ExportTTACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExportTTA createManyAndReturn
   */
  export type ExportTTACreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExportTTAS.
     */
    data: ExportTTACreateManyInput | ExportTTACreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExportTTA update
   */
  export type ExportTTAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAInclude<ExtArgs> | null
    /**
     * The data needed to update a ExportTTA.
     */
    data: XOR<ExportTTAUpdateInput, ExportTTAUncheckedUpdateInput>
    /**
     * Choose, which ExportTTA to update.
     */
    where: ExportTTAWhereUniqueInput
  }

  /**
   * ExportTTA updateMany
   */
  export type ExportTTAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExportTTAS.
     */
    data: XOR<ExportTTAUpdateManyMutationInput, ExportTTAUncheckedUpdateManyInput>
    /**
     * Filter which ExportTTAS to update
     */
    where?: ExportTTAWhereInput
  }

  /**
   * ExportTTA upsert
   */
  export type ExportTTAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAInclude<ExtArgs> | null
    /**
     * The filter to search for the ExportTTA to update in case it exists.
     */
    where: ExportTTAWhereUniqueInput
    /**
     * In case the ExportTTA found by the `where` argument doesn't exist, create a new ExportTTA with this data.
     */
    create: XOR<ExportTTACreateInput, ExportTTAUncheckedCreateInput>
    /**
     * In case the ExportTTA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExportTTAUpdateInput, ExportTTAUncheckedUpdateInput>
  }

  /**
   * ExportTTA delete
   */
  export type ExportTTADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAInclude<ExtArgs> | null
    /**
     * Filter which ExportTTA to delete.
     */
    where: ExportTTAWhereUniqueInput
  }

  /**
   * ExportTTA deleteMany
   */
  export type ExportTTADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportTTAS to delete
     */
    where?: ExportTTAWhereInput
  }

  /**
   * ExportTTA.centre
   */
  export type ExportTTA$centreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreInclude<ExtArgs> | null
    where?: CentreWhereInput
  }

  /**
   * ExportTTA.validePar
   */
  export type ExportTTA$valideParArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    where?: PersonnelWhereInput
  }

  /**
   * ExportTTA.session
   */
  export type ExportTTA$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionFMPA
     */
    select?: SessionFMPASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionFMPAInclude<ExtArgs> | null
    where?: SessionFMPAWhereInput
  }

  /**
   * ExportTTA without action
   */
  export type ExportTTADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportTTA
     */
    select?: ExportTTASelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExportTTAInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    utilisateurId: number | null
    entiteId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    utilisateurId: number | null
    entiteId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    utilisateurId: number | null
    action: string | null
    entiteType: string | null
    entiteId: number | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    utilisateurId: number | null
    action: string | null
    entiteType: string | null
    entiteId: number | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    utilisateurId: number
    action: number
    entiteType: number
    entiteId: number
    anciennesValeurs: number
    nouvellesValeurs: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    utilisateurId?: true
    entiteId?: true
  }

  export type AuditLogSumAggregateInputType = {
    utilisateurId?: true
    entiteId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    utilisateurId?: true
    action?: true
    entiteType?: true
    entiteId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    utilisateurId?: true
    action?: true
    entiteType?: true
    entiteId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    utilisateurId?: true
    action?: true
    entiteType?: true
    entiteId?: true
    anciennesValeurs?: true
    nouvellesValeurs?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    utilisateurId: number | null
    action: string
    entiteType: string
    entiteId: number | null
    anciennesValeurs: JsonValue | null
    nouvellesValeurs: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    utilisateurId?: boolean
    action?: boolean
    entiteType?: boolean
    entiteId?: boolean
    anciennesValeurs?: boolean
    nouvellesValeurs?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    utilisateur?: boolean | AuditLog$utilisateurArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    utilisateurId?: boolean
    action?: boolean
    entiteType?: boolean
    entiteId?: boolean
    anciennesValeurs?: boolean
    nouvellesValeurs?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    utilisateur?: boolean | AuditLog$utilisateurArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    utilisateurId?: boolean
    action?: boolean
    entiteType?: boolean
    entiteId?: boolean
    anciennesValeurs?: boolean
    nouvellesValeurs?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | AuditLog$utilisateurArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | AuditLog$utilisateurArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      utilisateur: Prisma.$PersonnelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      utilisateurId: number | null
      action: string
      entiteType: string
      entiteId: number | null
      anciennesValeurs: Prisma.JsonValue | null
      nouvellesValeurs: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    utilisateur<T extends AuditLog$utilisateurArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$utilisateurArgs<ExtArgs>>): Prisma__PersonnelClient<$Result.GetResult<Prisma.$PersonnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly utilisateurId: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entiteType: FieldRef<"AuditLog", 'String'>
    readonly entiteId: FieldRef<"AuditLog", 'Int'>
    readonly anciennesValeurs: FieldRef<"AuditLog", 'Json'>
    readonly nouvellesValeurs: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.utilisateur
   */
  export type AuditLog$utilisateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personnel
     */
    select?: PersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonnelInclude<ExtArgs> | null
    where?: PersonnelWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const GradeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    libelle: 'libelle',
    categorie: 'categorie',
    ordreHierarchique: 'ordreHierarchique',
    actif: 'actif'
  };

  export type GradeScalarFieldEnum = (typeof GradeScalarFieldEnum)[keyof typeof GradeScalarFieldEnum]


  export const CentreScalarFieldEnum: {
    id: 'id',
    code: 'code',
    nom: 'nom',
    type: 'type',
    adresse: 'adresse',
    ville: 'ville',
    codePostal: 'codePostal',
    telephone: 'telephone',
    email: 'email',
    actif: 'actif',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CentreScalarFieldEnum = (typeof CentreScalarFieldEnum)[keyof typeof CentreScalarFieldEnum]


  export const PersonnelScalarFieldEnum: {
    id: 'id',
    matricule: 'matricule',
    nom: 'nom',
    prenom: 'prenom',
    dateNaissance: 'dateNaissance',
    sexe: 'sexe',
    email: 'email',
    telephoneMobile: 'telephoneMobile',
    telephoneFixe: 'telephoneFixe',
    adresse: 'adresse',
    ville: 'ville',
    codePostal: 'codePostal',
    centreId: 'centreId',
    gradeId: 'gradeId',
    categorie: 'categorie',
    dateEngagement: 'dateEngagement',
    dateFinEngagement: 'dateFinEngagement',
    statut: 'statut',
    password: 'password',
    refreshToken: 'refreshToken',
    lastLogin: 'lastLogin',
    resetToken: 'resetToken',
    resetTokenExpires: 'resetTokenExpires',
    photoUrl: 'photoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PersonnelScalarFieldEnum = (typeof PersonnelScalarFieldEnum)[keyof typeof PersonnelScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    code: 'code',
    libelle: 'libelle',
    description: 'description',
    permissions: 'permissions',
    actif: 'actif'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PersonnelRoleScalarFieldEnum: {
    personnelId: 'personnelId',
    roleId: 'roleId',
    dateAttribution: 'dateAttribution',
    dateFin: 'dateFin'
  };

  export type PersonnelRoleScalarFieldEnum = (typeof PersonnelRoleScalarFieldEnum)[keyof typeof PersonnelRoleScalarFieldEnum]


  export const TypeCompetenceScalarFieldEnum: {
    id: 'id',
    code: 'code',
    libelle: 'libelle',
    description: 'description',
    dureeValiditeMois: 'dureeValiditeMois',
    actif: 'actif'
  };

  export type TypeCompetenceScalarFieldEnum = (typeof TypeCompetenceScalarFieldEnum)[keyof typeof TypeCompetenceScalarFieldEnum]


  export const PersonnelCompetenceScalarFieldEnum: {
    id: 'id',
    personnelId: 'personnelId',
    typeCompetenceId: 'typeCompetenceId',
    dateObtention: 'dateObtention',
    dateExpiration: 'dateExpiration',
    niveau: 'niveau',
    numeroDiplome: 'numeroDiplome',
    organismeDelivrance: 'organismeDelivrance',
    actif: 'actif',
    createdAt: 'createdAt'
  };

  export type PersonnelCompetenceScalarFieldEnum = (typeof PersonnelCompetenceScalarFieldEnum)[keyof typeof PersonnelCompetenceScalarFieldEnum]


  export const AptitudeMedicaleScalarFieldEnum: {
    id: 'id',
    personnelId: 'personnelId',
    dateVisite: 'dateVisite',
    dateProchaineVisite: 'dateProchaineVisite',
    aptitude: 'aptitude',
    restrictions: 'restrictions',
    medecin: 'medecin',
    commentaires: 'commentaires',
    createdAt: 'createdAt'
  };

  export type AptitudeMedicaleScalarFieldEnum = (typeof AptitudeMedicaleScalarFieldEnum)[keyof typeof AptitudeMedicaleScalarFieldEnum]


  export const TypeFMPAScalarFieldEnum: {
    id: 'id',
    code: 'code',
    libelle: 'libelle',
    dureeHeures: 'dureeHeures',
    obligatoire: 'obligatoire',
    periodiciteMois: 'periodiciteMois',
    description: 'description',
    actif: 'actif'
  };

  export type TypeFMPAScalarFieldEnum = (typeof TypeFMPAScalarFieldEnum)[keyof typeof TypeFMPAScalarFieldEnum]


  export const SessionFMPAScalarFieldEnum: {
    id: 'id',
    typeFMPAId: 'typeFMPAId',
    centreId: 'centreId',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    lieu: 'lieu',
    nombrePlacesMax: 'nombrePlacesMax',
    nombreInscrits: 'nombreInscrits',
    formateurPrincipalId: 'formateurPrincipalId',
    statut: 'statut',
    codeTTA: 'codeTTA',
    tauxHoraire: 'tauxHoraire',
    commentaires: 'commentaires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionFMPAScalarFieldEnum = (typeof SessionFMPAScalarFieldEnum)[keyof typeof SessionFMPAScalarFieldEnum]


  export const SessionFMPAFormateurScalarFieldEnum: {
    sessionId: 'sessionId',
    personnelId: 'personnelId'
  };

  export type SessionFMPAFormateurScalarFieldEnum = (typeof SessionFMPAFormateurScalarFieldEnum)[keyof typeof SessionFMPAFormateurScalarFieldEnum]


  export const InscriptionFMPAScalarFieldEnum: {
    id: 'id',
    sessionFMPAId: 'sessionFMPAId',
    personnelId: 'personnelId',
    dateInscription: 'dateInscription',
    statutInscription: 'statutInscription',
    heureArrivee: 'heureArrivee',
    heureDepart: 'heureDepart',
    signatureElectronique: 'signatureElectronique',
    dateSignature: 'dateSignature',
    noteEvaluation: 'noteEvaluation',
    acquis: 'acquis',
    commentaireFormateur: 'commentaireFormateur',
    heuresValidees: 'heuresValidees',
    montantTTA: 'montantTTA',
    exportePaie: 'exportePaie',
    dateExportPaie: 'dateExportPaie',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InscriptionFMPAScalarFieldEnum = (typeof InscriptionFMPAScalarFieldEnum)[keyof typeof InscriptionFMPAScalarFieldEnum]


  export const SignatureFMPAScalarFieldEnum: {
    id: 'id',
    sessionFMPAId: 'sessionFMPAId',
    personnelId: 'personnelId',
    type: 'type',
    signature: 'signature',
    dateSignature: 'dateSignature'
  };

  export type SignatureFMPAScalarFieldEnum = (typeof SignatureFMPAScalarFieldEnum)[keyof typeof SignatureFMPAScalarFieldEnum]


  export const CategorieMaterielScalarFieldEnum: {
    id: 'id',
    code: 'code',
    libelle: 'libelle',
    description: 'description',
    actif: 'actif'
  };

  export type CategorieMaterielScalarFieldEnum = (typeof CategorieMaterielScalarFieldEnum)[keyof typeof CategorieMaterielScalarFieldEnum]


  export const MaterielScalarFieldEnum: {
    id: 'id',
    categorieId: 'categorieId',
    centreId: 'centreId',
    codeInventaire: 'codeInventaire',
    libelle: 'libelle',
    marque: 'marque',
    modele: 'modele',
    numeroSerie: 'numeroSerie',
    dateAcquisition: 'dateAcquisition',
    dateMiseService: 'dateMiseService',
    dateReforme: 'dateReforme',
    etat: 'etat',
    periodiciteControleJours: 'periodiciteControleJours',
    dateDernierControle: 'dateDernierControle',
    dateProchainControle: 'dateProchainControle',
    localisation: 'localisation',
    responsableId: 'responsableId',
    valeurAchat: 'valeurAchat',
    fournisseur: 'fournisseur',
    numeroMarche: 'numeroMarche',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaterielScalarFieldEnum = (typeof MaterielScalarFieldEnum)[keyof typeof MaterielScalarFieldEnum]


  export const IncidentMaterielScalarFieldEnum: {
    id: 'id',
    materielId: 'materielId',
    signaleParId: 'signaleParId',
    dateIncident: 'dateIncident',
    typeIncident: 'typeIncident',
    gravite: 'gravite',
    description: 'description',
    photosUrls: 'photosUrls',
    statut: 'statut',
    traiteParId: 'traiteParId',
    dateResolution: 'dateResolution',
    actionsCorrectives: 'actionsCorrectives',
    coutReparation: 'coutReparation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IncidentMaterielScalarFieldEnum = (typeof IncidentMaterielScalarFieldEnum)[keyof typeof IncidentMaterielScalarFieldEnum]


  export const EPIScalarFieldEnum: {
    id: 'id',
    personnelId: 'personnelId',
    typeEPI: 'typeEPI',
    taille: 'taille',
    numeroSerie: 'numeroSerie',
    dateAttribution: 'dateAttribution',
    datePeremption: 'datePeremption',
    etat: 'etat',
    dateDernierControle: 'dateDernierControle',
    dateProchainControle: 'dateProchainControle',
    actif: 'actif',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EPIScalarFieldEnum = (typeof EPIScalarFieldEnum)[keyof typeof EPIScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    nom: 'nom',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const ConversationParticipantScalarFieldEnum: {
    conversationId: 'conversationId',
    personnelId: 'personnelId',
    dateAjout: 'dateAjout',
    dateSortie: 'dateSortie',
    role: 'role',
    notificationsActives: 'notificationsActives'
  };

  export type ConversationParticipantScalarFieldEnum = (typeof ConversationParticipantScalarFieldEnum)[keyof typeof ConversationParticipantScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    expediteurId: 'expediteurId',
    contenu: 'contenu',
    typeMessage: 'typeMessage',
    fichierUrl: 'fichierUrl',
    typeInteractif: 'typeInteractif',
    donneesInteractives: 'donneesInteractives',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    deletedAt: 'deletedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MessageLuScalarFieldEnum: {
    messageId: 'messageId',
    personnelId: 'personnelId',
    dateLecture: 'dateLecture'
  };

  export type MessageLuScalarFieldEnum = (typeof MessageLuScalarFieldEnum)[keyof typeof MessageLuScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    destinataireId: 'destinataireId',
    typeNotification: 'typeNotification',
    titre: 'titre',
    message: 'message',
    niveau: 'niveau',
    entiteType: 'entiteType',
    entiteId: 'entiteId',
    donneesSupplementaires: 'donneesSupplementaires',
    lue: 'lue',
    dateLecture: 'dateLecture',
    envoyeePush: 'envoyeePush',
    envoyeeEmail: 'envoyeeEmail',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const EvenementScalarFieldEnum: {
    id: 'id',
    createurId: 'createurId',
    centreId: 'centreId',
    titre: 'titre',
    description: 'description',
    lieu: 'lieu',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    journeeEntiere: 'journeeEntiere',
    typeEvenement: 'typeEvenement',
    visibilite: 'visibilite',
    recurrent: 'recurrent',
    patternRecurrence: 'patternRecurrence',
    couleur: 'couleur',
    rappels: 'rappels',
    annule: 'annule',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EvenementScalarFieldEnum = (typeof EvenementScalarFieldEnum)[keyof typeof EvenementScalarFieldEnum]


  export const EvenementParticipantScalarFieldEnum: {
    evenementId: 'evenementId',
    personnelId: 'personnelId',
    statutInvitation: 'statutInvitation',
    obligatoire: 'obligatoire',
    dateReponse: 'dateReponse',
    commentaire: 'commentaire'
  };

  export type EvenementParticipantScalarFieldEnum = (typeof EvenementParticipantScalarFieldEnum)[keyof typeof EvenementParticipantScalarFieldEnum]


  export const ExportTTAScalarFieldEnum: {
    id: 'id',
    periodeDebut: 'periodeDebut',
    periodeFin: 'periodeFin',
    centreId: 'centreId',
    genereParId: 'genereParId',
    dateGeneration: 'dateGeneration',
    nombreLignes: 'nombreLignes',
    montantTotal: 'montantTotal',
    fichierUrl: 'fichierUrl',
    formatExport: 'formatExport',
    statut: 'statut',
    dateValidation: 'dateValidation',
    valideParId: 'valideParId',
    dateTransmission: 'dateTransmission',
    numeroBordereau: 'numeroBordereau',
    commentaires: 'commentaires',
    sessionId: 'sessionId'
  };

  export type ExportTTAScalarFieldEnum = (typeof ExportTTAScalarFieldEnum)[keyof typeof ExportTTAScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    utilisateurId: 'utilisateurId',
    action: 'action',
    entiteType: 'entiteType',
    entiteId: 'entiteId',
    anciennesValeurs: 'anciennesValeurs',
    nouvellesValeurs: 'nouvellesValeurs',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Categorie'
   */
  export type EnumCategorieFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Categorie'>
    


  /**
   * Reference to a field of type 'Categorie[]'
   */
  export type ListEnumCategorieFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Categorie[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TypeCentre'
   */
  export type EnumTypeCentreFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeCentre'>
    


  /**
   * Reference to a field of type 'TypeCentre[]'
   */
  export type ListEnumTypeCentreFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeCentre[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Sexe'
   */
  export type EnumSexeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexe'>
    


  /**
   * Reference to a field of type 'Sexe[]'
   */
  export type ListEnumSexeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexe[]'>
    


  /**
   * Reference to a field of type 'StatutPersonnel'
   */
  export type EnumStatutPersonnelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutPersonnel'>
    


  /**
   * Reference to a field of type 'StatutPersonnel[]'
   */
  export type ListEnumStatutPersonnelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutPersonnel[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'StatutAptitude'
   */
  export type EnumStatutAptitudeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutAptitude'>
    


  /**
   * Reference to a field of type 'StatutAptitude[]'
   */
  export type ListEnumStatutAptitudeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutAptitude[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'StatutSession'
   */
  export type EnumStatutSessionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutSession'>
    


  /**
   * Reference to a field of type 'StatutSession[]'
   */
  export type ListEnumStatutSessionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutSession[]'>
    


  /**
   * Reference to a field of type 'StatutInscription'
   */
  export type EnumStatutInscriptionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutInscription'>
    


  /**
   * Reference to a field of type 'StatutInscription[]'
   */
  export type ListEnumStatutInscriptionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutInscription[]'>
    


  /**
   * Reference to a field of type 'EtatMateriel'
   */
  export type EnumEtatMaterielFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EtatMateriel'>
    


  /**
   * Reference to a field of type 'EtatMateriel[]'
   */
  export type ListEnumEtatMaterielFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EtatMateriel[]'>
    


  /**
   * Reference to a field of type 'TypeIncident'
   */
  export type EnumTypeIncidentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeIncident'>
    


  /**
   * Reference to a field of type 'TypeIncident[]'
   */
  export type ListEnumTypeIncidentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeIncident[]'>
    


  /**
   * Reference to a field of type 'GraviteIncident'
   */
  export type EnumGraviteIncidentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GraviteIncident'>
    


  /**
   * Reference to a field of type 'GraviteIncident[]'
   */
  export type ListEnumGraviteIncidentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GraviteIncident[]'>
    


  /**
   * Reference to a field of type 'StatutIncident'
   */
  export type EnumStatutIncidentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutIncident'>
    


  /**
   * Reference to a field of type 'StatutIncident[]'
   */
  export type ListEnumStatutIncidentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutIncident[]'>
    


  /**
   * Reference to a field of type 'EtatEPI'
   */
  export type EnumEtatEPIFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EtatEPI'>
    


  /**
   * Reference to a field of type 'EtatEPI[]'
   */
  export type ListEnumEtatEPIFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EtatEPI[]'>
    


  /**
   * Reference to a field of type 'TypeConversation'
   */
  export type EnumTypeConversationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeConversation'>
    


  /**
   * Reference to a field of type 'TypeConversation[]'
   */
  export type ListEnumTypeConversationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeConversation[]'>
    


  /**
   * Reference to a field of type 'RoleConversation'
   */
  export type EnumRoleConversationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleConversation'>
    


  /**
   * Reference to a field of type 'RoleConversation[]'
   */
  export type ListEnumRoleConversationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleConversation[]'>
    


  /**
   * Reference to a field of type 'TypeMessage'
   */
  export type EnumTypeMessageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeMessage'>
    


  /**
   * Reference to a field of type 'TypeMessage[]'
   */
  export type ListEnumTypeMessageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeMessage[]'>
    


  /**
   * Reference to a field of type 'NiveauNotification'
   */
  export type EnumNiveauNotificationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NiveauNotification'>
    


  /**
   * Reference to a field of type 'NiveauNotification[]'
   */
  export type ListEnumNiveauNotificationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NiveauNotification[]'>
    


  /**
   * Reference to a field of type 'VisibiliteEvenement'
   */
  export type EnumVisibiliteEvenementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisibiliteEvenement'>
    


  /**
   * Reference to a field of type 'VisibiliteEvenement[]'
   */
  export type ListEnumVisibiliteEvenementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisibiliteEvenement[]'>
    


  /**
   * Reference to a field of type 'StatutInvitation'
   */
  export type EnumStatutInvitationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutInvitation'>
    


  /**
   * Reference to a field of type 'StatutInvitation[]'
   */
  export type ListEnumStatutInvitationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutInvitation[]'>
    


  /**
   * Reference to a field of type 'FormatExport'
   */
  export type EnumFormatExportFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormatExport'>
    


  /**
   * Reference to a field of type 'FormatExport[]'
   */
  export type ListEnumFormatExportFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormatExport[]'>
    


  /**
   * Reference to a field of type 'StatutExport'
   */
  export type EnumStatutExportFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutExport'>
    


  /**
   * Reference to a field of type 'StatutExport[]'
   */
  export type ListEnumStatutExportFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutExport[]'>
    
  /**
   * Deep Input Types
   */


  export type GradeWhereInput = {
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    id?: IntFilter<"Grade"> | number
    code?: StringFilter<"Grade"> | string
    libelle?: StringFilter<"Grade"> | string
    categorie?: EnumCategorieFilter<"Grade"> | $Enums.Categorie
    ordreHierarchique?: IntFilter<"Grade"> | number
    actif?: BoolFilter<"Grade"> | boolean
    personnels?: PersonnelListRelationFilter
  }

  export type GradeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    categorie?: SortOrder
    ordreHierarchique?: SortOrder
    actif?: SortOrder
    personnels?: PersonnelOrderByRelationAggregateInput
  }

  export type GradeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    libelle?: StringFilter<"Grade"> | string
    categorie?: EnumCategorieFilter<"Grade"> | $Enums.Categorie
    ordreHierarchique?: IntFilter<"Grade"> | number
    actif?: BoolFilter<"Grade"> | boolean
    personnels?: PersonnelListRelationFilter
  }, "id" | "code">

  export type GradeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    categorie?: SortOrder
    ordreHierarchique?: SortOrder
    actif?: SortOrder
    _count?: GradeCountOrderByAggregateInput
    _avg?: GradeAvgOrderByAggregateInput
    _max?: GradeMaxOrderByAggregateInput
    _min?: GradeMinOrderByAggregateInput
    _sum?: GradeSumOrderByAggregateInput
  }

  export type GradeScalarWhereWithAggregatesInput = {
    AND?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    OR?: GradeScalarWhereWithAggregatesInput[]
    NOT?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Grade"> | number
    code?: StringWithAggregatesFilter<"Grade"> | string
    libelle?: StringWithAggregatesFilter<"Grade"> | string
    categorie?: EnumCategorieWithAggregatesFilter<"Grade"> | $Enums.Categorie
    ordreHierarchique?: IntWithAggregatesFilter<"Grade"> | number
    actif?: BoolWithAggregatesFilter<"Grade"> | boolean
  }

  export type CentreWhereInput = {
    AND?: CentreWhereInput | CentreWhereInput[]
    OR?: CentreWhereInput[]
    NOT?: CentreWhereInput | CentreWhereInput[]
    id?: IntFilter<"Centre"> | number
    code?: StringFilter<"Centre"> | string
    nom?: StringFilter<"Centre"> | string
    type?: EnumTypeCentreFilter<"Centre"> | $Enums.TypeCentre
    adresse?: StringNullableFilter<"Centre"> | string | null
    ville?: StringNullableFilter<"Centre"> | string | null
    codePostal?: StringNullableFilter<"Centre"> | string | null
    telephone?: StringNullableFilter<"Centre"> | string | null
    email?: StringNullableFilter<"Centre"> | string | null
    actif?: BoolFilter<"Centre"> | boolean
    createdAt?: DateTimeFilter<"Centre"> | Date | string
    updatedAt?: DateTimeFilter<"Centre"> | Date | string
    personnels?: PersonnelListRelationFilter
    sessions?: SessionFMPAListRelationFilter
    materiels?: MaterielListRelationFilter
    evenements?: EvenementListRelationFilter
    exportsTTA?: ExportTTAListRelationFilter
  }

  export type CentreOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    adresse?: SortOrderInput | SortOrder
    ville?: SortOrderInput | SortOrder
    codePostal?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personnels?: PersonnelOrderByRelationAggregateInput
    sessions?: SessionFMPAOrderByRelationAggregateInput
    materiels?: MaterielOrderByRelationAggregateInput
    evenements?: EvenementOrderByRelationAggregateInput
    exportsTTA?: ExportTTAOrderByRelationAggregateInput
  }

  export type CentreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: CentreWhereInput | CentreWhereInput[]
    OR?: CentreWhereInput[]
    NOT?: CentreWhereInput | CentreWhereInput[]
    nom?: StringFilter<"Centre"> | string
    type?: EnumTypeCentreFilter<"Centre"> | $Enums.TypeCentre
    adresse?: StringNullableFilter<"Centre"> | string | null
    ville?: StringNullableFilter<"Centre"> | string | null
    codePostal?: StringNullableFilter<"Centre"> | string | null
    telephone?: StringNullableFilter<"Centre"> | string | null
    email?: StringNullableFilter<"Centre"> | string | null
    actif?: BoolFilter<"Centre"> | boolean
    createdAt?: DateTimeFilter<"Centre"> | Date | string
    updatedAt?: DateTimeFilter<"Centre"> | Date | string
    personnels?: PersonnelListRelationFilter
    sessions?: SessionFMPAListRelationFilter
    materiels?: MaterielListRelationFilter
    evenements?: EvenementListRelationFilter
    exportsTTA?: ExportTTAListRelationFilter
  }, "id" | "code">

  export type CentreOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    adresse?: SortOrderInput | SortOrder
    ville?: SortOrderInput | SortOrder
    codePostal?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CentreCountOrderByAggregateInput
    _avg?: CentreAvgOrderByAggregateInput
    _max?: CentreMaxOrderByAggregateInput
    _min?: CentreMinOrderByAggregateInput
    _sum?: CentreSumOrderByAggregateInput
  }

  export type CentreScalarWhereWithAggregatesInput = {
    AND?: CentreScalarWhereWithAggregatesInput | CentreScalarWhereWithAggregatesInput[]
    OR?: CentreScalarWhereWithAggregatesInput[]
    NOT?: CentreScalarWhereWithAggregatesInput | CentreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Centre"> | number
    code?: StringWithAggregatesFilter<"Centre"> | string
    nom?: StringWithAggregatesFilter<"Centre"> | string
    type?: EnumTypeCentreWithAggregatesFilter<"Centre"> | $Enums.TypeCentre
    adresse?: StringNullableWithAggregatesFilter<"Centre"> | string | null
    ville?: StringNullableWithAggregatesFilter<"Centre"> | string | null
    codePostal?: StringNullableWithAggregatesFilter<"Centre"> | string | null
    telephone?: StringNullableWithAggregatesFilter<"Centre"> | string | null
    email?: StringNullableWithAggregatesFilter<"Centre"> | string | null
    actif?: BoolWithAggregatesFilter<"Centre"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Centre"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Centre"> | Date | string
  }

  export type PersonnelWhereInput = {
    AND?: PersonnelWhereInput | PersonnelWhereInput[]
    OR?: PersonnelWhereInput[]
    NOT?: PersonnelWhereInput | PersonnelWhereInput[]
    id?: IntFilter<"Personnel"> | number
    matricule?: StringFilter<"Personnel"> | string
    nom?: StringFilter<"Personnel"> | string
    prenom?: StringFilter<"Personnel"> | string
    dateNaissance?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    sexe?: EnumSexeNullableFilter<"Personnel"> | $Enums.Sexe | null
    email?: StringNullableFilter<"Personnel"> | string | null
    telephoneMobile?: StringNullableFilter<"Personnel"> | string | null
    telephoneFixe?: StringNullableFilter<"Personnel"> | string | null
    adresse?: StringNullableFilter<"Personnel"> | string | null
    ville?: StringNullableFilter<"Personnel"> | string | null
    codePostal?: StringNullableFilter<"Personnel"> | string | null
    centreId?: IntNullableFilter<"Personnel"> | number | null
    gradeId?: IntNullableFilter<"Personnel"> | number | null
    categorie?: EnumCategorieFilter<"Personnel"> | $Enums.Categorie
    dateEngagement?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    dateFinEngagement?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    statut?: EnumStatutPersonnelFilter<"Personnel"> | $Enums.StatutPersonnel
    password?: StringFilter<"Personnel"> | string
    refreshToken?: StringNullableFilter<"Personnel"> | string | null
    lastLogin?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    resetToken?: StringNullableFilter<"Personnel"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    photoUrl?: StringNullableFilter<"Personnel"> | string | null
    createdAt?: DateTimeFilter<"Personnel"> | Date | string
    updatedAt?: DateTimeFilter<"Personnel"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    centre?: XOR<CentreNullableRelationFilter, CentreWhereInput> | null
    grade?: XOR<GradeNullableRelationFilter, GradeWhereInput> | null
    personnelRoles?: PersonnelRoleListRelationFilter
    competences?: PersonnelCompetenceListRelationFilter
    aptitudesMedicales?: AptitudeMedicaleListRelationFilter
    inscriptionsFMPA?: InscriptionFMPAListRelationFilter
    sessionsFMPAFormateur?: SessionFMPAListRelationFilter
    sessionsFMPAAdditionnels?: SessionFMPAFormateurListRelationFilter
    signaturesFMPA?: SignatureFMPAListRelationFilter
    epi?: EPIListRelationFilter
    materielsResponsable?: MaterielListRelationFilter
    incidentsSignales?: IncidentMaterielListRelationFilter
    incidentsTraites?: IncidentMaterielListRelationFilter
    conversationsCreees?: ConversationListRelationFilter
    participations?: ConversationParticipantListRelationFilter
    messagesEnvoyes?: MessageListRelationFilter
    messagesLus?: MessageLuListRelationFilter
    notifications?: NotificationListRelationFilter
    evenementsCreees?: EvenementListRelationFilter
    participationsEvenements?: EvenementParticipantListRelationFilter
    exportsTTAGeneres?: ExportTTAListRelationFilter
    exportsTTAValides?: ExportTTAListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type PersonnelOrderByWithRelationInput = {
    id?: SortOrder
    matricule?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrderInput | SortOrder
    sexe?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telephoneMobile?: SortOrderInput | SortOrder
    telephoneFixe?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    ville?: SortOrderInput | SortOrder
    codePostal?: SortOrderInput | SortOrder
    centreId?: SortOrderInput | SortOrder
    gradeId?: SortOrderInput | SortOrder
    categorie?: SortOrder
    dateEngagement?: SortOrderInput | SortOrder
    dateFinEngagement?: SortOrderInput | SortOrder
    statut?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpires?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    centre?: CentreOrderByWithRelationInput
    grade?: GradeOrderByWithRelationInput
    personnelRoles?: PersonnelRoleOrderByRelationAggregateInput
    competences?: PersonnelCompetenceOrderByRelationAggregateInput
    aptitudesMedicales?: AptitudeMedicaleOrderByRelationAggregateInput
    inscriptionsFMPA?: InscriptionFMPAOrderByRelationAggregateInput
    sessionsFMPAFormateur?: SessionFMPAOrderByRelationAggregateInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurOrderByRelationAggregateInput
    signaturesFMPA?: SignatureFMPAOrderByRelationAggregateInput
    epi?: EPIOrderByRelationAggregateInput
    materielsResponsable?: MaterielOrderByRelationAggregateInput
    incidentsSignales?: IncidentMaterielOrderByRelationAggregateInput
    incidentsTraites?: IncidentMaterielOrderByRelationAggregateInput
    conversationsCreees?: ConversationOrderByRelationAggregateInput
    participations?: ConversationParticipantOrderByRelationAggregateInput
    messagesEnvoyes?: MessageOrderByRelationAggregateInput
    messagesLus?: MessageLuOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    evenementsCreees?: EvenementOrderByRelationAggregateInput
    participationsEvenements?: EvenementParticipantOrderByRelationAggregateInput
    exportsTTAGeneres?: ExportTTAOrderByRelationAggregateInput
    exportsTTAValides?: ExportTTAOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type PersonnelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    matricule?: string
    email?: string
    AND?: PersonnelWhereInput | PersonnelWhereInput[]
    OR?: PersonnelWhereInput[]
    NOT?: PersonnelWhereInput | PersonnelWhereInput[]
    nom?: StringFilter<"Personnel"> | string
    prenom?: StringFilter<"Personnel"> | string
    dateNaissance?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    sexe?: EnumSexeNullableFilter<"Personnel"> | $Enums.Sexe | null
    telephoneMobile?: StringNullableFilter<"Personnel"> | string | null
    telephoneFixe?: StringNullableFilter<"Personnel"> | string | null
    adresse?: StringNullableFilter<"Personnel"> | string | null
    ville?: StringNullableFilter<"Personnel"> | string | null
    codePostal?: StringNullableFilter<"Personnel"> | string | null
    centreId?: IntNullableFilter<"Personnel"> | number | null
    gradeId?: IntNullableFilter<"Personnel"> | number | null
    categorie?: EnumCategorieFilter<"Personnel"> | $Enums.Categorie
    dateEngagement?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    dateFinEngagement?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    statut?: EnumStatutPersonnelFilter<"Personnel"> | $Enums.StatutPersonnel
    password?: StringFilter<"Personnel"> | string
    refreshToken?: StringNullableFilter<"Personnel"> | string | null
    lastLogin?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    resetToken?: StringNullableFilter<"Personnel"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    photoUrl?: StringNullableFilter<"Personnel"> | string | null
    createdAt?: DateTimeFilter<"Personnel"> | Date | string
    updatedAt?: DateTimeFilter<"Personnel"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    centre?: XOR<CentreNullableRelationFilter, CentreWhereInput> | null
    grade?: XOR<GradeNullableRelationFilter, GradeWhereInput> | null
    personnelRoles?: PersonnelRoleListRelationFilter
    competences?: PersonnelCompetenceListRelationFilter
    aptitudesMedicales?: AptitudeMedicaleListRelationFilter
    inscriptionsFMPA?: InscriptionFMPAListRelationFilter
    sessionsFMPAFormateur?: SessionFMPAListRelationFilter
    sessionsFMPAAdditionnels?: SessionFMPAFormateurListRelationFilter
    signaturesFMPA?: SignatureFMPAListRelationFilter
    epi?: EPIListRelationFilter
    materielsResponsable?: MaterielListRelationFilter
    incidentsSignales?: IncidentMaterielListRelationFilter
    incidentsTraites?: IncidentMaterielListRelationFilter
    conversationsCreees?: ConversationListRelationFilter
    participations?: ConversationParticipantListRelationFilter
    messagesEnvoyes?: MessageListRelationFilter
    messagesLus?: MessageLuListRelationFilter
    notifications?: NotificationListRelationFilter
    evenementsCreees?: EvenementListRelationFilter
    participationsEvenements?: EvenementParticipantListRelationFilter
    exportsTTAGeneres?: ExportTTAListRelationFilter
    exportsTTAValides?: ExportTTAListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "matricule" | "email">

  export type PersonnelOrderByWithAggregationInput = {
    id?: SortOrder
    matricule?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrderInput | SortOrder
    sexe?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telephoneMobile?: SortOrderInput | SortOrder
    telephoneFixe?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    ville?: SortOrderInput | SortOrder
    codePostal?: SortOrderInput | SortOrder
    centreId?: SortOrderInput | SortOrder
    gradeId?: SortOrderInput | SortOrder
    categorie?: SortOrder
    dateEngagement?: SortOrderInput | SortOrder
    dateFinEngagement?: SortOrderInput | SortOrder
    statut?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpires?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PersonnelCountOrderByAggregateInput
    _avg?: PersonnelAvgOrderByAggregateInput
    _max?: PersonnelMaxOrderByAggregateInput
    _min?: PersonnelMinOrderByAggregateInput
    _sum?: PersonnelSumOrderByAggregateInput
  }

  export type PersonnelScalarWhereWithAggregatesInput = {
    AND?: PersonnelScalarWhereWithAggregatesInput | PersonnelScalarWhereWithAggregatesInput[]
    OR?: PersonnelScalarWhereWithAggregatesInput[]
    NOT?: PersonnelScalarWhereWithAggregatesInput | PersonnelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Personnel"> | number
    matricule?: StringWithAggregatesFilter<"Personnel"> | string
    nom?: StringWithAggregatesFilter<"Personnel"> | string
    prenom?: StringWithAggregatesFilter<"Personnel"> | string
    dateNaissance?: DateTimeNullableWithAggregatesFilter<"Personnel"> | Date | string | null
    sexe?: EnumSexeNullableWithAggregatesFilter<"Personnel"> | $Enums.Sexe | null
    email?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    telephoneMobile?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    telephoneFixe?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    adresse?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    ville?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    codePostal?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    centreId?: IntNullableWithAggregatesFilter<"Personnel"> | number | null
    gradeId?: IntNullableWithAggregatesFilter<"Personnel"> | number | null
    categorie?: EnumCategorieWithAggregatesFilter<"Personnel"> | $Enums.Categorie
    dateEngagement?: DateTimeNullableWithAggregatesFilter<"Personnel"> | Date | string | null
    dateFinEngagement?: DateTimeNullableWithAggregatesFilter<"Personnel"> | Date | string | null
    statut?: EnumStatutPersonnelWithAggregatesFilter<"Personnel"> | $Enums.StatutPersonnel
    password?: StringWithAggregatesFilter<"Personnel"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    lastLogin?: DateTimeNullableWithAggregatesFilter<"Personnel"> | Date | string | null
    resetToken?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    resetTokenExpires?: DateTimeNullableWithAggregatesFilter<"Personnel"> | Date | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"Personnel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Personnel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Personnel"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Personnel"> | Date | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    code?: StringFilter<"Role"> | string
    libelle?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    permissions?: JsonFilter<"Role">
    actif?: BoolFilter<"Role"> | boolean
    personnels?: PersonnelRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    actif?: SortOrder
    personnels?: PersonnelRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    libelle?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    permissions?: JsonFilter<"Role">
    actif?: BoolFilter<"Role"> | boolean
    personnels?: PersonnelRoleListRelationFilter
  }, "id" | "code">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    actif?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    code?: StringWithAggregatesFilter<"Role"> | string
    libelle?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    permissions?: JsonWithAggregatesFilter<"Role">
    actif?: BoolWithAggregatesFilter<"Role"> | boolean
  }

  export type PersonnelRoleWhereInput = {
    AND?: PersonnelRoleWhereInput | PersonnelRoleWhereInput[]
    OR?: PersonnelRoleWhereInput[]
    NOT?: PersonnelRoleWhereInput | PersonnelRoleWhereInput[]
    personnelId?: IntFilter<"PersonnelRole"> | number
    roleId?: IntFilter<"PersonnelRole"> | number
    dateAttribution?: DateTimeFilter<"PersonnelRole"> | Date | string
    dateFin?: DateTimeNullableFilter<"PersonnelRole"> | Date | string | null
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type PersonnelRoleOrderByWithRelationInput = {
    personnelId?: SortOrder
    roleId?: SortOrder
    dateAttribution?: SortOrder
    dateFin?: SortOrderInput | SortOrder
    personnel?: PersonnelOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type PersonnelRoleWhereUniqueInput = Prisma.AtLeast<{
    personnelId_roleId?: PersonnelRolePersonnelIdRoleIdCompoundUniqueInput
    AND?: PersonnelRoleWhereInput | PersonnelRoleWhereInput[]
    OR?: PersonnelRoleWhereInput[]
    NOT?: PersonnelRoleWhereInput | PersonnelRoleWhereInput[]
    personnelId?: IntFilter<"PersonnelRole"> | number
    roleId?: IntFilter<"PersonnelRole"> | number
    dateAttribution?: DateTimeFilter<"PersonnelRole"> | Date | string
    dateFin?: DateTimeNullableFilter<"PersonnelRole"> | Date | string | null
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "personnelId_roleId">

  export type PersonnelRoleOrderByWithAggregationInput = {
    personnelId?: SortOrder
    roleId?: SortOrder
    dateAttribution?: SortOrder
    dateFin?: SortOrderInput | SortOrder
    _count?: PersonnelRoleCountOrderByAggregateInput
    _avg?: PersonnelRoleAvgOrderByAggregateInput
    _max?: PersonnelRoleMaxOrderByAggregateInput
    _min?: PersonnelRoleMinOrderByAggregateInput
    _sum?: PersonnelRoleSumOrderByAggregateInput
  }

  export type PersonnelRoleScalarWhereWithAggregatesInput = {
    AND?: PersonnelRoleScalarWhereWithAggregatesInput | PersonnelRoleScalarWhereWithAggregatesInput[]
    OR?: PersonnelRoleScalarWhereWithAggregatesInput[]
    NOT?: PersonnelRoleScalarWhereWithAggregatesInput | PersonnelRoleScalarWhereWithAggregatesInput[]
    personnelId?: IntWithAggregatesFilter<"PersonnelRole"> | number
    roleId?: IntWithAggregatesFilter<"PersonnelRole"> | number
    dateAttribution?: DateTimeWithAggregatesFilter<"PersonnelRole"> | Date | string
    dateFin?: DateTimeNullableWithAggregatesFilter<"PersonnelRole"> | Date | string | null
  }

  export type TypeCompetenceWhereInput = {
    AND?: TypeCompetenceWhereInput | TypeCompetenceWhereInput[]
    OR?: TypeCompetenceWhereInput[]
    NOT?: TypeCompetenceWhereInput | TypeCompetenceWhereInput[]
    id?: IntFilter<"TypeCompetence"> | number
    code?: StringFilter<"TypeCompetence"> | string
    libelle?: StringFilter<"TypeCompetence"> | string
    description?: StringNullableFilter<"TypeCompetence"> | string | null
    dureeValiditeMois?: IntNullableFilter<"TypeCompetence"> | number | null
    actif?: BoolFilter<"TypeCompetence"> | boolean
    competences?: PersonnelCompetenceListRelationFilter
  }

  export type TypeCompetenceOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrderInput | SortOrder
    dureeValiditeMois?: SortOrderInput | SortOrder
    actif?: SortOrder
    competences?: PersonnelCompetenceOrderByRelationAggregateInput
  }

  export type TypeCompetenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: TypeCompetenceWhereInput | TypeCompetenceWhereInput[]
    OR?: TypeCompetenceWhereInput[]
    NOT?: TypeCompetenceWhereInput | TypeCompetenceWhereInput[]
    libelle?: StringFilter<"TypeCompetence"> | string
    description?: StringNullableFilter<"TypeCompetence"> | string | null
    dureeValiditeMois?: IntNullableFilter<"TypeCompetence"> | number | null
    actif?: BoolFilter<"TypeCompetence"> | boolean
    competences?: PersonnelCompetenceListRelationFilter
  }, "id" | "code">

  export type TypeCompetenceOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrderInput | SortOrder
    dureeValiditeMois?: SortOrderInput | SortOrder
    actif?: SortOrder
    _count?: TypeCompetenceCountOrderByAggregateInput
    _avg?: TypeCompetenceAvgOrderByAggregateInput
    _max?: TypeCompetenceMaxOrderByAggregateInput
    _min?: TypeCompetenceMinOrderByAggregateInput
    _sum?: TypeCompetenceSumOrderByAggregateInput
  }

  export type TypeCompetenceScalarWhereWithAggregatesInput = {
    AND?: TypeCompetenceScalarWhereWithAggregatesInput | TypeCompetenceScalarWhereWithAggregatesInput[]
    OR?: TypeCompetenceScalarWhereWithAggregatesInput[]
    NOT?: TypeCompetenceScalarWhereWithAggregatesInput | TypeCompetenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TypeCompetence"> | number
    code?: StringWithAggregatesFilter<"TypeCompetence"> | string
    libelle?: StringWithAggregatesFilter<"TypeCompetence"> | string
    description?: StringNullableWithAggregatesFilter<"TypeCompetence"> | string | null
    dureeValiditeMois?: IntNullableWithAggregatesFilter<"TypeCompetence"> | number | null
    actif?: BoolWithAggregatesFilter<"TypeCompetence"> | boolean
  }

  export type PersonnelCompetenceWhereInput = {
    AND?: PersonnelCompetenceWhereInput | PersonnelCompetenceWhereInput[]
    OR?: PersonnelCompetenceWhereInput[]
    NOT?: PersonnelCompetenceWhereInput | PersonnelCompetenceWhereInput[]
    id?: IntFilter<"PersonnelCompetence"> | number
    personnelId?: IntFilter<"PersonnelCompetence"> | number
    typeCompetenceId?: IntFilter<"PersonnelCompetence"> | number
    dateObtention?: DateTimeFilter<"PersonnelCompetence"> | Date | string
    dateExpiration?: DateTimeNullableFilter<"PersonnelCompetence"> | Date | string | null
    niveau?: StringNullableFilter<"PersonnelCompetence"> | string | null
    numeroDiplome?: StringNullableFilter<"PersonnelCompetence"> | string | null
    organismeDelivrance?: StringNullableFilter<"PersonnelCompetence"> | string | null
    actif?: BoolFilter<"PersonnelCompetence"> | boolean
    createdAt?: DateTimeFilter<"PersonnelCompetence"> | Date | string
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    typeCompetence?: XOR<TypeCompetenceRelationFilter, TypeCompetenceWhereInput>
  }

  export type PersonnelCompetenceOrderByWithRelationInput = {
    id?: SortOrder
    personnelId?: SortOrder
    typeCompetenceId?: SortOrder
    dateObtention?: SortOrder
    dateExpiration?: SortOrderInput | SortOrder
    niveau?: SortOrderInput | SortOrder
    numeroDiplome?: SortOrderInput | SortOrder
    organismeDelivrance?: SortOrderInput | SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    personnel?: PersonnelOrderByWithRelationInput
    typeCompetence?: TypeCompetenceOrderByWithRelationInput
  }

  export type PersonnelCompetenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    personnelId_typeCompetenceId_dateObtention?: PersonnelCompetencePersonnelIdTypeCompetenceIdDateObtentionCompoundUniqueInput
    AND?: PersonnelCompetenceWhereInput | PersonnelCompetenceWhereInput[]
    OR?: PersonnelCompetenceWhereInput[]
    NOT?: PersonnelCompetenceWhereInput | PersonnelCompetenceWhereInput[]
    personnelId?: IntFilter<"PersonnelCompetence"> | number
    typeCompetenceId?: IntFilter<"PersonnelCompetence"> | number
    dateObtention?: DateTimeFilter<"PersonnelCompetence"> | Date | string
    dateExpiration?: DateTimeNullableFilter<"PersonnelCompetence"> | Date | string | null
    niveau?: StringNullableFilter<"PersonnelCompetence"> | string | null
    numeroDiplome?: StringNullableFilter<"PersonnelCompetence"> | string | null
    organismeDelivrance?: StringNullableFilter<"PersonnelCompetence"> | string | null
    actif?: BoolFilter<"PersonnelCompetence"> | boolean
    createdAt?: DateTimeFilter<"PersonnelCompetence"> | Date | string
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    typeCompetence?: XOR<TypeCompetenceRelationFilter, TypeCompetenceWhereInput>
  }, "id" | "personnelId_typeCompetenceId_dateObtention">

  export type PersonnelCompetenceOrderByWithAggregationInput = {
    id?: SortOrder
    personnelId?: SortOrder
    typeCompetenceId?: SortOrder
    dateObtention?: SortOrder
    dateExpiration?: SortOrderInput | SortOrder
    niveau?: SortOrderInput | SortOrder
    numeroDiplome?: SortOrderInput | SortOrder
    organismeDelivrance?: SortOrderInput | SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    _count?: PersonnelCompetenceCountOrderByAggregateInput
    _avg?: PersonnelCompetenceAvgOrderByAggregateInput
    _max?: PersonnelCompetenceMaxOrderByAggregateInput
    _min?: PersonnelCompetenceMinOrderByAggregateInput
    _sum?: PersonnelCompetenceSumOrderByAggregateInput
  }

  export type PersonnelCompetenceScalarWhereWithAggregatesInput = {
    AND?: PersonnelCompetenceScalarWhereWithAggregatesInput | PersonnelCompetenceScalarWhereWithAggregatesInput[]
    OR?: PersonnelCompetenceScalarWhereWithAggregatesInput[]
    NOT?: PersonnelCompetenceScalarWhereWithAggregatesInput | PersonnelCompetenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PersonnelCompetence"> | number
    personnelId?: IntWithAggregatesFilter<"PersonnelCompetence"> | number
    typeCompetenceId?: IntWithAggregatesFilter<"PersonnelCompetence"> | number
    dateObtention?: DateTimeWithAggregatesFilter<"PersonnelCompetence"> | Date | string
    dateExpiration?: DateTimeNullableWithAggregatesFilter<"PersonnelCompetence"> | Date | string | null
    niveau?: StringNullableWithAggregatesFilter<"PersonnelCompetence"> | string | null
    numeroDiplome?: StringNullableWithAggregatesFilter<"PersonnelCompetence"> | string | null
    organismeDelivrance?: StringNullableWithAggregatesFilter<"PersonnelCompetence"> | string | null
    actif?: BoolWithAggregatesFilter<"PersonnelCompetence"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PersonnelCompetence"> | Date | string
  }

  export type AptitudeMedicaleWhereInput = {
    AND?: AptitudeMedicaleWhereInput | AptitudeMedicaleWhereInput[]
    OR?: AptitudeMedicaleWhereInput[]
    NOT?: AptitudeMedicaleWhereInput | AptitudeMedicaleWhereInput[]
    id?: IntFilter<"AptitudeMedicale"> | number
    personnelId?: IntFilter<"AptitudeMedicale"> | number
    dateVisite?: DateTimeFilter<"AptitudeMedicale"> | Date | string
    dateProchaineVisite?: DateTimeNullableFilter<"AptitudeMedicale"> | Date | string | null
    aptitude?: EnumStatutAptitudeFilter<"AptitudeMedicale"> | $Enums.StatutAptitude
    restrictions?: StringNullableFilter<"AptitudeMedicale"> | string | null
    medecin?: StringNullableFilter<"AptitudeMedicale"> | string | null
    commentaires?: StringNullableFilter<"AptitudeMedicale"> | string | null
    createdAt?: DateTimeFilter<"AptitudeMedicale"> | Date | string
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }

  export type AptitudeMedicaleOrderByWithRelationInput = {
    id?: SortOrder
    personnelId?: SortOrder
    dateVisite?: SortOrder
    dateProchaineVisite?: SortOrderInput | SortOrder
    aptitude?: SortOrder
    restrictions?: SortOrderInput | SortOrder
    medecin?: SortOrderInput | SortOrder
    commentaires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    personnel?: PersonnelOrderByWithRelationInput
  }

  export type AptitudeMedicaleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AptitudeMedicaleWhereInput | AptitudeMedicaleWhereInput[]
    OR?: AptitudeMedicaleWhereInput[]
    NOT?: AptitudeMedicaleWhereInput | AptitudeMedicaleWhereInput[]
    personnelId?: IntFilter<"AptitudeMedicale"> | number
    dateVisite?: DateTimeFilter<"AptitudeMedicale"> | Date | string
    dateProchaineVisite?: DateTimeNullableFilter<"AptitudeMedicale"> | Date | string | null
    aptitude?: EnumStatutAptitudeFilter<"AptitudeMedicale"> | $Enums.StatutAptitude
    restrictions?: StringNullableFilter<"AptitudeMedicale"> | string | null
    medecin?: StringNullableFilter<"AptitudeMedicale"> | string | null
    commentaires?: StringNullableFilter<"AptitudeMedicale"> | string | null
    createdAt?: DateTimeFilter<"AptitudeMedicale"> | Date | string
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }, "id">

  export type AptitudeMedicaleOrderByWithAggregationInput = {
    id?: SortOrder
    personnelId?: SortOrder
    dateVisite?: SortOrder
    dateProchaineVisite?: SortOrderInput | SortOrder
    aptitude?: SortOrder
    restrictions?: SortOrderInput | SortOrder
    medecin?: SortOrderInput | SortOrder
    commentaires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AptitudeMedicaleCountOrderByAggregateInput
    _avg?: AptitudeMedicaleAvgOrderByAggregateInput
    _max?: AptitudeMedicaleMaxOrderByAggregateInput
    _min?: AptitudeMedicaleMinOrderByAggregateInput
    _sum?: AptitudeMedicaleSumOrderByAggregateInput
  }

  export type AptitudeMedicaleScalarWhereWithAggregatesInput = {
    AND?: AptitudeMedicaleScalarWhereWithAggregatesInput | AptitudeMedicaleScalarWhereWithAggregatesInput[]
    OR?: AptitudeMedicaleScalarWhereWithAggregatesInput[]
    NOT?: AptitudeMedicaleScalarWhereWithAggregatesInput | AptitudeMedicaleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AptitudeMedicale"> | number
    personnelId?: IntWithAggregatesFilter<"AptitudeMedicale"> | number
    dateVisite?: DateTimeWithAggregatesFilter<"AptitudeMedicale"> | Date | string
    dateProchaineVisite?: DateTimeNullableWithAggregatesFilter<"AptitudeMedicale"> | Date | string | null
    aptitude?: EnumStatutAptitudeWithAggregatesFilter<"AptitudeMedicale"> | $Enums.StatutAptitude
    restrictions?: StringNullableWithAggregatesFilter<"AptitudeMedicale"> | string | null
    medecin?: StringNullableWithAggregatesFilter<"AptitudeMedicale"> | string | null
    commentaires?: StringNullableWithAggregatesFilter<"AptitudeMedicale"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AptitudeMedicale"> | Date | string
  }

  export type TypeFMPAWhereInput = {
    AND?: TypeFMPAWhereInput | TypeFMPAWhereInput[]
    OR?: TypeFMPAWhereInput[]
    NOT?: TypeFMPAWhereInput | TypeFMPAWhereInput[]
    id?: IntFilter<"TypeFMPA"> | number
    code?: StringFilter<"TypeFMPA"> | string
    libelle?: StringFilter<"TypeFMPA"> | string
    dureeHeures?: FloatFilter<"TypeFMPA"> | number
    obligatoire?: BoolFilter<"TypeFMPA"> | boolean
    periodiciteMois?: IntNullableFilter<"TypeFMPA"> | number | null
    description?: StringNullableFilter<"TypeFMPA"> | string | null
    actif?: BoolFilter<"TypeFMPA"> | boolean
    sessions?: SessionFMPAListRelationFilter
  }

  export type TypeFMPAOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    dureeHeures?: SortOrder
    obligatoire?: SortOrder
    periodiciteMois?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    actif?: SortOrder
    sessions?: SessionFMPAOrderByRelationAggregateInput
  }

  export type TypeFMPAWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: TypeFMPAWhereInput | TypeFMPAWhereInput[]
    OR?: TypeFMPAWhereInput[]
    NOT?: TypeFMPAWhereInput | TypeFMPAWhereInput[]
    libelle?: StringFilter<"TypeFMPA"> | string
    dureeHeures?: FloatFilter<"TypeFMPA"> | number
    obligatoire?: BoolFilter<"TypeFMPA"> | boolean
    periodiciteMois?: IntNullableFilter<"TypeFMPA"> | number | null
    description?: StringNullableFilter<"TypeFMPA"> | string | null
    actif?: BoolFilter<"TypeFMPA"> | boolean
    sessions?: SessionFMPAListRelationFilter
  }, "id" | "code">

  export type TypeFMPAOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    dureeHeures?: SortOrder
    obligatoire?: SortOrder
    periodiciteMois?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    actif?: SortOrder
    _count?: TypeFMPACountOrderByAggregateInput
    _avg?: TypeFMPAAvgOrderByAggregateInput
    _max?: TypeFMPAMaxOrderByAggregateInput
    _min?: TypeFMPAMinOrderByAggregateInput
    _sum?: TypeFMPASumOrderByAggregateInput
  }

  export type TypeFMPAScalarWhereWithAggregatesInput = {
    AND?: TypeFMPAScalarWhereWithAggregatesInput | TypeFMPAScalarWhereWithAggregatesInput[]
    OR?: TypeFMPAScalarWhereWithAggregatesInput[]
    NOT?: TypeFMPAScalarWhereWithAggregatesInput | TypeFMPAScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TypeFMPA"> | number
    code?: StringWithAggregatesFilter<"TypeFMPA"> | string
    libelle?: StringWithAggregatesFilter<"TypeFMPA"> | string
    dureeHeures?: FloatWithAggregatesFilter<"TypeFMPA"> | number
    obligatoire?: BoolWithAggregatesFilter<"TypeFMPA"> | boolean
    periodiciteMois?: IntNullableWithAggregatesFilter<"TypeFMPA"> | number | null
    description?: StringNullableWithAggregatesFilter<"TypeFMPA"> | string | null
    actif?: BoolWithAggregatesFilter<"TypeFMPA"> | boolean
  }

  export type SessionFMPAWhereInput = {
    AND?: SessionFMPAWhereInput | SessionFMPAWhereInput[]
    OR?: SessionFMPAWhereInput[]
    NOT?: SessionFMPAWhereInput | SessionFMPAWhereInput[]
    id?: IntFilter<"SessionFMPA"> | number
    typeFMPAId?: IntFilter<"SessionFMPA"> | number
    centreId?: IntNullableFilter<"SessionFMPA"> | number | null
    dateDebut?: DateTimeFilter<"SessionFMPA"> | Date | string
    dateFin?: DateTimeFilter<"SessionFMPA"> | Date | string
    lieu?: StringNullableFilter<"SessionFMPA"> | string | null
    nombrePlacesMax?: IntNullableFilter<"SessionFMPA"> | number | null
    nombreInscrits?: IntFilter<"SessionFMPA"> | number
    formateurPrincipalId?: IntFilter<"SessionFMPA"> | number
    statut?: EnumStatutSessionFilter<"SessionFMPA"> | $Enums.StatutSession
    codeTTA?: StringNullableFilter<"SessionFMPA"> | string | null
    tauxHoraire?: FloatNullableFilter<"SessionFMPA"> | number | null
    commentaires?: StringNullableFilter<"SessionFMPA"> | string | null
    createdAt?: DateTimeFilter<"SessionFMPA"> | Date | string
    updatedAt?: DateTimeFilter<"SessionFMPA"> | Date | string
    typeFMPA?: XOR<TypeFMPARelationFilter, TypeFMPAWhereInput>
    centre?: XOR<CentreNullableRelationFilter, CentreWhereInput> | null
    formateurPrincipal?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    formateursAdditionnels?: SessionFMPAFormateurListRelationFilter
    inscriptions?: InscriptionFMPAListRelationFilter
    signatures?: SignatureFMPAListRelationFilter
    exportsTTA?: ExportTTAListRelationFilter
  }

  export type SessionFMPAOrderByWithRelationInput = {
    id?: SortOrder
    typeFMPAId?: SortOrder
    centreId?: SortOrderInput | SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    lieu?: SortOrderInput | SortOrder
    nombrePlacesMax?: SortOrderInput | SortOrder
    nombreInscrits?: SortOrder
    formateurPrincipalId?: SortOrder
    statut?: SortOrder
    codeTTA?: SortOrderInput | SortOrder
    tauxHoraire?: SortOrderInput | SortOrder
    commentaires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    typeFMPA?: TypeFMPAOrderByWithRelationInput
    centre?: CentreOrderByWithRelationInput
    formateurPrincipal?: PersonnelOrderByWithRelationInput
    formateursAdditionnels?: SessionFMPAFormateurOrderByRelationAggregateInput
    inscriptions?: InscriptionFMPAOrderByRelationAggregateInput
    signatures?: SignatureFMPAOrderByRelationAggregateInput
    exportsTTA?: ExportTTAOrderByRelationAggregateInput
  }

  export type SessionFMPAWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SessionFMPAWhereInput | SessionFMPAWhereInput[]
    OR?: SessionFMPAWhereInput[]
    NOT?: SessionFMPAWhereInput | SessionFMPAWhereInput[]
    typeFMPAId?: IntFilter<"SessionFMPA"> | number
    centreId?: IntNullableFilter<"SessionFMPA"> | number | null
    dateDebut?: DateTimeFilter<"SessionFMPA"> | Date | string
    dateFin?: DateTimeFilter<"SessionFMPA"> | Date | string
    lieu?: StringNullableFilter<"SessionFMPA"> | string | null
    nombrePlacesMax?: IntNullableFilter<"SessionFMPA"> | number | null
    nombreInscrits?: IntFilter<"SessionFMPA"> | number
    formateurPrincipalId?: IntFilter<"SessionFMPA"> | number
    statut?: EnumStatutSessionFilter<"SessionFMPA"> | $Enums.StatutSession
    codeTTA?: StringNullableFilter<"SessionFMPA"> | string | null
    tauxHoraire?: FloatNullableFilter<"SessionFMPA"> | number | null
    commentaires?: StringNullableFilter<"SessionFMPA"> | string | null
    createdAt?: DateTimeFilter<"SessionFMPA"> | Date | string
    updatedAt?: DateTimeFilter<"SessionFMPA"> | Date | string
    typeFMPA?: XOR<TypeFMPARelationFilter, TypeFMPAWhereInput>
    centre?: XOR<CentreNullableRelationFilter, CentreWhereInput> | null
    formateurPrincipal?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    formateursAdditionnels?: SessionFMPAFormateurListRelationFilter
    inscriptions?: InscriptionFMPAListRelationFilter
    signatures?: SignatureFMPAListRelationFilter
    exportsTTA?: ExportTTAListRelationFilter
  }, "id">

  export type SessionFMPAOrderByWithAggregationInput = {
    id?: SortOrder
    typeFMPAId?: SortOrder
    centreId?: SortOrderInput | SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    lieu?: SortOrderInput | SortOrder
    nombrePlacesMax?: SortOrderInput | SortOrder
    nombreInscrits?: SortOrder
    formateurPrincipalId?: SortOrder
    statut?: SortOrder
    codeTTA?: SortOrderInput | SortOrder
    tauxHoraire?: SortOrderInput | SortOrder
    commentaires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionFMPACountOrderByAggregateInput
    _avg?: SessionFMPAAvgOrderByAggregateInput
    _max?: SessionFMPAMaxOrderByAggregateInput
    _min?: SessionFMPAMinOrderByAggregateInput
    _sum?: SessionFMPASumOrderByAggregateInput
  }

  export type SessionFMPAScalarWhereWithAggregatesInput = {
    AND?: SessionFMPAScalarWhereWithAggregatesInput | SessionFMPAScalarWhereWithAggregatesInput[]
    OR?: SessionFMPAScalarWhereWithAggregatesInput[]
    NOT?: SessionFMPAScalarWhereWithAggregatesInput | SessionFMPAScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SessionFMPA"> | number
    typeFMPAId?: IntWithAggregatesFilter<"SessionFMPA"> | number
    centreId?: IntNullableWithAggregatesFilter<"SessionFMPA"> | number | null
    dateDebut?: DateTimeWithAggregatesFilter<"SessionFMPA"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"SessionFMPA"> | Date | string
    lieu?: StringNullableWithAggregatesFilter<"SessionFMPA"> | string | null
    nombrePlacesMax?: IntNullableWithAggregatesFilter<"SessionFMPA"> | number | null
    nombreInscrits?: IntWithAggregatesFilter<"SessionFMPA"> | number
    formateurPrincipalId?: IntWithAggregatesFilter<"SessionFMPA"> | number
    statut?: EnumStatutSessionWithAggregatesFilter<"SessionFMPA"> | $Enums.StatutSession
    codeTTA?: StringNullableWithAggregatesFilter<"SessionFMPA"> | string | null
    tauxHoraire?: FloatNullableWithAggregatesFilter<"SessionFMPA"> | number | null
    commentaires?: StringNullableWithAggregatesFilter<"SessionFMPA"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SessionFMPA"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SessionFMPA"> | Date | string
  }

  export type SessionFMPAFormateurWhereInput = {
    AND?: SessionFMPAFormateurWhereInput | SessionFMPAFormateurWhereInput[]
    OR?: SessionFMPAFormateurWhereInput[]
    NOT?: SessionFMPAFormateurWhereInput | SessionFMPAFormateurWhereInput[]
    sessionId?: IntFilter<"SessionFMPAFormateur"> | number
    personnelId?: IntFilter<"SessionFMPAFormateur"> | number
    session?: XOR<SessionFMPARelationFilter, SessionFMPAWhereInput>
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }

  export type SessionFMPAFormateurOrderByWithRelationInput = {
    sessionId?: SortOrder
    personnelId?: SortOrder
    session?: SessionFMPAOrderByWithRelationInput
    personnel?: PersonnelOrderByWithRelationInput
  }

  export type SessionFMPAFormateurWhereUniqueInput = Prisma.AtLeast<{
    sessionId_personnelId?: SessionFMPAFormateurSessionIdPersonnelIdCompoundUniqueInput
    AND?: SessionFMPAFormateurWhereInput | SessionFMPAFormateurWhereInput[]
    OR?: SessionFMPAFormateurWhereInput[]
    NOT?: SessionFMPAFormateurWhereInput | SessionFMPAFormateurWhereInput[]
    sessionId?: IntFilter<"SessionFMPAFormateur"> | number
    personnelId?: IntFilter<"SessionFMPAFormateur"> | number
    session?: XOR<SessionFMPARelationFilter, SessionFMPAWhereInput>
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }, "sessionId_personnelId">

  export type SessionFMPAFormateurOrderByWithAggregationInput = {
    sessionId?: SortOrder
    personnelId?: SortOrder
    _count?: SessionFMPAFormateurCountOrderByAggregateInput
    _avg?: SessionFMPAFormateurAvgOrderByAggregateInput
    _max?: SessionFMPAFormateurMaxOrderByAggregateInput
    _min?: SessionFMPAFormateurMinOrderByAggregateInput
    _sum?: SessionFMPAFormateurSumOrderByAggregateInput
  }

  export type SessionFMPAFormateurScalarWhereWithAggregatesInput = {
    AND?: SessionFMPAFormateurScalarWhereWithAggregatesInput | SessionFMPAFormateurScalarWhereWithAggregatesInput[]
    OR?: SessionFMPAFormateurScalarWhereWithAggregatesInput[]
    NOT?: SessionFMPAFormateurScalarWhereWithAggregatesInput | SessionFMPAFormateurScalarWhereWithAggregatesInput[]
    sessionId?: IntWithAggregatesFilter<"SessionFMPAFormateur"> | number
    personnelId?: IntWithAggregatesFilter<"SessionFMPAFormateur"> | number
  }

  export type InscriptionFMPAWhereInput = {
    AND?: InscriptionFMPAWhereInput | InscriptionFMPAWhereInput[]
    OR?: InscriptionFMPAWhereInput[]
    NOT?: InscriptionFMPAWhereInput | InscriptionFMPAWhereInput[]
    id?: IntFilter<"InscriptionFMPA"> | number
    sessionFMPAId?: IntFilter<"InscriptionFMPA"> | number
    personnelId?: IntFilter<"InscriptionFMPA"> | number
    dateInscription?: DateTimeFilter<"InscriptionFMPA"> | Date | string
    statutInscription?: EnumStatutInscriptionFilter<"InscriptionFMPA"> | $Enums.StatutInscription
    heureArrivee?: DateTimeNullableFilter<"InscriptionFMPA"> | Date | string | null
    heureDepart?: DateTimeNullableFilter<"InscriptionFMPA"> | Date | string | null
    signatureElectronique?: StringNullableFilter<"InscriptionFMPA"> | string | null
    dateSignature?: DateTimeNullableFilter<"InscriptionFMPA"> | Date | string | null
    noteEvaluation?: FloatNullableFilter<"InscriptionFMPA"> | number | null
    acquis?: BoolNullableFilter<"InscriptionFMPA"> | boolean | null
    commentaireFormateur?: StringNullableFilter<"InscriptionFMPA"> | string | null
    heuresValidees?: FloatNullableFilter<"InscriptionFMPA"> | number | null
    montantTTA?: FloatNullableFilter<"InscriptionFMPA"> | number | null
    exportePaie?: BoolFilter<"InscriptionFMPA"> | boolean
    dateExportPaie?: DateTimeNullableFilter<"InscriptionFMPA"> | Date | string | null
    createdAt?: DateTimeFilter<"InscriptionFMPA"> | Date | string
    updatedAt?: DateTimeFilter<"InscriptionFMPA"> | Date | string
    session?: XOR<SessionFMPARelationFilter, SessionFMPAWhereInput>
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }

  export type InscriptionFMPAOrderByWithRelationInput = {
    id?: SortOrder
    sessionFMPAId?: SortOrder
    personnelId?: SortOrder
    dateInscription?: SortOrder
    statutInscription?: SortOrder
    heureArrivee?: SortOrderInput | SortOrder
    heureDepart?: SortOrderInput | SortOrder
    signatureElectronique?: SortOrderInput | SortOrder
    dateSignature?: SortOrderInput | SortOrder
    noteEvaluation?: SortOrderInput | SortOrder
    acquis?: SortOrderInput | SortOrder
    commentaireFormateur?: SortOrderInput | SortOrder
    heuresValidees?: SortOrderInput | SortOrder
    montantTTA?: SortOrderInput | SortOrder
    exportePaie?: SortOrder
    dateExportPaie?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: SessionFMPAOrderByWithRelationInput
    personnel?: PersonnelOrderByWithRelationInput
  }

  export type InscriptionFMPAWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionFMPAId_personnelId?: InscriptionFMPASessionFMPAIdPersonnelIdCompoundUniqueInput
    AND?: InscriptionFMPAWhereInput | InscriptionFMPAWhereInput[]
    OR?: InscriptionFMPAWhereInput[]
    NOT?: InscriptionFMPAWhereInput | InscriptionFMPAWhereInput[]
    sessionFMPAId?: IntFilter<"InscriptionFMPA"> | number
    personnelId?: IntFilter<"InscriptionFMPA"> | number
    dateInscription?: DateTimeFilter<"InscriptionFMPA"> | Date | string
    statutInscription?: EnumStatutInscriptionFilter<"InscriptionFMPA"> | $Enums.StatutInscription
    heureArrivee?: DateTimeNullableFilter<"InscriptionFMPA"> | Date | string | null
    heureDepart?: DateTimeNullableFilter<"InscriptionFMPA"> | Date | string | null
    signatureElectronique?: StringNullableFilter<"InscriptionFMPA"> | string | null
    dateSignature?: DateTimeNullableFilter<"InscriptionFMPA"> | Date | string | null
    noteEvaluation?: FloatNullableFilter<"InscriptionFMPA"> | number | null
    acquis?: BoolNullableFilter<"InscriptionFMPA"> | boolean | null
    commentaireFormateur?: StringNullableFilter<"InscriptionFMPA"> | string | null
    heuresValidees?: FloatNullableFilter<"InscriptionFMPA"> | number | null
    montantTTA?: FloatNullableFilter<"InscriptionFMPA"> | number | null
    exportePaie?: BoolFilter<"InscriptionFMPA"> | boolean
    dateExportPaie?: DateTimeNullableFilter<"InscriptionFMPA"> | Date | string | null
    createdAt?: DateTimeFilter<"InscriptionFMPA"> | Date | string
    updatedAt?: DateTimeFilter<"InscriptionFMPA"> | Date | string
    session?: XOR<SessionFMPARelationFilter, SessionFMPAWhereInput>
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }, "id" | "sessionFMPAId_personnelId">

  export type InscriptionFMPAOrderByWithAggregationInput = {
    id?: SortOrder
    sessionFMPAId?: SortOrder
    personnelId?: SortOrder
    dateInscription?: SortOrder
    statutInscription?: SortOrder
    heureArrivee?: SortOrderInput | SortOrder
    heureDepart?: SortOrderInput | SortOrder
    signatureElectronique?: SortOrderInput | SortOrder
    dateSignature?: SortOrderInput | SortOrder
    noteEvaluation?: SortOrderInput | SortOrder
    acquis?: SortOrderInput | SortOrder
    commentaireFormateur?: SortOrderInput | SortOrder
    heuresValidees?: SortOrderInput | SortOrder
    montantTTA?: SortOrderInput | SortOrder
    exportePaie?: SortOrder
    dateExportPaie?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InscriptionFMPACountOrderByAggregateInput
    _avg?: InscriptionFMPAAvgOrderByAggregateInput
    _max?: InscriptionFMPAMaxOrderByAggregateInput
    _min?: InscriptionFMPAMinOrderByAggregateInput
    _sum?: InscriptionFMPASumOrderByAggregateInput
  }

  export type InscriptionFMPAScalarWhereWithAggregatesInput = {
    AND?: InscriptionFMPAScalarWhereWithAggregatesInput | InscriptionFMPAScalarWhereWithAggregatesInput[]
    OR?: InscriptionFMPAScalarWhereWithAggregatesInput[]
    NOT?: InscriptionFMPAScalarWhereWithAggregatesInput | InscriptionFMPAScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InscriptionFMPA"> | number
    sessionFMPAId?: IntWithAggregatesFilter<"InscriptionFMPA"> | number
    personnelId?: IntWithAggregatesFilter<"InscriptionFMPA"> | number
    dateInscription?: DateTimeWithAggregatesFilter<"InscriptionFMPA"> | Date | string
    statutInscription?: EnumStatutInscriptionWithAggregatesFilter<"InscriptionFMPA"> | $Enums.StatutInscription
    heureArrivee?: DateTimeNullableWithAggregatesFilter<"InscriptionFMPA"> | Date | string | null
    heureDepart?: DateTimeNullableWithAggregatesFilter<"InscriptionFMPA"> | Date | string | null
    signatureElectronique?: StringNullableWithAggregatesFilter<"InscriptionFMPA"> | string | null
    dateSignature?: DateTimeNullableWithAggregatesFilter<"InscriptionFMPA"> | Date | string | null
    noteEvaluation?: FloatNullableWithAggregatesFilter<"InscriptionFMPA"> | number | null
    acquis?: BoolNullableWithAggregatesFilter<"InscriptionFMPA"> | boolean | null
    commentaireFormateur?: StringNullableWithAggregatesFilter<"InscriptionFMPA"> | string | null
    heuresValidees?: FloatNullableWithAggregatesFilter<"InscriptionFMPA"> | number | null
    montantTTA?: FloatNullableWithAggregatesFilter<"InscriptionFMPA"> | number | null
    exportePaie?: BoolWithAggregatesFilter<"InscriptionFMPA"> | boolean
    dateExportPaie?: DateTimeNullableWithAggregatesFilter<"InscriptionFMPA"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InscriptionFMPA"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InscriptionFMPA"> | Date | string
  }

  export type SignatureFMPAWhereInput = {
    AND?: SignatureFMPAWhereInput | SignatureFMPAWhereInput[]
    OR?: SignatureFMPAWhereInput[]
    NOT?: SignatureFMPAWhereInput | SignatureFMPAWhereInput[]
    id?: StringFilter<"SignatureFMPA"> | string
    sessionFMPAId?: IntFilter<"SignatureFMPA"> | number
    personnelId?: IntFilter<"SignatureFMPA"> | number
    type?: StringFilter<"SignatureFMPA"> | string
    signature?: StringFilter<"SignatureFMPA"> | string
    dateSignature?: DateTimeFilter<"SignatureFMPA"> | Date | string
    session?: XOR<SessionFMPARelationFilter, SessionFMPAWhereInput>
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }

  export type SignatureFMPAOrderByWithRelationInput = {
    id?: SortOrder
    sessionFMPAId?: SortOrder
    personnelId?: SortOrder
    type?: SortOrder
    signature?: SortOrder
    dateSignature?: SortOrder
    session?: SessionFMPAOrderByWithRelationInput
    personnel?: PersonnelOrderByWithRelationInput
  }

  export type SignatureFMPAWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SignatureFMPAWhereInput | SignatureFMPAWhereInput[]
    OR?: SignatureFMPAWhereInput[]
    NOT?: SignatureFMPAWhereInput | SignatureFMPAWhereInput[]
    sessionFMPAId?: IntFilter<"SignatureFMPA"> | number
    personnelId?: IntFilter<"SignatureFMPA"> | number
    type?: StringFilter<"SignatureFMPA"> | string
    signature?: StringFilter<"SignatureFMPA"> | string
    dateSignature?: DateTimeFilter<"SignatureFMPA"> | Date | string
    session?: XOR<SessionFMPARelationFilter, SessionFMPAWhereInput>
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }, "id">

  export type SignatureFMPAOrderByWithAggregationInput = {
    id?: SortOrder
    sessionFMPAId?: SortOrder
    personnelId?: SortOrder
    type?: SortOrder
    signature?: SortOrder
    dateSignature?: SortOrder
    _count?: SignatureFMPACountOrderByAggregateInput
    _avg?: SignatureFMPAAvgOrderByAggregateInput
    _max?: SignatureFMPAMaxOrderByAggregateInput
    _min?: SignatureFMPAMinOrderByAggregateInput
    _sum?: SignatureFMPASumOrderByAggregateInput
  }

  export type SignatureFMPAScalarWhereWithAggregatesInput = {
    AND?: SignatureFMPAScalarWhereWithAggregatesInput | SignatureFMPAScalarWhereWithAggregatesInput[]
    OR?: SignatureFMPAScalarWhereWithAggregatesInput[]
    NOT?: SignatureFMPAScalarWhereWithAggregatesInput | SignatureFMPAScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SignatureFMPA"> | string
    sessionFMPAId?: IntWithAggregatesFilter<"SignatureFMPA"> | number
    personnelId?: IntWithAggregatesFilter<"SignatureFMPA"> | number
    type?: StringWithAggregatesFilter<"SignatureFMPA"> | string
    signature?: StringWithAggregatesFilter<"SignatureFMPA"> | string
    dateSignature?: DateTimeWithAggregatesFilter<"SignatureFMPA"> | Date | string
  }

  export type CategorieMaterielWhereInput = {
    AND?: CategorieMaterielWhereInput | CategorieMaterielWhereInput[]
    OR?: CategorieMaterielWhereInput[]
    NOT?: CategorieMaterielWhereInput | CategorieMaterielWhereInput[]
    id?: IntFilter<"CategorieMateriel"> | number
    code?: StringFilter<"CategorieMateriel"> | string
    libelle?: StringFilter<"CategorieMateriel"> | string
    description?: StringNullableFilter<"CategorieMateriel"> | string | null
    actif?: BoolFilter<"CategorieMateriel"> | boolean
    materiels?: MaterielListRelationFilter
  }

  export type CategorieMaterielOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrderInput | SortOrder
    actif?: SortOrder
    materiels?: MaterielOrderByRelationAggregateInput
  }

  export type CategorieMaterielWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: CategorieMaterielWhereInput | CategorieMaterielWhereInput[]
    OR?: CategorieMaterielWhereInput[]
    NOT?: CategorieMaterielWhereInput | CategorieMaterielWhereInput[]
    libelle?: StringFilter<"CategorieMateriel"> | string
    description?: StringNullableFilter<"CategorieMateriel"> | string | null
    actif?: BoolFilter<"CategorieMateriel"> | boolean
    materiels?: MaterielListRelationFilter
  }, "id" | "code">

  export type CategorieMaterielOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrderInput | SortOrder
    actif?: SortOrder
    _count?: CategorieMaterielCountOrderByAggregateInput
    _avg?: CategorieMaterielAvgOrderByAggregateInput
    _max?: CategorieMaterielMaxOrderByAggregateInput
    _min?: CategorieMaterielMinOrderByAggregateInput
    _sum?: CategorieMaterielSumOrderByAggregateInput
  }

  export type CategorieMaterielScalarWhereWithAggregatesInput = {
    AND?: CategorieMaterielScalarWhereWithAggregatesInput | CategorieMaterielScalarWhereWithAggregatesInput[]
    OR?: CategorieMaterielScalarWhereWithAggregatesInput[]
    NOT?: CategorieMaterielScalarWhereWithAggregatesInput | CategorieMaterielScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CategorieMateriel"> | number
    code?: StringWithAggregatesFilter<"CategorieMateriel"> | string
    libelle?: StringWithAggregatesFilter<"CategorieMateriel"> | string
    description?: StringNullableWithAggregatesFilter<"CategorieMateriel"> | string | null
    actif?: BoolWithAggregatesFilter<"CategorieMateriel"> | boolean
  }

  export type MaterielWhereInput = {
    AND?: MaterielWhereInput | MaterielWhereInput[]
    OR?: MaterielWhereInput[]
    NOT?: MaterielWhereInput | MaterielWhereInput[]
    id?: IntFilter<"Materiel"> | number
    categorieId?: IntFilter<"Materiel"> | number
    centreId?: IntNullableFilter<"Materiel"> | number | null
    codeInventaire?: StringFilter<"Materiel"> | string
    libelle?: StringFilter<"Materiel"> | string
    marque?: StringNullableFilter<"Materiel"> | string | null
    modele?: StringNullableFilter<"Materiel"> | string | null
    numeroSerie?: StringNullableFilter<"Materiel"> | string | null
    dateAcquisition?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    dateMiseService?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    dateReforme?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    etat?: EnumEtatMaterielFilter<"Materiel"> | $Enums.EtatMateriel
    periodiciteControleJours?: IntNullableFilter<"Materiel"> | number | null
    dateDernierControle?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    dateProchainControle?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    localisation?: StringNullableFilter<"Materiel"> | string | null
    responsableId?: IntNullableFilter<"Materiel"> | number | null
    valeurAchat?: FloatNullableFilter<"Materiel"> | number | null
    fournisseur?: StringNullableFilter<"Materiel"> | string | null
    numeroMarche?: StringNullableFilter<"Materiel"> | string | null
    createdAt?: DateTimeFilter<"Materiel"> | Date | string
    updatedAt?: DateTimeFilter<"Materiel"> | Date | string
    categorie?: XOR<CategorieMaterielRelationFilter, CategorieMaterielWhereInput>
    centre?: XOR<CentreNullableRelationFilter, CentreWhereInput> | null
    responsable?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
    incidents?: IncidentMaterielListRelationFilter
  }

  export type MaterielOrderByWithRelationInput = {
    id?: SortOrder
    categorieId?: SortOrder
    centreId?: SortOrderInput | SortOrder
    codeInventaire?: SortOrder
    libelle?: SortOrder
    marque?: SortOrderInput | SortOrder
    modele?: SortOrderInput | SortOrder
    numeroSerie?: SortOrderInput | SortOrder
    dateAcquisition?: SortOrderInput | SortOrder
    dateMiseService?: SortOrderInput | SortOrder
    dateReforme?: SortOrderInput | SortOrder
    etat?: SortOrder
    periodiciteControleJours?: SortOrderInput | SortOrder
    dateDernierControle?: SortOrderInput | SortOrder
    dateProchainControle?: SortOrderInput | SortOrder
    localisation?: SortOrderInput | SortOrder
    responsableId?: SortOrderInput | SortOrder
    valeurAchat?: SortOrderInput | SortOrder
    fournisseur?: SortOrderInput | SortOrder
    numeroMarche?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categorie?: CategorieMaterielOrderByWithRelationInput
    centre?: CentreOrderByWithRelationInput
    responsable?: PersonnelOrderByWithRelationInput
    incidents?: IncidentMaterielOrderByRelationAggregateInput
  }

  export type MaterielWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codeInventaire?: string
    AND?: MaterielWhereInput | MaterielWhereInput[]
    OR?: MaterielWhereInput[]
    NOT?: MaterielWhereInput | MaterielWhereInput[]
    categorieId?: IntFilter<"Materiel"> | number
    centreId?: IntNullableFilter<"Materiel"> | number | null
    libelle?: StringFilter<"Materiel"> | string
    marque?: StringNullableFilter<"Materiel"> | string | null
    modele?: StringNullableFilter<"Materiel"> | string | null
    numeroSerie?: StringNullableFilter<"Materiel"> | string | null
    dateAcquisition?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    dateMiseService?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    dateReforme?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    etat?: EnumEtatMaterielFilter<"Materiel"> | $Enums.EtatMateriel
    periodiciteControleJours?: IntNullableFilter<"Materiel"> | number | null
    dateDernierControle?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    dateProchainControle?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    localisation?: StringNullableFilter<"Materiel"> | string | null
    responsableId?: IntNullableFilter<"Materiel"> | number | null
    valeurAchat?: FloatNullableFilter<"Materiel"> | number | null
    fournisseur?: StringNullableFilter<"Materiel"> | string | null
    numeroMarche?: StringNullableFilter<"Materiel"> | string | null
    createdAt?: DateTimeFilter<"Materiel"> | Date | string
    updatedAt?: DateTimeFilter<"Materiel"> | Date | string
    categorie?: XOR<CategorieMaterielRelationFilter, CategorieMaterielWhereInput>
    centre?: XOR<CentreNullableRelationFilter, CentreWhereInput> | null
    responsable?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
    incidents?: IncidentMaterielListRelationFilter
  }, "id" | "codeInventaire">

  export type MaterielOrderByWithAggregationInput = {
    id?: SortOrder
    categorieId?: SortOrder
    centreId?: SortOrderInput | SortOrder
    codeInventaire?: SortOrder
    libelle?: SortOrder
    marque?: SortOrderInput | SortOrder
    modele?: SortOrderInput | SortOrder
    numeroSerie?: SortOrderInput | SortOrder
    dateAcquisition?: SortOrderInput | SortOrder
    dateMiseService?: SortOrderInput | SortOrder
    dateReforme?: SortOrderInput | SortOrder
    etat?: SortOrder
    periodiciteControleJours?: SortOrderInput | SortOrder
    dateDernierControle?: SortOrderInput | SortOrder
    dateProchainControle?: SortOrderInput | SortOrder
    localisation?: SortOrderInput | SortOrder
    responsableId?: SortOrderInput | SortOrder
    valeurAchat?: SortOrderInput | SortOrder
    fournisseur?: SortOrderInput | SortOrder
    numeroMarche?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaterielCountOrderByAggregateInput
    _avg?: MaterielAvgOrderByAggregateInput
    _max?: MaterielMaxOrderByAggregateInput
    _min?: MaterielMinOrderByAggregateInput
    _sum?: MaterielSumOrderByAggregateInput
  }

  export type MaterielScalarWhereWithAggregatesInput = {
    AND?: MaterielScalarWhereWithAggregatesInput | MaterielScalarWhereWithAggregatesInput[]
    OR?: MaterielScalarWhereWithAggregatesInput[]
    NOT?: MaterielScalarWhereWithAggregatesInput | MaterielScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Materiel"> | number
    categorieId?: IntWithAggregatesFilter<"Materiel"> | number
    centreId?: IntNullableWithAggregatesFilter<"Materiel"> | number | null
    codeInventaire?: StringWithAggregatesFilter<"Materiel"> | string
    libelle?: StringWithAggregatesFilter<"Materiel"> | string
    marque?: StringNullableWithAggregatesFilter<"Materiel"> | string | null
    modele?: StringNullableWithAggregatesFilter<"Materiel"> | string | null
    numeroSerie?: StringNullableWithAggregatesFilter<"Materiel"> | string | null
    dateAcquisition?: DateTimeNullableWithAggregatesFilter<"Materiel"> | Date | string | null
    dateMiseService?: DateTimeNullableWithAggregatesFilter<"Materiel"> | Date | string | null
    dateReforme?: DateTimeNullableWithAggregatesFilter<"Materiel"> | Date | string | null
    etat?: EnumEtatMaterielWithAggregatesFilter<"Materiel"> | $Enums.EtatMateriel
    periodiciteControleJours?: IntNullableWithAggregatesFilter<"Materiel"> | number | null
    dateDernierControle?: DateTimeNullableWithAggregatesFilter<"Materiel"> | Date | string | null
    dateProchainControle?: DateTimeNullableWithAggregatesFilter<"Materiel"> | Date | string | null
    localisation?: StringNullableWithAggregatesFilter<"Materiel"> | string | null
    responsableId?: IntNullableWithAggregatesFilter<"Materiel"> | number | null
    valeurAchat?: FloatNullableWithAggregatesFilter<"Materiel"> | number | null
    fournisseur?: StringNullableWithAggregatesFilter<"Materiel"> | string | null
    numeroMarche?: StringNullableWithAggregatesFilter<"Materiel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Materiel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Materiel"> | Date | string
  }

  export type IncidentMaterielWhereInput = {
    AND?: IncidentMaterielWhereInput | IncidentMaterielWhereInput[]
    OR?: IncidentMaterielWhereInput[]
    NOT?: IncidentMaterielWhereInput | IncidentMaterielWhereInput[]
    id?: IntFilter<"IncidentMateriel"> | number
    materielId?: IntFilter<"IncidentMateriel"> | number
    signaleParId?: IntFilter<"IncidentMateriel"> | number
    dateIncident?: DateTimeFilter<"IncidentMateriel"> | Date | string
    typeIncident?: EnumTypeIncidentFilter<"IncidentMateriel"> | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFilter<"IncidentMateriel"> | $Enums.GraviteIncident
    description?: StringFilter<"IncidentMateriel"> | string
    photosUrls?: StringNullableListFilter<"IncidentMateriel">
    statut?: EnumStatutIncidentFilter<"IncidentMateriel"> | $Enums.StatutIncident
    traiteParId?: IntNullableFilter<"IncidentMateriel"> | number | null
    dateResolution?: DateTimeNullableFilter<"IncidentMateriel"> | Date | string | null
    actionsCorrectives?: StringNullableFilter<"IncidentMateriel"> | string | null
    coutReparation?: FloatNullableFilter<"IncidentMateriel"> | number | null
    createdAt?: DateTimeFilter<"IncidentMateriel"> | Date | string
    updatedAt?: DateTimeFilter<"IncidentMateriel"> | Date | string
    materiel?: XOR<MaterielRelationFilter, MaterielWhereInput>
    signalePar?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    traitePar?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
  }

  export type IncidentMaterielOrderByWithRelationInput = {
    id?: SortOrder
    materielId?: SortOrder
    signaleParId?: SortOrder
    dateIncident?: SortOrder
    typeIncident?: SortOrder
    gravite?: SortOrder
    description?: SortOrder
    photosUrls?: SortOrder
    statut?: SortOrder
    traiteParId?: SortOrderInput | SortOrder
    dateResolution?: SortOrderInput | SortOrder
    actionsCorrectives?: SortOrderInput | SortOrder
    coutReparation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    materiel?: MaterielOrderByWithRelationInput
    signalePar?: PersonnelOrderByWithRelationInput
    traitePar?: PersonnelOrderByWithRelationInput
  }

  export type IncidentMaterielWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IncidentMaterielWhereInput | IncidentMaterielWhereInput[]
    OR?: IncidentMaterielWhereInput[]
    NOT?: IncidentMaterielWhereInput | IncidentMaterielWhereInput[]
    materielId?: IntFilter<"IncidentMateriel"> | number
    signaleParId?: IntFilter<"IncidentMateriel"> | number
    dateIncident?: DateTimeFilter<"IncidentMateriel"> | Date | string
    typeIncident?: EnumTypeIncidentFilter<"IncidentMateriel"> | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFilter<"IncidentMateriel"> | $Enums.GraviteIncident
    description?: StringFilter<"IncidentMateriel"> | string
    photosUrls?: StringNullableListFilter<"IncidentMateriel">
    statut?: EnumStatutIncidentFilter<"IncidentMateriel"> | $Enums.StatutIncident
    traiteParId?: IntNullableFilter<"IncidentMateriel"> | number | null
    dateResolution?: DateTimeNullableFilter<"IncidentMateriel"> | Date | string | null
    actionsCorrectives?: StringNullableFilter<"IncidentMateriel"> | string | null
    coutReparation?: FloatNullableFilter<"IncidentMateriel"> | number | null
    createdAt?: DateTimeFilter<"IncidentMateriel"> | Date | string
    updatedAt?: DateTimeFilter<"IncidentMateriel"> | Date | string
    materiel?: XOR<MaterielRelationFilter, MaterielWhereInput>
    signalePar?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    traitePar?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
  }, "id">

  export type IncidentMaterielOrderByWithAggregationInput = {
    id?: SortOrder
    materielId?: SortOrder
    signaleParId?: SortOrder
    dateIncident?: SortOrder
    typeIncident?: SortOrder
    gravite?: SortOrder
    description?: SortOrder
    photosUrls?: SortOrder
    statut?: SortOrder
    traiteParId?: SortOrderInput | SortOrder
    dateResolution?: SortOrderInput | SortOrder
    actionsCorrectives?: SortOrderInput | SortOrder
    coutReparation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IncidentMaterielCountOrderByAggregateInput
    _avg?: IncidentMaterielAvgOrderByAggregateInput
    _max?: IncidentMaterielMaxOrderByAggregateInput
    _min?: IncidentMaterielMinOrderByAggregateInput
    _sum?: IncidentMaterielSumOrderByAggregateInput
  }

  export type IncidentMaterielScalarWhereWithAggregatesInput = {
    AND?: IncidentMaterielScalarWhereWithAggregatesInput | IncidentMaterielScalarWhereWithAggregatesInput[]
    OR?: IncidentMaterielScalarWhereWithAggregatesInput[]
    NOT?: IncidentMaterielScalarWhereWithAggregatesInput | IncidentMaterielScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IncidentMateriel"> | number
    materielId?: IntWithAggregatesFilter<"IncidentMateriel"> | number
    signaleParId?: IntWithAggregatesFilter<"IncidentMateriel"> | number
    dateIncident?: DateTimeWithAggregatesFilter<"IncidentMateriel"> | Date | string
    typeIncident?: EnumTypeIncidentWithAggregatesFilter<"IncidentMateriel"> | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentWithAggregatesFilter<"IncidentMateriel"> | $Enums.GraviteIncident
    description?: StringWithAggregatesFilter<"IncidentMateriel"> | string
    photosUrls?: StringNullableListFilter<"IncidentMateriel">
    statut?: EnumStatutIncidentWithAggregatesFilter<"IncidentMateriel"> | $Enums.StatutIncident
    traiteParId?: IntNullableWithAggregatesFilter<"IncidentMateriel"> | number | null
    dateResolution?: DateTimeNullableWithAggregatesFilter<"IncidentMateriel"> | Date | string | null
    actionsCorrectives?: StringNullableWithAggregatesFilter<"IncidentMateriel"> | string | null
    coutReparation?: FloatNullableWithAggregatesFilter<"IncidentMateriel"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"IncidentMateriel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IncidentMateriel"> | Date | string
  }

  export type EPIWhereInput = {
    AND?: EPIWhereInput | EPIWhereInput[]
    OR?: EPIWhereInput[]
    NOT?: EPIWhereInput | EPIWhereInput[]
    id?: IntFilter<"EPI"> | number
    personnelId?: IntFilter<"EPI"> | number
    typeEPI?: StringFilter<"EPI"> | string
    taille?: StringNullableFilter<"EPI"> | string | null
    numeroSerie?: StringNullableFilter<"EPI"> | string | null
    dateAttribution?: DateTimeFilter<"EPI"> | Date | string
    datePeremption?: DateTimeNullableFilter<"EPI"> | Date | string | null
    etat?: EnumEtatEPIFilter<"EPI"> | $Enums.EtatEPI
    dateDernierControle?: DateTimeNullableFilter<"EPI"> | Date | string | null
    dateProchainControle?: DateTimeNullableFilter<"EPI"> | Date | string | null
    actif?: BoolFilter<"EPI"> | boolean
    createdAt?: DateTimeFilter<"EPI"> | Date | string
    updatedAt?: DateTimeFilter<"EPI"> | Date | string
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }

  export type EPIOrderByWithRelationInput = {
    id?: SortOrder
    personnelId?: SortOrder
    typeEPI?: SortOrder
    taille?: SortOrderInput | SortOrder
    numeroSerie?: SortOrderInput | SortOrder
    dateAttribution?: SortOrder
    datePeremption?: SortOrderInput | SortOrder
    etat?: SortOrder
    dateDernierControle?: SortOrderInput | SortOrder
    dateProchainControle?: SortOrderInput | SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personnel?: PersonnelOrderByWithRelationInput
  }

  export type EPIWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EPIWhereInput | EPIWhereInput[]
    OR?: EPIWhereInput[]
    NOT?: EPIWhereInput | EPIWhereInput[]
    personnelId?: IntFilter<"EPI"> | number
    typeEPI?: StringFilter<"EPI"> | string
    taille?: StringNullableFilter<"EPI"> | string | null
    numeroSerie?: StringNullableFilter<"EPI"> | string | null
    dateAttribution?: DateTimeFilter<"EPI"> | Date | string
    datePeremption?: DateTimeNullableFilter<"EPI"> | Date | string | null
    etat?: EnumEtatEPIFilter<"EPI"> | $Enums.EtatEPI
    dateDernierControle?: DateTimeNullableFilter<"EPI"> | Date | string | null
    dateProchainControle?: DateTimeNullableFilter<"EPI"> | Date | string | null
    actif?: BoolFilter<"EPI"> | boolean
    createdAt?: DateTimeFilter<"EPI"> | Date | string
    updatedAt?: DateTimeFilter<"EPI"> | Date | string
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }, "id">

  export type EPIOrderByWithAggregationInput = {
    id?: SortOrder
    personnelId?: SortOrder
    typeEPI?: SortOrder
    taille?: SortOrderInput | SortOrder
    numeroSerie?: SortOrderInput | SortOrder
    dateAttribution?: SortOrder
    datePeremption?: SortOrderInput | SortOrder
    etat?: SortOrder
    dateDernierControle?: SortOrderInput | SortOrder
    dateProchainControle?: SortOrderInput | SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EPICountOrderByAggregateInput
    _avg?: EPIAvgOrderByAggregateInput
    _max?: EPIMaxOrderByAggregateInput
    _min?: EPIMinOrderByAggregateInput
    _sum?: EPISumOrderByAggregateInput
  }

  export type EPIScalarWhereWithAggregatesInput = {
    AND?: EPIScalarWhereWithAggregatesInput | EPIScalarWhereWithAggregatesInput[]
    OR?: EPIScalarWhereWithAggregatesInput[]
    NOT?: EPIScalarWhereWithAggregatesInput | EPIScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EPI"> | number
    personnelId?: IntWithAggregatesFilter<"EPI"> | number
    typeEPI?: StringWithAggregatesFilter<"EPI"> | string
    taille?: StringNullableWithAggregatesFilter<"EPI"> | string | null
    numeroSerie?: StringNullableWithAggregatesFilter<"EPI"> | string | null
    dateAttribution?: DateTimeWithAggregatesFilter<"EPI"> | Date | string
    datePeremption?: DateTimeNullableWithAggregatesFilter<"EPI"> | Date | string | null
    etat?: EnumEtatEPIWithAggregatesFilter<"EPI"> | $Enums.EtatEPI
    dateDernierControle?: DateTimeNullableWithAggregatesFilter<"EPI"> | Date | string | null
    dateProchainControle?: DateTimeNullableWithAggregatesFilter<"EPI"> | Date | string | null
    actif?: BoolWithAggregatesFilter<"EPI"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EPI"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EPI"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: IntFilter<"Conversation"> | number
    type?: EnumTypeConversationFilter<"Conversation"> | $Enums.TypeConversation
    nom?: StringNullableFilter<"Conversation"> | string | null
    createdById?: IntFilter<"Conversation"> | number
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    createdBy?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    participants?: ConversationParticipantListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    nom?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: PersonnelOrderByWithRelationInput
    participants?: ConversationParticipantOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    type?: EnumTypeConversationFilter<"Conversation"> | $Enums.TypeConversation
    nom?: StringNullableFilter<"Conversation"> | string | null
    createdById?: IntFilter<"Conversation"> | number
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    createdBy?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    participants?: ConversationParticipantListRelationFilter
    messages?: MessageListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    nom?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _avg?: ConversationAvgOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
    _sum?: ConversationSumOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Conversation"> | number
    type?: EnumTypeConversationWithAggregatesFilter<"Conversation"> | $Enums.TypeConversation
    nom?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    createdById?: IntWithAggregatesFilter<"Conversation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type ConversationParticipantWhereInput = {
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    conversationId?: IntFilter<"ConversationParticipant"> | number
    personnelId?: IntFilter<"ConversationParticipant"> | number
    dateAjout?: DateTimeFilter<"ConversationParticipant"> | Date | string
    dateSortie?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
    role?: EnumRoleConversationFilter<"ConversationParticipant"> | $Enums.RoleConversation
    notificationsActives?: BoolFilter<"ConversationParticipant"> | boolean
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }

  export type ConversationParticipantOrderByWithRelationInput = {
    conversationId?: SortOrder
    personnelId?: SortOrder
    dateAjout?: SortOrder
    dateSortie?: SortOrderInput | SortOrder
    role?: SortOrder
    notificationsActives?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    personnel?: PersonnelOrderByWithRelationInput
  }

  export type ConversationParticipantWhereUniqueInput = Prisma.AtLeast<{
    conversationId_personnelId?: ConversationParticipantConversationIdPersonnelIdCompoundUniqueInput
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    conversationId?: IntFilter<"ConversationParticipant"> | number
    personnelId?: IntFilter<"ConversationParticipant"> | number
    dateAjout?: DateTimeFilter<"ConversationParticipant"> | Date | string
    dateSortie?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
    role?: EnumRoleConversationFilter<"ConversationParticipant"> | $Enums.RoleConversation
    notificationsActives?: BoolFilter<"ConversationParticipant"> | boolean
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }, "conversationId_personnelId">

  export type ConversationParticipantOrderByWithAggregationInput = {
    conversationId?: SortOrder
    personnelId?: SortOrder
    dateAjout?: SortOrder
    dateSortie?: SortOrderInput | SortOrder
    role?: SortOrder
    notificationsActives?: SortOrder
    _count?: ConversationParticipantCountOrderByAggregateInput
    _avg?: ConversationParticipantAvgOrderByAggregateInput
    _max?: ConversationParticipantMaxOrderByAggregateInput
    _min?: ConversationParticipantMinOrderByAggregateInput
    _sum?: ConversationParticipantSumOrderByAggregateInput
  }

  export type ConversationParticipantScalarWhereWithAggregatesInput = {
    AND?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    OR?: ConversationParticipantScalarWhereWithAggregatesInput[]
    NOT?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    conversationId?: IntWithAggregatesFilter<"ConversationParticipant"> | number
    personnelId?: IntWithAggregatesFilter<"ConversationParticipant"> | number
    dateAjout?: DateTimeWithAggregatesFilter<"ConversationParticipant"> | Date | string
    dateSortie?: DateTimeNullableWithAggregatesFilter<"ConversationParticipant"> | Date | string | null
    role?: EnumRoleConversationWithAggregatesFilter<"ConversationParticipant"> | $Enums.RoleConversation
    notificationsActives?: BoolWithAggregatesFilter<"ConversationParticipant"> | boolean
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: IntFilter<"Message"> | number
    conversationId?: IntFilter<"Message"> | number
    expediteurId?: IntFilter<"Message"> | number
    contenu?: StringFilter<"Message"> | string
    typeMessage?: EnumTypeMessageFilter<"Message"> | $Enums.TypeMessage
    fichierUrl?: StringNullableFilter<"Message"> | string | null
    typeInteractif?: StringNullableFilter<"Message"> | string | null
    donneesInteractives?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    editedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    expediteur?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    messagesLus?: MessageLuListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    expediteurId?: SortOrder
    contenu?: SortOrder
    typeMessage?: SortOrder
    fichierUrl?: SortOrderInput | SortOrder
    typeInteractif?: SortOrderInput | SortOrder
    donneesInteractives?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    conversation?: ConversationOrderByWithRelationInput
    expediteur?: PersonnelOrderByWithRelationInput
    messagesLus?: MessageLuOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: IntFilter<"Message"> | number
    expediteurId?: IntFilter<"Message"> | number
    contenu?: StringFilter<"Message"> | string
    typeMessage?: EnumTypeMessageFilter<"Message"> | $Enums.TypeMessage
    fichierUrl?: StringNullableFilter<"Message"> | string | null
    typeInteractif?: StringNullableFilter<"Message"> | string | null
    donneesInteractives?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    editedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    expediteur?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    messagesLus?: MessageLuListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    expediteurId?: SortOrder
    contenu?: SortOrder
    typeMessage?: SortOrder
    fichierUrl?: SortOrderInput | SortOrder
    typeInteractif?: SortOrderInput | SortOrder
    donneesInteractives?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Message"> | number
    conversationId?: IntWithAggregatesFilter<"Message"> | number
    expediteurId?: IntWithAggregatesFilter<"Message"> | number
    contenu?: StringWithAggregatesFilter<"Message"> | string
    typeMessage?: EnumTypeMessageWithAggregatesFilter<"Message"> | $Enums.TypeMessage
    fichierUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    typeInteractif?: StringNullableWithAggregatesFilter<"Message"> | string | null
    donneesInteractives?: JsonNullableWithAggregatesFilter<"Message">
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    editedAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
  }

  export type MessageLuWhereInput = {
    AND?: MessageLuWhereInput | MessageLuWhereInput[]
    OR?: MessageLuWhereInput[]
    NOT?: MessageLuWhereInput | MessageLuWhereInput[]
    messageId?: IntFilter<"MessageLu"> | number
    personnelId?: IntFilter<"MessageLu"> | number
    dateLecture?: DateTimeFilter<"MessageLu"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }

  export type MessageLuOrderByWithRelationInput = {
    messageId?: SortOrder
    personnelId?: SortOrder
    dateLecture?: SortOrder
    message?: MessageOrderByWithRelationInput
    personnel?: PersonnelOrderByWithRelationInput
  }

  export type MessageLuWhereUniqueInput = Prisma.AtLeast<{
    messageId_personnelId?: MessageLuMessageIdPersonnelIdCompoundUniqueInput
    AND?: MessageLuWhereInput | MessageLuWhereInput[]
    OR?: MessageLuWhereInput[]
    NOT?: MessageLuWhereInput | MessageLuWhereInput[]
    messageId?: IntFilter<"MessageLu"> | number
    personnelId?: IntFilter<"MessageLu"> | number
    dateLecture?: DateTimeFilter<"MessageLu"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }, "messageId_personnelId">

  export type MessageLuOrderByWithAggregationInput = {
    messageId?: SortOrder
    personnelId?: SortOrder
    dateLecture?: SortOrder
    _count?: MessageLuCountOrderByAggregateInput
    _avg?: MessageLuAvgOrderByAggregateInput
    _max?: MessageLuMaxOrderByAggregateInput
    _min?: MessageLuMinOrderByAggregateInput
    _sum?: MessageLuSumOrderByAggregateInput
  }

  export type MessageLuScalarWhereWithAggregatesInput = {
    AND?: MessageLuScalarWhereWithAggregatesInput | MessageLuScalarWhereWithAggregatesInput[]
    OR?: MessageLuScalarWhereWithAggregatesInput[]
    NOT?: MessageLuScalarWhereWithAggregatesInput | MessageLuScalarWhereWithAggregatesInput[]
    messageId?: IntWithAggregatesFilter<"MessageLu"> | number
    personnelId?: IntWithAggregatesFilter<"MessageLu"> | number
    dateLecture?: DateTimeWithAggregatesFilter<"MessageLu"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    destinataireId?: IntFilter<"Notification"> | number
    typeNotification?: StringFilter<"Notification"> | string
    titre?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    niveau?: EnumNiveauNotificationFilter<"Notification"> | $Enums.NiveauNotification
    entiteType?: StringNullableFilter<"Notification"> | string | null
    entiteId?: IntNullableFilter<"Notification"> | number | null
    donneesSupplementaires?: JsonNullableFilter<"Notification">
    lue?: BoolFilter<"Notification"> | boolean
    dateLecture?: DateTimeNullableFilter<"Notification"> | Date | string | null
    envoyeePush?: BoolFilter<"Notification"> | boolean
    envoyeeEmail?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    destinataire?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    destinataireId?: SortOrder
    typeNotification?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    niveau?: SortOrder
    entiteType?: SortOrderInput | SortOrder
    entiteId?: SortOrderInput | SortOrder
    donneesSupplementaires?: SortOrderInput | SortOrder
    lue?: SortOrder
    dateLecture?: SortOrderInput | SortOrder
    envoyeePush?: SortOrder
    envoyeeEmail?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    destinataire?: PersonnelOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    destinataireId?: IntFilter<"Notification"> | number
    typeNotification?: StringFilter<"Notification"> | string
    titre?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    niveau?: EnumNiveauNotificationFilter<"Notification"> | $Enums.NiveauNotification
    entiteType?: StringNullableFilter<"Notification"> | string | null
    entiteId?: IntNullableFilter<"Notification"> | number | null
    donneesSupplementaires?: JsonNullableFilter<"Notification">
    lue?: BoolFilter<"Notification"> | boolean
    dateLecture?: DateTimeNullableFilter<"Notification"> | Date | string | null
    envoyeePush?: BoolFilter<"Notification"> | boolean
    envoyeeEmail?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    destinataire?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    destinataireId?: SortOrder
    typeNotification?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    niveau?: SortOrder
    entiteType?: SortOrderInput | SortOrder
    entiteId?: SortOrderInput | SortOrder
    donneesSupplementaires?: SortOrderInput | SortOrder
    lue?: SortOrder
    dateLecture?: SortOrderInput | SortOrder
    envoyeePush?: SortOrder
    envoyeeEmail?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    destinataireId?: IntWithAggregatesFilter<"Notification"> | number
    typeNotification?: StringWithAggregatesFilter<"Notification"> | string
    titre?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    niveau?: EnumNiveauNotificationWithAggregatesFilter<"Notification"> | $Enums.NiveauNotification
    entiteType?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    entiteId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    donneesSupplementaires?: JsonNullableWithAggregatesFilter<"Notification">
    lue?: BoolWithAggregatesFilter<"Notification"> | boolean
    dateLecture?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    envoyeePush?: BoolWithAggregatesFilter<"Notification"> | boolean
    envoyeeEmail?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type EvenementWhereInput = {
    AND?: EvenementWhereInput | EvenementWhereInput[]
    OR?: EvenementWhereInput[]
    NOT?: EvenementWhereInput | EvenementWhereInput[]
    id?: IntFilter<"Evenement"> | number
    createurId?: IntFilter<"Evenement"> | number
    centreId?: IntNullableFilter<"Evenement"> | number | null
    titre?: StringFilter<"Evenement"> | string
    description?: StringNullableFilter<"Evenement"> | string | null
    lieu?: StringNullableFilter<"Evenement"> | string | null
    dateDebut?: DateTimeFilter<"Evenement"> | Date | string
    dateFin?: DateTimeFilter<"Evenement"> | Date | string
    journeeEntiere?: BoolFilter<"Evenement"> | boolean
    typeEvenement?: StringNullableFilter<"Evenement"> | string | null
    visibilite?: EnumVisibiliteEvenementFilter<"Evenement"> | $Enums.VisibiliteEvenement
    recurrent?: BoolFilter<"Evenement"> | boolean
    patternRecurrence?: JsonNullableFilter<"Evenement">
    couleur?: StringNullableFilter<"Evenement"> | string | null
    rappels?: JsonFilter<"Evenement">
    annule?: BoolFilter<"Evenement"> | boolean
    createdAt?: DateTimeFilter<"Evenement"> | Date | string
    updatedAt?: DateTimeFilter<"Evenement"> | Date | string
    createur?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    centre?: XOR<CentreNullableRelationFilter, CentreWhereInput> | null
    participants?: EvenementParticipantListRelationFilter
  }

  export type EvenementOrderByWithRelationInput = {
    id?: SortOrder
    createurId?: SortOrder
    centreId?: SortOrderInput | SortOrder
    titre?: SortOrder
    description?: SortOrderInput | SortOrder
    lieu?: SortOrderInput | SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    journeeEntiere?: SortOrder
    typeEvenement?: SortOrderInput | SortOrder
    visibilite?: SortOrder
    recurrent?: SortOrder
    patternRecurrence?: SortOrderInput | SortOrder
    couleur?: SortOrderInput | SortOrder
    rappels?: SortOrder
    annule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createur?: PersonnelOrderByWithRelationInput
    centre?: CentreOrderByWithRelationInput
    participants?: EvenementParticipantOrderByRelationAggregateInput
  }

  export type EvenementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EvenementWhereInput | EvenementWhereInput[]
    OR?: EvenementWhereInput[]
    NOT?: EvenementWhereInput | EvenementWhereInput[]
    createurId?: IntFilter<"Evenement"> | number
    centreId?: IntNullableFilter<"Evenement"> | number | null
    titre?: StringFilter<"Evenement"> | string
    description?: StringNullableFilter<"Evenement"> | string | null
    lieu?: StringNullableFilter<"Evenement"> | string | null
    dateDebut?: DateTimeFilter<"Evenement"> | Date | string
    dateFin?: DateTimeFilter<"Evenement"> | Date | string
    journeeEntiere?: BoolFilter<"Evenement"> | boolean
    typeEvenement?: StringNullableFilter<"Evenement"> | string | null
    visibilite?: EnumVisibiliteEvenementFilter<"Evenement"> | $Enums.VisibiliteEvenement
    recurrent?: BoolFilter<"Evenement"> | boolean
    patternRecurrence?: JsonNullableFilter<"Evenement">
    couleur?: StringNullableFilter<"Evenement"> | string | null
    rappels?: JsonFilter<"Evenement">
    annule?: BoolFilter<"Evenement"> | boolean
    createdAt?: DateTimeFilter<"Evenement"> | Date | string
    updatedAt?: DateTimeFilter<"Evenement"> | Date | string
    createur?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    centre?: XOR<CentreNullableRelationFilter, CentreWhereInput> | null
    participants?: EvenementParticipantListRelationFilter
  }, "id">

  export type EvenementOrderByWithAggregationInput = {
    id?: SortOrder
    createurId?: SortOrder
    centreId?: SortOrderInput | SortOrder
    titre?: SortOrder
    description?: SortOrderInput | SortOrder
    lieu?: SortOrderInput | SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    journeeEntiere?: SortOrder
    typeEvenement?: SortOrderInput | SortOrder
    visibilite?: SortOrder
    recurrent?: SortOrder
    patternRecurrence?: SortOrderInput | SortOrder
    couleur?: SortOrderInput | SortOrder
    rappels?: SortOrder
    annule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EvenementCountOrderByAggregateInput
    _avg?: EvenementAvgOrderByAggregateInput
    _max?: EvenementMaxOrderByAggregateInput
    _min?: EvenementMinOrderByAggregateInput
    _sum?: EvenementSumOrderByAggregateInput
  }

  export type EvenementScalarWhereWithAggregatesInput = {
    AND?: EvenementScalarWhereWithAggregatesInput | EvenementScalarWhereWithAggregatesInput[]
    OR?: EvenementScalarWhereWithAggregatesInput[]
    NOT?: EvenementScalarWhereWithAggregatesInput | EvenementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Evenement"> | number
    createurId?: IntWithAggregatesFilter<"Evenement"> | number
    centreId?: IntNullableWithAggregatesFilter<"Evenement"> | number | null
    titre?: StringWithAggregatesFilter<"Evenement"> | string
    description?: StringNullableWithAggregatesFilter<"Evenement"> | string | null
    lieu?: StringNullableWithAggregatesFilter<"Evenement"> | string | null
    dateDebut?: DateTimeWithAggregatesFilter<"Evenement"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"Evenement"> | Date | string
    journeeEntiere?: BoolWithAggregatesFilter<"Evenement"> | boolean
    typeEvenement?: StringNullableWithAggregatesFilter<"Evenement"> | string | null
    visibilite?: EnumVisibiliteEvenementWithAggregatesFilter<"Evenement"> | $Enums.VisibiliteEvenement
    recurrent?: BoolWithAggregatesFilter<"Evenement"> | boolean
    patternRecurrence?: JsonNullableWithAggregatesFilter<"Evenement">
    couleur?: StringNullableWithAggregatesFilter<"Evenement"> | string | null
    rappels?: JsonWithAggregatesFilter<"Evenement">
    annule?: BoolWithAggregatesFilter<"Evenement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Evenement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Evenement"> | Date | string
  }

  export type EvenementParticipantWhereInput = {
    AND?: EvenementParticipantWhereInput | EvenementParticipantWhereInput[]
    OR?: EvenementParticipantWhereInput[]
    NOT?: EvenementParticipantWhereInput | EvenementParticipantWhereInput[]
    evenementId?: IntFilter<"EvenementParticipant"> | number
    personnelId?: IntFilter<"EvenementParticipant"> | number
    statutInvitation?: EnumStatutInvitationFilter<"EvenementParticipant"> | $Enums.StatutInvitation
    obligatoire?: BoolFilter<"EvenementParticipant"> | boolean
    dateReponse?: DateTimeNullableFilter<"EvenementParticipant"> | Date | string | null
    commentaire?: StringNullableFilter<"EvenementParticipant"> | string | null
    evenement?: XOR<EvenementRelationFilter, EvenementWhereInput>
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }

  export type EvenementParticipantOrderByWithRelationInput = {
    evenementId?: SortOrder
    personnelId?: SortOrder
    statutInvitation?: SortOrder
    obligatoire?: SortOrder
    dateReponse?: SortOrderInput | SortOrder
    commentaire?: SortOrderInput | SortOrder
    evenement?: EvenementOrderByWithRelationInput
    personnel?: PersonnelOrderByWithRelationInput
  }

  export type EvenementParticipantWhereUniqueInput = Prisma.AtLeast<{
    evenementId_personnelId?: EvenementParticipantEvenementIdPersonnelIdCompoundUniqueInput
    AND?: EvenementParticipantWhereInput | EvenementParticipantWhereInput[]
    OR?: EvenementParticipantWhereInput[]
    NOT?: EvenementParticipantWhereInput | EvenementParticipantWhereInput[]
    evenementId?: IntFilter<"EvenementParticipant"> | number
    personnelId?: IntFilter<"EvenementParticipant"> | number
    statutInvitation?: EnumStatutInvitationFilter<"EvenementParticipant"> | $Enums.StatutInvitation
    obligatoire?: BoolFilter<"EvenementParticipant"> | boolean
    dateReponse?: DateTimeNullableFilter<"EvenementParticipant"> | Date | string | null
    commentaire?: StringNullableFilter<"EvenementParticipant"> | string | null
    evenement?: XOR<EvenementRelationFilter, EvenementWhereInput>
    personnel?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
  }, "evenementId_personnelId">

  export type EvenementParticipantOrderByWithAggregationInput = {
    evenementId?: SortOrder
    personnelId?: SortOrder
    statutInvitation?: SortOrder
    obligatoire?: SortOrder
    dateReponse?: SortOrderInput | SortOrder
    commentaire?: SortOrderInput | SortOrder
    _count?: EvenementParticipantCountOrderByAggregateInput
    _avg?: EvenementParticipantAvgOrderByAggregateInput
    _max?: EvenementParticipantMaxOrderByAggregateInput
    _min?: EvenementParticipantMinOrderByAggregateInput
    _sum?: EvenementParticipantSumOrderByAggregateInput
  }

  export type EvenementParticipantScalarWhereWithAggregatesInput = {
    AND?: EvenementParticipantScalarWhereWithAggregatesInput | EvenementParticipantScalarWhereWithAggregatesInput[]
    OR?: EvenementParticipantScalarWhereWithAggregatesInput[]
    NOT?: EvenementParticipantScalarWhereWithAggregatesInput | EvenementParticipantScalarWhereWithAggregatesInput[]
    evenementId?: IntWithAggregatesFilter<"EvenementParticipant"> | number
    personnelId?: IntWithAggregatesFilter<"EvenementParticipant"> | number
    statutInvitation?: EnumStatutInvitationWithAggregatesFilter<"EvenementParticipant"> | $Enums.StatutInvitation
    obligatoire?: BoolWithAggregatesFilter<"EvenementParticipant"> | boolean
    dateReponse?: DateTimeNullableWithAggregatesFilter<"EvenementParticipant"> | Date | string | null
    commentaire?: StringNullableWithAggregatesFilter<"EvenementParticipant"> | string | null
  }

  export type ExportTTAWhereInput = {
    AND?: ExportTTAWhereInput | ExportTTAWhereInput[]
    OR?: ExportTTAWhereInput[]
    NOT?: ExportTTAWhereInput | ExportTTAWhereInput[]
    id?: IntFilter<"ExportTTA"> | number
    periodeDebut?: DateTimeFilter<"ExportTTA"> | Date | string
    periodeFin?: DateTimeFilter<"ExportTTA"> | Date | string
    centreId?: IntNullableFilter<"ExportTTA"> | number | null
    genereParId?: IntFilter<"ExportTTA"> | number
    dateGeneration?: DateTimeFilter<"ExportTTA"> | Date | string
    nombreLignes?: IntNullableFilter<"ExportTTA"> | number | null
    montantTotal?: FloatNullableFilter<"ExportTTA"> | number | null
    fichierUrl?: StringNullableFilter<"ExportTTA"> | string | null
    formatExport?: EnumFormatExportFilter<"ExportTTA"> | $Enums.FormatExport
    statut?: EnumStatutExportFilter<"ExportTTA"> | $Enums.StatutExport
    dateValidation?: DateTimeNullableFilter<"ExportTTA"> | Date | string | null
    valideParId?: IntNullableFilter<"ExportTTA"> | number | null
    dateTransmission?: DateTimeNullableFilter<"ExportTTA"> | Date | string | null
    numeroBordereau?: StringNullableFilter<"ExportTTA"> | string | null
    commentaires?: StringNullableFilter<"ExportTTA"> | string | null
    sessionId?: IntNullableFilter<"ExportTTA"> | number | null
    centre?: XOR<CentreNullableRelationFilter, CentreWhereInput> | null
    generePar?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    validePar?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
    session?: XOR<SessionFMPANullableRelationFilter, SessionFMPAWhereInput> | null
  }

  export type ExportTTAOrderByWithRelationInput = {
    id?: SortOrder
    periodeDebut?: SortOrder
    periodeFin?: SortOrder
    centreId?: SortOrderInput | SortOrder
    genereParId?: SortOrder
    dateGeneration?: SortOrder
    nombreLignes?: SortOrderInput | SortOrder
    montantTotal?: SortOrderInput | SortOrder
    fichierUrl?: SortOrderInput | SortOrder
    formatExport?: SortOrder
    statut?: SortOrder
    dateValidation?: SortOrderInput | SortOrder
    valideParId?: SortOrderInput | SortOrder
    dateTransmission?: SortOrderInput | SortOrder
    numeroBordereau?: SortOrderInput | SortOrder
    commentaires?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    centre?: CentreOrderByWithRelationInput
    generePar?: PersonnelOrderByWithRelationInput
    validePar?: PersonnelOrderByWithRelationInput
    session?: SessionFMPAOrderByWithRelationInput
  }

  export type ExportTTAWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExportTTAWhereInput | ExportTTAWhereInput[]
    OR?: ExportTTAWhereInput[]
    NOT?: ExportTTAWhereInput | ExportTTAWhereInput[]
    periodeDebut?: DateTimeFilter<"ExportTTA"> | Date | string
    periodeFin?: DateTimeFilter<"ExportTTA"> | Date | string
    centreId?: IntNullableFilter<"ExportTTA"> | number | null
    genereParId?: IntFilter<"ExportTTA"> | number
    dateGeneration?: DateTimeFilter<"ExportTTA"> | Date | string
    nombreLignes?: IntNullableFilter<"ExportTTA"> | number | null
    montantTotal?: FloatNullableFilter<"ExportTTA"> | number | null
    fichierUrl?: StringNullableFilter<"ExportTTA"> | string | null
    formatExport?: EnumFormatExportFilter<"ExportTTA"> | $Enums.FormatExport
    statut?: EnumStatutExportFilter<"ExportTTA"> | $Enums.StatutExport
    dateValidation?: DateTimeNullableFilter<"ExportTTA"> | Date | string | null
    valideParId?: IntNullableFilter<"ExportTTA"> | number | null
    dateTransmission?: DateTimeNullableFilter<"ExportTTA"> | Date | string | null
    numeroBordereau?: StringNullableFilter<"ExportTTA"> | string | null
    commentaires?: StringNullableFilter<"ExportTTA"> | string | null
    sessionId?: IntNullableFilter<"ExportTTA"> | number | null
    centre?: XOR<CentreNullableRelationFilter, CentreWhereInput> | null
    generePar?: XOR<PersonnelRelationFilter, PersonnelWhereInput>
    validePar?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
    session?: XOR<SessionFMPANullableRelationFilter, SessionFMPAWhereInput> | null
  }, "id">

  export type ExportTTAOrderByWithAggregationInput = {
    id?: SortOrder
    periodeDebut?: SortOrder
    periodeFin?: SortOrder
    centreId?: SortOrderInput | SortOrder
    genereParId?: SortOrder
    dateGeneration?: SortOrder
    nombreLignes?: SortOrderInput | SortOrder
    montantTotal?: SortOrderInput | SortOrder
    fichierUrl?: SortOrderInput | SortOrder
    formatExport?: SortOrder
    statut?: SortOrder
    dateValidation?: SortOrderInput | SortOrder
    valideParId?: SortOrderInput | SortOrder
    dateTransmission?: SortOrderInput | SortOrder
    numeroBordereau?: SortOrderInput | SortOrder
    commentaires?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    _count?: ExportTTACountOrderByAggregateInput
    _avg?: ExportTTAAvgOrderByAggregateInput
    _max?: ExportTTAMaxOrderByAggregateInput
    _min?: ExportTTAMinOrderByAggregateInput
    _sum?: ExportTTASumOrderByAggregateInput
  }

  export type ExportTTAScalarWhereWithAggregatesInput = {
    AND?: ExportTTAScalarWhereWithAggregatesInput | ExportTTAScalarWhereWithAggregatesInput[]
    OR?: ExportTTAScalarWhereWithAggregatesInput[]
    NOT?: ExportTTAScalarWhereWithAggregatesInput | ExportTTAScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExportTTA"> | number
    periodeDebut?: DateTimeWithAggregatesFilter<"ExportTTA"> | Date | string
    periodeFin?: DateTimeWithAggregatesFilter<"ExportTTA"> | Date | string
    centreId?: IntNullableWithAggregatesFilter<"ExportTTA"> | number | null
    genereParId?: IntWithAggregatesFilter<"ExportTTA"> | number
    dateGeneration?: DateTimeWithAggregatesFilter<"ExportTTA"> | Date | string
    nombreLignes?: IntNullableWithAggregatesFilter<"ExportTTA"> | number | null
    montantTotal?: FloatNullableWithAggregatesFilter<"ExportTTA"> | number | null
    fichierUrl?: StringNullableWithAggregatesFilter<"ExportTTA"> | string | null
    formatExport?: EnumFormatExportWithAggregatesFilter<"ExportTTA"> | $Enums.FormatExport
    statut?: EnumStatutExportWithAggregatesFilter<"ExportTTA"> | $Enums.StatutExport
    dateValidation?: DateTimeNullableWithAggregatesFilter<"ExportTTA"> | Date | string | null
    valideParId?: IntNullableWithAggregatesFilter<"ExportTTA"> | number | null
    dateTransmission?: DateTimeNullableWithAggregatesFilter<"ExportTTA"> | Date | string | null
    numeroBordereau?: StringNullableWithAggregatesFilter<"ExportTTA"> | string | null
    commentaires?: StringNullableWithAggregatesFilter<"ExportTTA"> | string | null
    sessionId?: IntNullableWithAggregatesFilter<"ExportTTA"> | number | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    utilisateurId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    entiteType?: StringFilter<"AuditLog"> | string
    entiteId?: IntNullableFilter<"AuditLog"> | number | null
    anciennesValeurs?: JsonNullableFilter<"AuditLog">
    nouvellesValeurs?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    utilisateur?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    utilisateurId?: SortOrderInput | SortOrder
    action?: SortOrder
    entiteType?: SortOrder
    entiteId?: SortOrderInput | SortOrder
    anciennesValeurs?: SortOrderInput | SortOrder
    nouvellesValeurs?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    utilisateur?: PersonnelOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    utilisateurId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    entiteType?: StringFilter<"AuditLog"> | string
    entiteId?: IntNullableFilter<"AuditLog"> | number | null
    anciennesValeurs?: JsonNullableFilter<"AuditLog">
    nouvellesValeurs?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    utilisateur?: XOR<PersonnelNullableRelationFilter, PersonnelWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    utilisateurId?: SortOrderInput | SortOrder
    action?: SortOrder
    entiteType?: SortOrder
    entiteId?: SortOrderInput | SortOrder
    anciennesValeurs?: SortOrderInput | SortOrder
    nouvellesValeurs?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    utilisateurId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entiteType?: StringWithAggregatesFilter<"AuditLog"> | string
    entiteId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    anciennesValeurs?: JsonNullableWithAggregatesFilter<"AuditLog">
    nouvellesValeurs?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type GradeCreateInput = {
    code: string
    libelle: string
    categorie: $Enums.Categorie
    ordreHierarchique: number
    actif?: boolean
    personnels?: PersonnelCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateInput = {
    id?: number
    code: string
    libelle: string
    categorie: $Enums.Categorie
    ordreHierarchique: number
    actif?: boolean
    personnels?: PersonnelUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    ordreHierarchique?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
    personnels?: PersonnelUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    ordreHierarchique?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
    personnels?: PersonnelUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type GradeCreateManyInput = {
    id?: number
    code: string
    libelle: string
    categorie: $Enums.Categorie
    ordreHierarchique: number
    actif?: boolean
  }

  export type GradeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    ordreHierarchique?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GradeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    ordreHierarchique?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CentreCreateInput = {
    code: string
    nom: string
    type: $Enums.TypeCentre
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    telephone?: string | null
    email?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personnels?: PersonnelCreateNestedManyWithoutCentreInput
    sessions?: SessionFMPACreateNestedManyWithoutCentreInput
    materiels?: MaterielCreateNestedManyWithoutCentreInput
    evenements?: EvenementCreateNestedManyWithoutCentreInput
    exportsTTA?: ExportTTACreateNestedManyWithoutCentreInput
  }

  export type CentreUncheckedCreateInput = {
    id?: number
    code: string
    nom: string
    type: $Enums.TypeCentre
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    telephone?: string | null
    email?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personnels?: PersonnelUncheckedCreateNestedManyWithoutCentreInput
    sessions?: SessionFMPAUncheckedCreateNestedManyWithoutCentreInput
    materiels?: MaterielUncheckedCreateNestedManyWithoutCentreInput
    evenements?: EvenementUncheckedCreateNestedManyWithoutCentreInput
    exportsTTA?: ExportTTAUncheckedCreateNestedManyWithoutCentreInput
  }

  export type CentreUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCentreFieldUpdateOperationsInput | $Enums.TypeCentre
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnels?: PersonnelUpdateManyWithoutCentreNestedInput
    sessions?: SessionFMPAUpdateManyWithoutCentreNestedInput
    materiels?: MaterielUpdateManyWithoutCentreNestedInput
    evenements?: EvenementUpdateManyWithoutCentreNestedInput
    exportsTTA?: ExportTTAUpdateManyWithoutCentreNestedInput
  }

  export type CentreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCentreFieldUpdateOperationsInput | $Enums.TypeCentre
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnels?: PersonnelUncheckedUpdateManyWithoutCentreNestedInput
    sessions?: SessionFMPAUncheckedUpdateManyWithoutCentreNestedInput
    materiels?: MaterielUncheckedUpdateManyWithoutCentreNestedInput
    evenements?: EvenementUncheckedUpdateManyWithoutCentreNestedInput
    exportsTTA?: ExportTTAUncheckedUpdateManyWithoutCentreNestedInput
  }

  export type CentreCreateManyInput = {
    id?: number
    code: string
    nom: string
    type: $Enums.TypeCentre
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    telephone?: string | null
    email?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CentreUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCentreFieldUpdateOperationsInput | $Enums.TypeCentre
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CentreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCentreFieldUpdateOperationsInput | $Enums.TypeCentre
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonnelCreateInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUpdateInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelCreateManyInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PersonnelUpdateManyMutationInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonnelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleCreateInput = {
    code: string
    libelle: string
    description?: string | null
    permissions?: JsonNullValueInput | InputJsonValue
    actif?: boolean
    personnels?: PersonnelRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    code: string
    libelle: string
    description?: string | null
    permissions?: JsonNullValueInput | InputJsonValue
    actif?: boolean
    personnels?: PersonnelRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    actif?: BoolFieldUpdateOperationsInput | boolean
    personnels?: PersonnelRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    actif?: BoolFieldUpdateOperationsInput | boolean
    personnels?: PersonnelRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    code: string
    libelle: string
    description?: string | null
    permissions?: JsonNullValueInput | InputJsonValue
    actif?: boolean
  }

  export type RoleUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersonnelRoleCreateInput = {
    dateAttribution?: Date | string
    dateFin?: Date | string | null
    personnel: PersonnelCreateNestedOneWithoutPersonnelRolesInput
    role: RoleCreateNestedOneWithoutPersonnelsInput
  }

  export type PersonnelRoleUncheckedCreateInput = {
    personnelId: number
    roleId: number
    dateAttribution?: Date | string
    dateFin?: Date | string | null
  }

  export type PersonnelRoleUpdateInput = {
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnel?: PersonnelUpdateOneRequiredWithoutPersonnelRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutPersonnelsNestedInput
  }

  export type PersonnelRoleUncheckedUpdateInput = {
    personnelId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonnelRoleCreateManyInput = {
    personnelId: number
    roleId: number
    dateAttribution?: Date | string
    dateFin?: Date | string | null
  }

  export type PersonnelRoleUpdateManyMutationInput = {
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonnelRoleUncheckedUpdateManyInput = {
    personnelId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypeCompetenceCreateInput = {
    code: string
    libelle: string
    description?: string | null
    dureeValiditeMois?: number | null
    actif?: boolean
    competences?: PersonnelCompetenceCreateNestedManyWithoutTypeCompetenceInput
  }

  export type TypeCompetenceUncheckedCreateInput = {
    id?: number
    code: string
    libelle: string
    description?: string | null
    dureeValiditeMois?: number | null
    actif?: boolean
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutTypeCompetenceInput
  }

  export type TypeCompetenceUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dureeValiditeMois?: NullableIntFieldUpdateOperationsInput | number | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    competences?: PersonnelCompetenceUpdateManyWithoutTypeCompetenceNestedInput
  }

  export type TypeCompetenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dureeValiditeMois?: NullableIntFieldUpdateOperationsInput | number | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutTypeCompetenceNestedInput
  }

  export type TypeCompetenceCreateManyInput = {
    id?: number
    code: string
    libelle: string
    description?: string | null
    dureeValiditeMois?: number | null
    actif?: boolean
  }

  export type TypeCompetenceUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dureeValiditeMois?: NullableIntFieldUpdateOperationsInput | number | null
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TypeCompetenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dureeValiditeMois?: NullableIntFieldUpdateOperationsInput | number | null
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersonnelCompetenceCreateInput = {
    dateObtention: Date | string
    dateExpiration?: Date | string | null
    niveau?: string | null
    numeroDiplome?: string | null
    organismeDelivrance?: string | null
    actif?: boolean
    createdAt?: Date | string
    personnel: PersonnelCreateNestedOneWithoutCompetencesInput
    typeCompetence: TypeCompetenceCreateNestedOneWithoutCompetencesInput
  }

  export type PersonnelCompetenceUncheckedCreateInput = {
    id?: number
    personnelId: number
    typeCompetenceId: number
    dateObtention: Date | string
    dateExpiration?: Date | string | null
    niveau?: string | null
    numeroDiplome?: string | null
    organismeDelivrance?: string | null
    actif?: boolean
    createdAt?: Date | string
  }

  export type PersonnelCompetenceUpdateInput = {
    dateObtention?: DateTimeFieldUpdateOperationsInput | Date | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    numeroDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    organismeDelivrance?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnel?: PersonnelUpdateOneRequiredWithoutCompetencesNestedInput
    typeCompetence?: TypeCompetenceUpdateOneRequiredWithoutCompetencesNestedInput
  }

  export type PersonnelCompetenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    typeCompetenceId?: IntFieldUpdateOperationsInput | number
    dateObtention?: DateTimeFieldUpdateOperationsInput | Date | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    numeroDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    organismeDelivrance?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonnelCompetenceCreateManyInput = {
    id?: number
    personnelId: number
    typeCompetenceId: number
    dateObtention: Date | string
    dateExpiration?: Date | string | null
    niveau?: string | null
    numeroDiplome?: string | null
    organismeDelivrance?: string | null
    actif?: boolean
    createdAt?: Date | string
  }

  export type PersonnelCompetenceUpdateManyMutationInput = {
    dateObtention?: DateTimeFieldUpdateOperationsInput | Date | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    numeroDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    organismeDelivrance?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonnelCompetenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    typeCompetenceId?: IntFieldUpdateOperationsInput | number
    dateObtention?: DateTimeFieldUpdateOperationsInput | Date | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    numeroDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    organismeDelivrance?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AptitudeMedicaleCreateInput = {
    dateVisite: Date | string
    dateProchaineVisite?: Date | string | null
    aptitude: $Enums.StatutAptitude
    restrictions?: string | null
    medecin?: string | null
    commentaires?: string | null
    createdAt?: Date | string
    personnel: PersonnelCreateNestedOneWithoutAptitudesMedicalesInput
  }

  export type AptitudeMedicaleUncheckedCreateInput = {
    id?: number
    personnelId: number
    dateVisite: Date | string
    dateProchaineVisite?: Date | string | null
    aptitude: $Enums.StatutAptitude
    restrictions?: string | null
    medecin?: string | null
    commentaires?: string | null
    createdAt?: Date | string
  }

  export type AptitudeMedicaleUpdateInput = {
    dateVisite?: DateTimeFieldUpdateOperationsInput | Date | string
    dateProchaineVisite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aptitude?: EnumStatutAptitudeFieldUpdateOperationsInput | $Enums.StatutAptitude
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    medecin?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnel?: PersonnelUpdateOneRequiredWithoutAptitudesMedicalesNestedInput
  }

  export type AptitudeMedicaleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    dateVisite?: DateTimeFieldUpdateOperationsInput | Date | string
    dateProchaineVisite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aptitude?: EnumStatutAptitudeFieldUpdateOperationsInput | $Enums.StatutAptitude
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    medecin?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AptitudeMedicaleCreateManyInput = {
    id?: number
    personnelId: number
    dateVisite: Date | string
    dateProchaineVisite?: Date | string | null
    aptitude: $Enums.StatutAptitude
    restrictions?: string | null
    medecin?: string | null
    commentaires?: string | null
    createdAt?: Date | string
  }

  export type AptitudeMedicaleUpdateManyMutationInput = {
    dateVisite?: DateTimeFieldUpdateOperationsInput | Date | string
    dateProchaineVisite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aptitude?: EnumStatutAptitudeFieldUpdateOperationsInput | $Enums.StatutAptitude
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    medecin?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AptitudeMedicaleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    dateVisite?: DateTimeFieldUpdateOperationsInput | Date | string
    dateProchaineVisite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aptitude?: EnumStatutAptitudeFieldUpdateOperationsInput | $Enums.StatutAptitude
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    medecin?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeFMPACreateInput = {
    code: string
    libelle: string
    dureeHeures: number
    obligatoire?: boolean
    periodiciteMois?: number | null
    description?: string | null
    actif?: boolean
    sessions?: SessionFMPACreateNestedManyWithoutTypeFMPAInput
  }

  export type TypeFMPAUncheckedCreateInput = {
    id?: number
    code: string
    libelle: string
    dureeHeures: number
    obligatoire?: boolean
    periodiciteMois?: number | null
    description?: string | null
    actif?: boolean
    sessions?: SessionFMPAUncheckedCreateNestedManyWithoutTypeFMPAInput
  }

  export type TypeFMPAUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    dureeHeures?: FloatFieldUpdateOperationsInput | number
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    periodiciteMois?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    sessions?: SessionFMPAUpdateManyWithoutTypeFMPANestedInput
  }

  export type TypeFMPAUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    dureeHeures?: FloatFieldUpdateOperationsInput | number
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    periodiciteMois?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    sessions?: SessionFMPAUncheckedUpdateManyWithoutTypeFMPANestedInput
  }

  export type TypeFMPACreateManyInput = {
    id?: number
    code: string
    libelle: string
    dureeHeures: number
    obligatoire?: boolean
    periodiciteMois?: number | null
    description?: string | null
    actif?: boolean
  }

  export type TypeFMPAUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    dureeHeures?: FloatFieldUpdateOperationsInput | number
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    periodiciteMois?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TypeFMPAUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    dureeHeures?: FloatFieldUpdateOperationsInput | number
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    periodiciteMois?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionFMPACreateInput = {
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    typeFMPA: TypeFMPACreateNestedOneWithoutSessionsInput
    centre?: CentreCreateNestedOneWithoutSessionsInput
    formateurPrincipal: PersonnelCreateNestedOneWithoutSessionsFMPAFormateurInput
    formateursAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutSessionInput
    inscriptions?: InscriptionFMPACreateNestedManyWithoutSessionInput
    signatures?: SignatureFMPACreateNestedManyWithoutSessionInput
    exportsTTA?: ExportTTACreateNestedManyWithoutSessionInput
  }

  export type SessionFMPAUncheckedCreateInput = {
    id?: number
    typeFMPAId: number
    centreId?: number | null
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    formateurPrincipalId: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    formateursAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutSessionInput
    inscriptions?: InscriptionFMPAUncheckedCreateNestedManyWithoutSessionInput
    signatures?: SignatureFMPAUncheckedCreateNestedManyWithoutSessionInput
    exportsTTA?: ExportTTAUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionFMPAUpdateInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeFMPA?: TypeFMPAUpdateOneRequiredWithoutSessionsNestedInput
    centre?: CentreUpdateOneWithoutSessionsNestedInput
    formateurPrincipal?: PersonnelUpdateOneRequiredWithoutSessionsFMPAFormateurNestedInput
    formateursAdditionnels?: SessionFMPAFormateurUpdateManyWithoutSessionNestedInput
    inscriptions?: InscriptionFMPAUpdateManyWithoutSessionNestedInput
    signatures?: SignatureFMPAUpdateManyWithoutSessionNestedInput
    exportsTTA?: ExportTTAUpdateManyWithoutSessionNestedInput
  }

  export type SessionFMPAUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeFMPAId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    formateurPrincipalId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formateursAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutSessionNestedInput
    inscriptions?: InscriptionFMPAUncheckedUpdateManyWithoutSessionNestedInput
    signatures?: SignatureFMPAUncheckedUpdateManyWithoutSessionNestedInput
    exportsTTA?: ExportTTAUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionFMPACreateManyInput = {
    id?: number
    typeFMPAId: number
    centreId?: number | null
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    formateurPrincipalId: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionFMPAUpdateManyMutationInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionFMPAUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeFMPAId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    formateurPrincipalId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionFMPAFormateurCreateInput = {
    session: SessionFMPACreateNestedOneWithoutFormateursAdditionnelsInput
    personnel: PersonnelCreateNestedOneWithoutSessionsFMPAAdditionnelsInput
  }

  export type SessionFMPAFormateurUncheckedCreateInput = {
    sessionId: number
    personnelId: number
  }

  export type SessionFMPAFormateurUpdateInput = {
    session?: SessionFMPAUpdateOneRequiredWithoutFormateursAdditionnelsNestedInput
    personnel?: PersonnelUpdateOneRequiredWithoutSessionsFMPAAdditionnelsNestedInput
  }

  export type SessionFMPAFormateurUncheckedUpdateInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionFMPAFormateurCreateManyInput = {
    sessionId: number
    personnelId: number
  }

  export type SessionFMPAFormateurUpdateManyMutationInput = {

  }

  export type SessionFMPAFormateurUncheckedUpdateManyInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
  }

  export type InscriptionFMPACreateInput = {
    dateInscription?: Date | string
    statutInscription?: $Enums.StatutInscription
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    signatureElectronique?: string | null
    dateSignature?: Date | string | null
    noteEvaluation?: number | null
    acquis?: boolean | null
    commentaireFormateur?: string | null
    heuresValidees?: number | null
    montantTTA?: number | null
    exportePaie?: boolean
    dateExportPaie?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: SessionFMPACreateNestedOneWithoutInscriptionsInput
    personnel: PersonnelCreateNestedOneWithoutInscriptionsFMPAInput
  }

  export type InscriptionFMPAUncheckedCreateInput = {
    id?: number
    sessionFMPAId: number
    personnelId: number
    dateInscription?: Date | string
    statutInscription?: $Enums.StatutInscription
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    signatureElectronique?: string | null
    dateSignature?: Date | string | null
    noteEvaluation?: number | null
    acquis?: boolean | null
    commentaireFormateur?: string | null
    heuresValidees?: number | null
    montantTTA?: number | null
    exportePaie?: boolean
    dateExportPaie?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InscriptionFMPAUpdateInput = {
    dateInscription?: DateTimeFieldUpdateOperationsInput | Date | string
    statutInscription?: EnumStatutInscriptionFieldUpdateOperationsInput | $Enums.StatutInscription
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureElectronique?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteEvaluation?: NullableFloatFieldUpdateOperationsInput | number | null
    acquis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commentaireFormateur?: NullableStringFieldUpdateOperationsInput | string | null
    heuresValidees?: NullableFloatFieldUpdateOperationsInput | number | null
    montantTTA?: NullableFloatFieldUpdateOperationsInput | number | null
    exportePaie?: BoolFieldUpdateOperationsInput | boolean
    dateExportPaie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionFMPAUpdateOneRequiredWithoutInscriptionsNestedInput
    personnel?: PersonnelUpdateOneRequiredWithoutInscriptionsFMPANestedInput
  }

  export type InscriptionFMPAUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionFMPAId?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    dateInscription?: DateTimeFieldUpdateOperationsInput | Date | string
    statutInscription?: EnumStatutInscriptionFieldUpdateOperationsInput | $Enums.StatutInscription
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureElectronique?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteEvaluation?: NullableFloatFieldUpdateOperationsInput | number | null
    acquis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commentaireFormateur?: NullableStringFieldUpdateOperationsInput | string | null
    heuresValidees?: NullableFloatFieldUpdateOperationsInput | number | null
    montantTTA?: NullableFloatFieldUpdateOperationsInput | number | null
    exportePaie?: BoolFieldUpdateOperationsInput | boolean
    dateExportPaie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InscriptionFMPACreateManyInput = {
    id?: number
    sessionFMPAId: number
    personnelId: number
    dateInscription?: Date | string
    statutInscription?: $Enums.StatutInscription
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    signatureElectronique?: string | null
    dateSignature?: Date | string | null
    noteEvaluation?: number | null
    acquis?: boolean | null
    commentaireFormateur?: string | null
    heuresValidees?: number | null
    montantTTA?: number | null
    exportePaie?: boolean
    dateExportPaie?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InscriptionFMPAUpdateManyMutationInput = {
    dateInscription?: DateTimeFieldUpdateOperationsInput | Date | string
    statutInscription?: EnumStatutInscriptionFieldUpdateOperationsInput | $Enums.StatutInscription
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureElectronique?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteEvaluation?: NullableFloatFieldUpdateOperationsInput | number | null
    acquis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commentaireFormateur?: NullableStringFieldUpdateOperationsInput | string | null
    heuresValidees?: NullableFloatFieldUpdateOperationsInput | number | null
    montantTTA?: NullableFloatFieldUpdateOperationsInput | number | null
    exportePaie?: BoolFieldUpdateOperationsInput | boolean
    dateExportPaie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InscriptionFMPAUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionFMPAId?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    dateInscription?: DateTimeFieldUpdateOperationsInput | Date | string
    statutInscription?: EnumStatutInscriptionFieldUpdateOperationsInput | $Enums.StatutInscription
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureElectronique?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteEvaluation?: NullableFloatFieldUpdateOperationsInput | number | null
    acquis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commentaireFormateur?: NullableStringFieldUpdateOperationsInput | string | null
    heuresValidees?: NullableFloatFieldUpdateOperationsInput | number | null
    montantTTA?: NullableFloatFieldUpdateOperationsInput | number | null
    exportePaie?: BoolFieldUpdateOperationsInput | boolean
    dateExportPaie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureFMPACreateInput = {
    id?: string
    type: string
    signature: string
    dateSignature?: Date | string
    session: SessionFMPACreateNestedOneWithoutSignaturesInput
    personnel: PersonnelCreateNestedOneWithoutSignaturesFMPAInput
  }

  export type SignatureFMPAUncheckedCreateInput = {
    id?: string
    sessionFMPAId: number
    personnelId: number
    type: string
    signature: string
    dateSignature?: Date | string
  }

  export type SignatureFMPAUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionFMPAUpdateOneRequiredWithoutSignaturesNestedInput
    personnel?: PersonnelUpdateOneRequiredWithoutSignaturesFMPANestedInput
  }

  export type SignatureFMPAUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionFMPAId?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureFMPACreateManyInput = {
    id?: string
    sessionFMPAId: number
    personnelId: number
    type: string
    signature: string
    dateSignature?: Date | string
  }

  export type SignatureFMPAUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureFMPAUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionFMPAId?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategorieMaterielCreateInput = {
    code: string
    libelle: string
    description?: string | null
    actif?: boolean
    materiels?: MaterielCreateNestedManyWithoutCategorieInput
  }

  export type CategorieMaterielUncheckedCreateInput = {
    id?: number
    code: string
    libelle: string
    description?: string | null
    actif?: boolean
    materiels?: MaterielUncheckedCreateNestedManyWithoutCategorieInput
  }

  export type CategorieMaterielUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    materiels?: MaterielUpdateManyWithoutCategorieNestedInput
  }

  export type CategorieMaterielUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    materiels?: MaterielUncheckedUpdateManyWithoutCategorieNestedInput
  }

  export type CategorieMaterielCreateManyInput = {
    id?: number
    code: string
    libelle: string
    description?: string | null
    actif?: boolean
  }

  export type CategorieMaterielUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CategorieMaterielUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MaterielCreateInput = {
    codeInventaire: string
    libelle: string
    marque?: string | null
    modele?: string | null
    numeroSerie?: string | null
    dateAcquisition?: Date | string | null
    dateMiseService?: Date | string | null
    dateReforme?: Date | string | null
    etat?: $Enums.EtatMateriel
    periodiciteControleJours?: number | null
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    localisation?: string | null
    valeurAchat?: number | null
    fournisseur?: string | null
    numeroMarche?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categorie: CategorieMaterielCreateNestedOneWithoutMaterielsInput
    centre?: CentreCreateNestedOneWithoutMaterielsInput
    responsable?: PersonnelCreateNestedOneWithoutMaterielsResponsableInput
    incidents?: IncidentMaterielCreateNestedManyWithoutMaterielInput
  }

  export type MaterielUncheckedCreateInput = {
    id?: number
    categorieId: number
    centreId?: number | null
    codeInventaire: string
    libelle: string
    marque?: string | null
    modele?: string | null
    numeroSerie?: string | null
    dateAcquisition?: Date | string | null
    dateMiseService?: Date | string | null
    dateReforme?: Date | string | null
    etat?: $Enums.EtatMateriel
    periodiciteControleJours?: number | null
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    localisation?: string | null
    responsableId?: number | null
    valeurAchat?: number | null
    fournisseur?: string | null
    numeroMarche?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    incidents?: IncidentMaterielUncheckedCreateNestedManyWithoutMaterielInput
  }

  export type MaterielUpdateInput = {
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categorie?: CategorieMaterielUpdateOneRequiredWithoutMaterielsNestedInput
    centre?: CentreUpdateOneWithoutMaterielsNestedInput
    responsable?: PersonnelUpdateOneWithoutMaterielsResponsableNestedInput
    incidents?: IncidentMaterielUpdateManyWithoutMaterielNestedInput
  }

  export type MaterielUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    categorieId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    responsableId?: NullableIntFieldUpdateOperationsInput | number | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incidents?: IncidentMaterielUncheckedUpdateManyWithoutMaterielNestedInput
  }

  export type MaterielCreateManyInput = {
    id?: number
    categorieId: number
    centreId?: number | null
    codeInventaire: string
    libelle: string
    marque?: string | null
    modele?: string | null
    numeroSerie?: string | null
    dateAcquisition?: Date | string | null
    dateMiseService?: Date | string | null
    dateReforme?: Date | string | null
    etat?: $Enums.EtatMateriel
    periodiciteControleJours?: number | null
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    localisation?: string | null
    responsableId?: number | null
    valeurAchat?: number | null
    fournisseur?: string | null
    numeroMarche?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterielUpdateManyMutationInput = {
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterielUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categorieId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    responsableId?: NullableIntFieldUpdateOperationsInput | number | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentMaterielCreateInput = {
    dateIncident?: Date | string
    typeIncident: $Enums.TypeIncident
    gravite: $Enums.GraviteIncident
    description: string
    photosUrls?: IncidentMaterielCreatephotosUrlsInput | string[]
    statut?: $Enums.StatutIncident
    dateResolution?: Date | string | null
    actionsCorrectives?: string | null
    coutReparation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materiel: MaterielCreateNestedOneWithoutIncidentsInput
    signalePar: PersonnelCreateNestedOneWithoutIncidentsSignalesInput
    traitePar?: PersonnelCreateNestedOneWithoutIncidentsTraitesInput
  }

  export type IncidentMaterielUncheckedCreateInput = {
    id?: number
    materielId: number
    signaleParId: number
    dateIncident?: Date | string
    typeIncident: $Enums.TypeIncident
    gravite: $Enums.GraviteIncident
    description: string
    photosUrls?: IncidentMaterielCreatephotosUrlsInput | string[]
    statut?: $Enums.StatutIncident
    traiteParId?: number | null
    dateResolution?: Date | string | null
    actionsCorrectives?: string | null
    coutReparation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentMaterielUpdateInput = {
    dateIncident?: DateTimeFieldUpdateOperationsInput | Date | string
    typeIncident?: EnumTypeIncidentFieldUpdateOperationsInput | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFieldUpdateOperationsInput | $Enums.GraviteIncident
    description?: StringFieldUpdateOperationsInput | string
    photosUrls?: IncidentMaterielUpdatephotosUrlsInput | string[]
    statut?: EnumStatutIncidentFieldUpdateOperationsInput | $Enums.StatutIncident
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionsCorrectives?: NullableStringFieldUpdateOperationsInput | string | null
    coutReparation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materiel?: MaterielUpdateOneRequiredWithoutIncidentsNestedInput
    signalePar?: PersonnelUpdateOneRequiredWithoutIncidentsSignalesNestedInput
    traitePar?: PersonnelUpdateOneWithoutIncidentsTraitesNestedInput
  }

  export type IncidentMaterielUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    materielId?: IntFieldUpdateOperationsInput | number
    signaleParId?: IntFieldUpdateOperationsInput | number
    dateIncident?: DateTimeFieldUpdateOperationsInput | Date | string
    typeIncident?: EnumTypeIncidentFieldUpdateOperationsInput | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFieldUpdateOperationsInput | $Enums.GraviteIncident
    description?: StringFieldUpdateOperationsInput | string
    photosUrls?: IncidentMaterielUpdatephotosUrlsInput | string[]
    statut?: EnumStatutIncidentFieldUpdateOperationsInput | $Enums.StatutIncident
    traiteParId?: NullableIntFieldUpdateOperationsInput | number | null
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionsCorrectives?: NullableStringFieldUpdateOperationsInput | string | null
    coutReparation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentMaterielCreateManyInput = {
    id?: number
    materielId: number
    signaleParId: number
    dateIncident?: Date | string
    typeIncident: $Enums.TypeIncident
    gravite: $Enums.GraviteIncident
    description: string
    photosUrls?: IncidentMaterielCreatephotosUrlsInput | string[]
    statut?: $Enums.StatutIncident
    traiteParId?: number | null
    dateResolution?: Date | string | null
    actionsCorrectives?: string | null
    coutReparation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentMaterielUpdateManyMutationInput = {
    dateIncident?: DateTimeFieldUpdateOperationsInput | Date | string
    typeIncident?: EnumTypeIncidentFieldUpdateOperationsInput | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFieldUpdateOperationsInput | $Enums.GraviteIncident
    description?: StringFieldUpdateOperationsInput | string
    photosUrls?: IncidentMaterielUpdatephotosUrlsInput | string[]
    statut?: EnumStatutIncidentFieldUpdateOperationsInput | $Enums.StatutIncident
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionsCorrectives?: NullableStringFieldUpdateOperationsInput | string | null
    coutReparation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentMaterielUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    materielId?: IntFieldUpdateOperationsInput | number
    signaleParId?: IntFieldUpdateOperationsInput | number
    dateIncident?: DateTimeFieldUpdateOperationsInput | Date | string
    typeIncident?: EnumTypeIncidentFieldUpdateOperationsInput | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFieldUpdateOperationsInput | $Enums.GraviteIncident
    description?: StringFieldUpdateOperationsInput | string
    photosUrls?: IncidentMaterielUpdatephotosUrlsInput | string[]
    statut?: EnumStatutIncidentFieldUpdateOperationsInput | $Enums.StatutIncident
    traiteParId?: NullableIntFieldUpdateOperationsInput | number | null
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionsCorrectives?: NullableStringFieldUpdateOperationsInput | string | null
    coutReparation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EPICreateInput = {
    typeEPI: string
    taille?: string | null
    numeroSerie?: string | null
    dateAttribution: Date | string
    datePeremption?: Date | string | null
    etat?: $Enums.EtatEPI
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personnel: PersonnelCreateNestedOneWithoutEpiInput
  }

  export type EPIUncheckedCreateInput = {
    id?: number
    personnelId: number
    typeEPI: string
    taille?: string | null
    numeroSerie?: string | null
    dateAttribution: Date | string
    datePeremption?: Date | string | null
    etat?: $Enums.EtatEPI
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EPIUpdateInput = {
    typeEPI?: StringFieldUpdateOperationsInput | string
    taille?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    datePeremption?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatEPIFieldUpdateOperationsInput | $Enums.EtatEPI
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnel?: PersonnelUpdateOneRequiredWithoutEpiNestedInput
  }

  export type EPIUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    typeEPI?: StringFieldUpdateOperationsInput | string
    taille?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    datePeremption?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatEPIFieldUpdateOperationsInput | $Enums.EtatEPI
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EPICreateManyInput = {
    id?: number
    personnelId: number
    typeEPI: string
    taille?: string | null
    numeroSerie?: string | null
    dateAttribution: Date | string
    datePeremption?: Date | string | null
    etat?: $Enums.EtatEPI
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EPIUpdateManyMutationInput = {
    typeEPI?: StringFieldUpdateOperationsInput | string
    taille?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    datePeremption?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatEPIFieldUpdateOperationsInput | $Enums.EtatEPI
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EPIUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    typeEPI?: StringFieldUpdateOperationsInput | string
    taille?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    datePeremption?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatEPIFieldUpdateOperationsInput | $Enums.EtatEPI
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    type: $Enums.TypeConversation
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: PersonnelCreateNestedOneWithoutConversationsCreeesInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: number
    type: $Enums.TypeConversation
    nom?: string | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    type?: EnumTypeConversationFieldUpdateOperationsInput | $Enums.TypeConversation
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: PersonnelUpdateOneRequiredWithoutConversationsCreeesNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTypeConversationFieldUpdateOperationsInput | $Enums.TypeConversation
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: number
    type: $Enums.TypeConversation
    nom?: string | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    type?: EnumTypeConversationFieldUpdateOperationsInput | $Enums.TypeConversation
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTypeConversationFieldUpdateOperationsInput | $Enums.TypeConversation
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateInput = {
    dateAjout?: Date | string
    dateSortie?: Date | string | null
    role?: $Enums.RoleConversation
    notificationsActives?: boolean
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
    personnel: PersonnelCreateNestedOneWithoutParticipationsInput
  }

  export type ConversationParticipantUncheckedCreateInput = {
    conversationId: number
    personnelId: number
    dateAjout?: Date | string
    dateSortie?: Date | string | null
    role?: $Enums.RoleConversation
    notificationsActives?: boolean
  }

  export type ConversationParticipantUpdateInput = {
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleConversationFieldUpdateOperationsInput | $Enums.RoleConversation
    notificationsActives?: BoolFieldUpdateOperationsInput | boolean
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
    personnel?: PersonnelUpdateOneRequiredWithoutParticipationsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateInput = {
    conversationId?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleConversationFieldUpdateOperationsInput | $Enums.RoleConversation
    notificationsActives?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConversationParticipantCreateManyInput = {
    conversationId: number
    personnelId: number
    dateAjout?: Date | string
    dateSortie?: Date | string | null
    role?: $Enums.RoleConversation
    notificationsActives?: boolean
  }

  export type ConversationParticipantUpdateManyMutationInput = {
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleConversationFieldUpdateOperationsInput | $Enums.RoleConversation
    notificationsActives?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConversationParticipantUncheckedUpdateManyInput = {
    conversationId?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleConversationFieldUpdateOperationsInput | $Enums.RoleConversation
    notificationsActives?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageCreateInput = {
    contenu: string
    typeMessage?: $Enums.TypeMessage
    fichierUrl?: string | null
    typeInteractif?: string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    expediteur: PersonnelCreateNestedOneWithoutMessagesEnvoyesInput
    messagesLus?: MessageLuCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    conversationId: number
    expediteurId: number
    contenu: string
    typeMessage?: $Enums.TypeMessage
    fichierUrl?: string | null
    typeInteractif?: string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    contenu?: StringFieldUpdateOperationsInput | string
    typeMessage?: EnumTypeMessageFieldUpdateOperationsInput | $Enums.TypeMessage
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeInteractif?: NullableStringFieldUpdateOperationsInput | string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    expediteur?: PersonnelUpdateOneRequiredWithoutMessagesEnvoyesNestedInput
    messagesLus?: MessageLuUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversationId?: IntFieldUpdateOperationsInput | number
    expediteurId?: IntFieldUpdateOperationsInput | number
    contenu?: StringFieldUpdateOperationsInput | string
    typeMessage?: EnumTypeMessageFieldUpdateOperationsInput | $Enums.TypeMessage
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeInteractif?: NullableStringFieldUpdateOperationsInput | string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messagesLus?: MessageLuUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: number
    conversationId: number
    expediteurId: number
    contenu: string
    typeMessage?: $Enums.TypeMessage
    fichierUrl?: string | null
    typeInteractif?: string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type MessageUpdateManyMutationInput = {
    contenu?: StringFieldUpdateOperationsInput | string
    typeMessage?: EnumTypeMessageFieldUpdateOperationsInput | $Enums.TypeMessage
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeInteractif?: NullableStringFieldUpdateOperationsInput | string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversationId?: IntFieldUpdateOperationsInput | number
    expediteurId?: IntFieldUpdateOperationsInput | number
    contenu?: StringFieldUpdateOperationsInput | string
    typeMessage?: EnumTypeMessageFieldUpdateOperationsInput | $Enums.TypeMessage
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeInteractif?: NullableStringFieldUpdateOperationsInput | string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageLuCreateInput = {
    dateLecture?: Date | string
    message: MessageCreateNestedOneWithoutMessagesLusInput
    personnel: PersonnelCreateNestedOneWithoutMessagesLusInput
  }

  export type MessageLuUncheckedCreateInput = {
    messageId: number
    personnelId: number
    dateLecture?: Date | string
  }

  export type MessageLuUpdateInput = {
    dateLecture?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutMessagesLusNestedInput
    personnel?: PersonnelUpdateOneRequiredWithoutMessagesLusNestedInput
  }

  export type MessageLuUncheckedUpdateInput = {
    messageId?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    dateLecture?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLuCreateManyInput = {
    messageId: number
    personnelId: number
    dateLecture?: Date | string
  }

  export type MessageLuUpdateManyMutationInput = {
    dateLecture?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLuUncheckedUpdateManyInput = {
    messageId?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    dateLecture?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    typeNotification: string
    titre: string
    message: string
    niveau?: $Enums.NiveauNotification
    entiteType?: string | null
    entiteId?: number | null
    donneesSupplementaires?: NullableJsonNullValueInput | InputJsonValue
    lue?: boolean
    dateLecture?: Date | string | null
    envoyeePush?: boolean
    envoyeeEmail?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
    destinataire: PersonnelCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    destinataireId: number
    typeNotification: string
    titre: string
    message: string
    niveau?: $Enums.NiveauNotification
    entiteType?: string | null
    entiteId?: number | null
    donneesSupplementaires?: NullableJsonNullValueInput | InputJsonValue
    lue?: boolean
    dateLecture?: Date | string | null
    envoyeePush?: boolean
    envoyeeEmail?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    typeNotification?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    niveau?: EnumNiveauNotificationFieldUpdateOperationsInput | $Enums.NiveauNotification
    entiteType?: NullableStringFieldUpdateOperationsInput | string | null
    entiteId?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSupplementaires?: NullableJsonNullValueInput | InputJsonValue
    lue?: BoolFieldUpdateOperationsInput | boolean
    dateLecture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    envoyeePush?: BoolFieldUpdateOperationsInput | boolean
    envoyeeEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    destinataire?: PersonnelUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    destinataireId?: IntFieldUpdateOperationsInput | number
    typeNotification?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    niveau?: EnumNiveauNotificationFieldUpdateOperationsInput | $Enums.NiveauNotification
    entiteType?: NullableStringFieldUpdateOperationsInput | string | null
    entiteId?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSupplementaires?: NullableJsonNullValueInput | InputJsonValue
    lue?: BoolFieldUpdateOperationsInput | boolean
    dateLecture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    envoyeePush?: BoolFieldUpdateOperationsInput | boolean
    envoyeeEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: number
    destinataireId: number
    typeNotification: string
    titre: string
    message: string
    niveau?: $Enums.NiveauNotification
    entiteType?: string | null
    entiteId?: number | null
    donneesSupplementaires?: NullableJsonNullValueInput | InputJsonValue
    lue?: boolean
    dateLecture?: Date | string | null
    envoyeePush?: boolean
    envoyeeEmail?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    typeNotification?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    niveau?: EnumNiveauNotificationFieldUpdateOperationsInput | $Enums.NiveauNotification
    entiteType?: NullableStringFieldUpdateOperationsInput | string | null
    entiteId?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSupplementaires?: NullableJsonNullValueInput | InputJsonValue
    lue?: BoolFieldUpdateOperationsInput | boolean
    dateLecture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    envoyeePush?: BoolFieldUpdateOperationsInput | boolean
    envoyeeEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    destinataireId?: IntFieldUpdateOperationsInput | number
    typeNotification?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    niveau?: EnumNiveauNotificationFieldUpdateOperationsInput | $Enums.NiveauNotification
    entiteType?: NullableStringFieldUpdateOperationsInput | string | null
    entiteId?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSupplementaires?: NullableJsonNullValueInput | InputJsonValue
    lue?: BoolFieldUpdateOperationsInput | boolean
    dateLecture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    envoyeePush?: BoolFieldUpdateOperationsInput | boolean
    envoyeeEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvenementCreateInput = {
    titre: string
    description?: string | null
    lieu?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    journeeEntiere?: boolean
    typeEvenement?: string | null
    visibilite?: $Enums.VisibiliteEvenement
    recurrent?: boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createur: PersonnelCreateNestedOneWithoutEvenementsCreeesInput
    centre?: CentreCreateNestedOneWithoutEvenementsInput
    participants?: EvenementParticipantCreateNestedManyWithoutEvenementInput
  }

  export type EvenementUncheckedCreateInput = {
    id?: number
    createurId: number
    centreId?: number | null
    titre: string
    description?: string | null
    lieu?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    journeeEntiere?: boolean
    typeEvenement?: string | null
    visibilite?: $Enums.VisibiliteEvenement
    recurrent?: boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: EvenementParticipantUncheckedCreateNestedManyWithoutEvenementInput
  }

  export type EvenementUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    journeeEntiere?: BoolFieldUpdateOperationsInput | boolean
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: EnumVisibiliteEvenementFieldUpdateOperationsInput | $Enums.VisibiliteEvenement
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: NullableStringFieldUpdateOperationsInput | string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createur?: PersonnelUpdateOneRequiredWithoutEvenementsCreeesNestedInput
    centre?: CentreUpdateOneWithoutEvenementsNestedInput
    participants?: EvenementParticipantUpdateManyWithoutEvenementNestedInput
  }

  export type EvenementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createurId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    journeeEntiere?: BoolFieldUpdateOperationsInput | boolean
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: EnumVisibiliteEvenementFieldUpdateOperationsInput | $Enums.VisibiliteEvenement
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: NullableStringFieldUpdateOperationsInput | string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: EvenementParticipantUncheckedUpdateManyWithoutEvenementNestedInput
  }

  export type EvenementCreateManyInput = {
    id?: number
    createurId: number
    centreId?: number | null
    titre: string
    description?: string | null
    lieu?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    journeeEntiere?: boolean
    typeEvenement?: string | null
    visibilite?: $Enums.VisibiliteEvenement
    recurrent?: boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvenementUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    journeeEntiere?: BoolFieldUpdateOperationsInput | boolean
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: EnumVisibiliteEvenementFieldUpdateOperationsInput | $Enums.VisibiliteEvenement
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: NullableStringFieldUpdateOperationsInput | string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvenementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createurId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    journeeEntiere?: BoolFieldUpdateOperationsInput | boolean
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: EnumVisibiliteEvenementFieldUpdateOperationsInput | $Enums.VisibiliteEvenement
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: NullableStringFieldUpdateOperationsInput | string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvenementParticipantCreateInput = {
    statutInvitation?: $Enums.StatutInvitation
    obligatoire?: boolean
    dateReponse?: Date | string | null
    commentaire?: string | null
    evenement: EvenementCreateNestedOneWithoutParticipantsInput
    personnel: PersonnelCreateNestedOneWithoutParticipationsEvenementsInput
  }

  export type EvenementParticipantUncheckedCreateInput = {
    evenementId: number
    personnelId: number
    statutInvitation?: $Enums.StatutInvitation
    obligatoire?: boolean
    dateReponse?: Date | string | null
    commentaire?: string | null
  }

  export type EvenementParticipantUpdateInput = {
    statutInvitation?: EnumStatutInvitationFieldUpdateOperationsInput | $Enums.StatutInvitation
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    dateReponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    evenement?: EvenementUpdateOneRequiredWithoutParticipantsNestedInput
    personnel?: PersonnelUpdateOneRequiredWithoutParticipationsEvenementsNestedInput
  }

  export type EvenementParticipantUncheckedUpdateInput = {
    evenementId?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    statutInvitation?: EnumStatutInvitationFieldUpdateOperationsInput | $Enums.StatutInvitation
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    dateReponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvenementParticipantCreateManyInput = {
    evenementId: number
    personnelId: number
    statutInvitation?: $Enums.StatutInvitation
    obligatoire?: boolean
    dateReponse?: Date | string | null
    commentaire?: string | null
  }

  export type EvenementParticipantUpdateManyMutationInput = {
    statutInvitation?: EnumStatutInvitationFieldUpdateOperationsInput | $Enums.StatutInvitation
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    dateReponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvenementParticipantUncheckedUpdateManyInput = {
    evenementId?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    statutInvitation?: EnumStatutInvitationFieldUpdateOperationsInput | $Enums.StatutInvitation
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    dateReponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExportTTACreateInput = {
    periodeDebut: Date | string
    periodeFin: Date | string
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
    centre?: CentreCreateNestedOneWithoutExportsTTAInput
    generePar: PersonnelCreateNestedOneWithoutExportsTTAGeneresInput
    validePar?: PersonnelCreateNestedOneWithoutExportsTTAValidesInput
    session?: SessionFMPACreateNestedOneWithoutExportsTTAInput
  }

  export type ExportTTAUncheckedCreateInput = {
    id?: number
    periodeDebut: Date | string
    periodeFin: Date | string
    centreId?: number | null
    genereParId: number
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    valideParId?: number | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
    sessionId?: number | null
  }

  export type ExportTTAUpdateInput = {
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    centre?: CentreUpdateOneWithoutExportsTTANestedInput
    generePar?: PersonnelUpdateOneRequiredWithoutExportsTTAGeneresNestedInput
    validePar?: PersonnelUpdateOneWithoutExportsTTAValidesNestedInput
    session?: SessionFMPAUpdateOneWithoutExportsTTANestedInput
  }

  export type ExportTTAUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    genereParId?: IntFieldUpdateOperationsInput | number
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valideParId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExportTTACreateManyInput = {
    id?: number
    periodeDebut: Date | string
    periodeFin: Date | string
    centreId?: number | null
    genereParId: number
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    valideParId?: number | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
    sessionId?: number | null
  }

  export type ExportTTAUpdateManyMutationInput = {
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExportTTAUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    genereParId?: IntFieldUpdateOperationsInput | number
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valideParId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entiteType: string
    entiteId?: number | null
    anciennesValeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvellesValeurs?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    utilisateur?: PersonnelCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    utilisateurId?: number | null
    action: string
    entiteType: string
    entiteId?: number | null
    anciennesValeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvellesValeurs?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entiteType?: StringFieldUpdateOperationsInput | string
    entiteId?: NullableIntFieldUpdateOperationsInput | number | null
    anciennesValeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvellesValeurs?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: PersonnelUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    entiteType?: StringFieldUpdateOperationsInput | string
    entiteId?: NullableIntFieldUpdateOperationsInput | number | null
    anciennesValeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvellesValeurs?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    utilisateurId?: number | null
    action: string
    entiteType: string
    entiteId?: number | null
    anciennesValeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvellesValeurs?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entiteType?: StringFieldUpdateOperationsInput | string
    entiteId?: NullableIntFieldUpdateOperationsInput | number | null
    anciennesValeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvellesValeurs?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    entiteType?: StringFieldUpdateOperationsInput | string
    entiteId?: NullableIntFieldUpdateOperationsInput | number | null
    anciennesValeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvellesValeurs?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumCategorieFilter<$PrismaModel = never> = {
    equals?: $Enums.Categorie | EnumCategorieFieldRefInput<$PrismaModel>
    in?: $Enums.Categorie[] | ListEnumCategorieFieldRefInput<$PrismaModel>
    notIn?: $Enums.Categorie[] | ListEnumCategorieFieldRefInput<$PrismaModel>
    not?: NestedEnumCategorieFilter<$PrismaModel> | $Enums.Categorie
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PersonnelListRelationFilter = {
    every?: PersonnelWhereInput
    some?: PersonnelWhereInput
    none?: PersonnelWhereInput
  }

  export type PersonnelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    categorie?: SortOrder
    ordreHierarchique?: SortOrder
    actif?: SortOrder
  }

  export type GradeAvgOrderByAggregateInput = {
    id?: SortOrder
    ordreHierarchique?: SortOrder
  }

  export type GradeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    categorie?: SortOrder
    ordreHierarchique?: SortOrder
    actif?: SortOrder
  }

  export type GradeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    categorie?: SortOrder
    ordreHierarchique?: SortOrder
    actif?: SortOrder
  }

  export type GradeSumOrderByAggregateInput = {
    id?: SortOrder
    ordreHierarchique?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumCategorieWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Categorie | EnumCategorieFieldRefInput<$PrismaModel>
    in?: $Enums.Categorie[] | ListEnumCategorieFieldRefInput<$PrismaModel>
    notIn?: $Enums.Categorie[] | ListEnumCategorieFieldRefInput<$PrismaModel>
    not?: NestedEnumCategorieWithAggregatesFilter<$PrismaModel> | $Enums.Categorie
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategorieFilter<$PrismaModel>
    _max?: NestedEnumCategorieFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumTypeCentreFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeCentre | EnumTypeCentreFieldRefInput<$PrismaModel>
    in?: $Enums.TypeCentre[] | ListEnumTypeCentreFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeCentre[] | ListEnumTypeCentreFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeCentreFilter<$PrismaModel> | $Enums.TypeCentre
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionFMPAListRelationFilter = {
    every?: SessionFMPAWhereInput
    some?: SessionFMPAWhereInput
    none?: SessionFMPAWhereInput
  }

  export type MaterielListRelationFilter = {
    every?: MaterielWhereInput
    some?: MaterielWhereInput
    none?: MaterielWhereInput
  }

  export type EvenementListRelationFilter = {
    every?: EvenementWhereInput
    some?: EvenementWhereInput
    none?: EvenementWhereInput
  }

  export type ExportTTAListRelationFilter = {
    every?: ExportTTAWhereInput
    some?: ExportTTAWhereInput
    none?: ExportTTAWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionFMPAOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterielOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvenementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExportTTAOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CentreCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    adresse?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CentreAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CentreMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    adresse?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CentreMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    adresse?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CentreSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTypeCentreWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeCentre | EnumTypeCentreFieldRefInput<$PrismaModel>
    in?: $Enums.TypeCentre[] | ListEnumTypeCentreFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeCentre[] | ListEnumTypeCentreFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeCentreWithAggregatesFilter<$PrismaModel> | $Enums.TypeCentre
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeCentreFilter<$PrismaModel>
    _max?: NestedEnumTypeCentreFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumSexeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexe | EnumSexeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexeNullableFilter<$PrismaModel> | $Enums.Sexe | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumStatutPersonnelFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutPersonnel | EnumStatutPersonnelFieldRefInput<$PrismaModel>
    in?: $Enums.StatutPersonnel[] | ListEnumStatutPersonnelFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutPersonnel[] | ListEnumStatutPersonnelFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutPersonnelFilter<$PrismaModel> | $Enums.StatutPersonnel
  }

  export type CentreNullableRelationFilter = {
    is?: CentreWhereInput | null
    isNot?: CentreWhereInput | null
  }

  export type GradeNullableRelationFilter = {
    is?: GradeWhereInput | null
    isNot?: GradeWhereInput | null
  }

  export type PersonnelRoleListRelationFilter = {
    every?: PersonnelRoleWhereInput
    some?: PersonnelRoleWhereInput
    none?: PersonnelRoleWhereInput
  }

  export type PersonnelCompetenceListRelationFilter = {
    every?: PersonnelCompetenceWhereInput
    some?: PersonnelCompetenceWhereInput
    none?: PersonnelCompetenceWhereInput
  }

  export type AptitudeMedicaleListRelationFilter = {
    every?: AptitudeMedicaleWhereInput
    some?: AptitudeMedicaleWhereInput
    none?: AptitudeMedicaleWhereInput
  }

  export type InscriptionFMPAListRelationFilter = {
    every?: InscriptionFMPAWhereInput
    some?: InscriptionFMPAWhereInput
    none?: InscriptionFMPAWhereInput
  }

  export type SessionFMPAFormateurListRelationFilter = {
    every?: SessionFMPAFormateurWhereInput
    some?: SessionFMPAFormateurWhereInput
    none?: SessionFMPAFormateurWhereInput
  }

  export type SignatureFMPAListRelationFilter = {
    every?: SignatureFMPAWhereInput
    some?: SignatureFMPAWhereInput
    none?: SignatureFMPAWhereInput
  }

  export type EPIListRelationFilter = {
    every?: EPIWhereInput
    some?: EPIWhereInput
    none?: EPIWhereInput
  }

  export type IncidentMaterielListRelationFilter = {
    every?: IncidentMaterielWhereInput
    some?: IncidentMaterielWhereInput
    none?: IncidentMaterielWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type ConversationParticipantListRelationFilter = {
    every?: ConversationParticipantWhereInput
    some?: ConversationParticipantWhereInput
    none?: ConversationParticipantWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageLuListRelationFilter = {
    every?: MessageLuWhereInput
    some?: MessageLuWhereInput
    none?: MessageLuWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type EvenementParticipantListRelationFilter = {
    every?: EvenementParticipantWhereInput
    some?: EvenementParticipantWhereInput
    none?: EvenementParticipantWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type PersonnelRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonnelCompetenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AptitudeMedicaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InscriptionFMPAOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionFMPAFormateurOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SignatureFMPAOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EPIOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentMaterielOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageLuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvenementParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonnelCountOrderByAggregateInput = {
    id?: SortOrder
    matricule?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrder
    sexe?: SortOrder
    email?: SortOrder
    telephoneMobile?: SortOrder
    telephoneFixe?: SortOrder
    adresse?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrder
    centreId?: SortOrder
    gradeId?: SortOrder
    categorie?: SortOrder
    dateEngagement?: SortOrder
    dateFinEngagement?: SortOrder
    statut?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrder
    lastLogin?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PersonnelAvgOrderByAggregateInput = {
    id?: SortOrder
    centreId?: SortOrder
    gradeId?: SortOrder
  }

  export type PersonnelMaxOrderByAggregateInput = {
    id?: SortOrder
    matricule?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrder
    sexe?: SortOrder
    email?: SortOrder
    telephoneMobile?: SortOrder
    telephoneFixe?: SortOrder
    adresse?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrder
    centreId?: SortOrder
    gradeId?: SortOrder
    categorie?: SortOrder
    dateEngagement?: SortOrder
    dateFinEngagement?: SortOrder
    statut?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrder
    lastLogin?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PersonnelMinOrderByAggregateInput = {
    id?: SortOrder
    matricule?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrder
    sexe?: SortOrder
    email?: SortOrder
    telephoneMobile?: SortOrder
    telephoneFixe?: SortOrder
    adresse?: SortOrder
    ville?: SortOrder
    codePostal?: SortOrder
    centreId?: SortOrder
    gradeId?: SortOrder
    categorie?: SortOrder
    dateEngagement?: SortOrder
    dateFinEngagement?: SortOrder
    statut?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrder
    lastLogin?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PersonnelSumOrderByAggregateInput = {
    id?: SortOrder
    centreId?: SortOrder
    gradeId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumSexeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexe | EnumSexeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sexe | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSexeNullableFilter<$PrismaModel>
    _max?: NestedEnumSexeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumStatutPersonnelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutPersonnel | EnumStatutPersonnelFieldRefInput<$PrismaModel>
    in?: $Enums.StatutPersonnel[] | ListEnumStatutPersonnelFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutPersonnel[] | ListEnumStatutPersonnelFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutPersonnelWithAggregatesFilter<$PrismaModel> | $Enums.StatutPersonnel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutPersonnelFilter<$PrismaModel>
    _max?: NestedEnumStatutPersonnelFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    permissions?: SortOrder
    actif?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    actif?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    actif?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type PersonnelRelationFilter = {
    is?: PersonnelWhereInput
    isNot?: PersonnelWhereInput
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PersonnelRolePersonnelIdRoleIdCompoundUniqueInput = {
    personnelId: number
    roleId: number
  }

  export type PersonnelRoleCountOrderByAggregateInput = {
    personnelId?: SortOrder
    roleId?: SortOrder
    dateAttribution?: SortOrder
    dateFin?: SortOrder
  }

  export type PersonnelRoleAvgOrderByAggregateInput = {
    personnelId?: SortOrder
    roleId?: SortOrder
  }

  export type PersonnelRoleMaxOrderByAggregateInput = {
    personnelId?: SortOrder
    roleId?: SortOrder
    dateAttribution?: SortOrder
    dateFin?: SortOrder
  }

  export type PersonnelRoleMinOrderByAggregateInput = {
    personnelId?: SortOrder
    roleId?: SortOrder
    dateAttribution?: SortOrder
    dateFin?: SortOrder
  }

  export type PersonnelRoleSumOrderByAggregateInput = {
    personnelId?: SortOrder
    roleId?: SortOrder
  }

  export type TypeCompetenceCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    dureeValiditeMois?: SortOrder
    actif?: SortOrder
  }

  export type TypeCompetenceAvgOrderByAggregateInput = {
    id?: SortOrder
    dureeValiditeMois?: SortOrder
  }

  export type TypeCompetenceMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    dureeValiditeMois?: SortOrder
    actif?: SortOrder
  }

  export type TypeCompetenceMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    dureeValiditeMois?: SortOrder
    actif?: SortOrder
  }

  export type TypeCompetenceSumOrderByAggregateInput = {
    id?: SortOrder
    dureeValiditeMois?: SortOrder
  }

  export type TypeCompetenceRelationFilter = {
    is?: TypeCompetenceWhereInput
    isNot?: TypeCompetenceWhereInput
  }

  export type PersonnelCompetencePersonnelIdTypeCompetenceIdDateObtentionCompoundUniqueInput = {
    personnelId: number
    typeCompetenceId: number
    dateObtention: Date | string
  }

  export type PersonnelCompetenceCountOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
    typeCompetenceId?: SortOrder
    dateObtention?: SortOrder
    dateExpiration?: SortOrder
    niveau?: SortOrder
    numeroDiplome?: SortOrder
    organismeDelivrance?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
  }

  export type PersonnelCompetenceAvgOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
    typeCompetenceId?: SortOrder
  }

  export type PersonnelCompetenceMaxOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
    typeCompetenceId?: SortOrder
    dateObtention?: SortOrder
    dateExpiration?: SortOrder
    niveau?: SortOrder
    numeroDiplome?: SortOrder
    organismeDelivrance?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
  }

  export type PersonnelCompetenceMinOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
    typeCompetenceId?: SortOrder
    dateObtention?: SortOrder
    dateExpiration?: SortOrder
    niveau?: SortOrder
    numeroDiplome?: SortOrder
    organismeDelivrance?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
  }

  export type PersonnelCompetenceSumOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
    typeCompetenceId?: SortOrder
  }

  export type EnumStatutAptitudeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAptitude | EnumStatutAptitudeFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAptitude[] | ListEnumStatutAptitudeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutAptitude[] | ListEnumStatutAptitudeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutAptitudeFilter<$PrismaModel> | $Enums.StatutAptitude
  }

  export type AptitudeMedicaleCountOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
    dateVisite?: SortOrder
    dateProchaineVisite?: SortOrder
    aptitude?: SortOrder
    restrictions?: SortOrder
    medecin?: SortOrder
    commentaires?: SortOrder
    createdAt?: SortOrder
  }

  export type AptitudeMedicaleAvgOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
  }

  export type AptitudeMedicaleMaxOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
    dateVisite?: SortOrder
    dateProchaineVisite?: SortOrder
    aptitude?: SortOrder
    restrictions?: SortOrder
    medecin?: SortOrder
    commentaires?: SortOrder
    createdAt?: SortOrder
  }

  export type AptitudeMedicaleMinOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
    dateVisite?: SortOrder
    dateProchaineVisite?: SortOrder
    aptitude?: SortOrder
    restrictions?: SortOrder
    medecin?: SortOrder
    commentaires?: SortOrder
    createdAt?: SortOrder
  }

  export type AptitudeMedicaleSumOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
  }

  export type EnumStatutAptitudeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAptitude | EnumStatutAptitudeFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAptitude[] | ListEnumStatutAptitudeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutAptitude[] | ListEnumStatutAptitudeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutAptitudeWithAggregatesFilter<$PrismaModel> | $Enums.StatutAptitude
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutAptitudeFilter<$PrismaModel>
    _max?: NestedEnumStatutAptitudeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type TypeFMPACountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    dureeHeures?: SortOrder
    obligatoire?: SortOrder
    periodiciteMois?: SortOrder
    description?: SortOrder
    actif?: SortOrder
  }

  export type TypeFMPAAvgOrderByAggregateInput = {
    id?: SortOrder
    dureeHeures?: SortOrder
    periodiciteMois?: SortOrder
  }

  export type TypeFMPAMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    dureeHeures?: SortOrder
    obligatoire?: SortOrder
    periodiciteMois?: SortOrder
    description?: SortOrder
    actif?: SortOrder
  }

  export type TypeFMPAMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    dureeHeures?: SortOrder
    obligatoire?: SortOrder
    periodiciteMois?: SortOrder
    description?: SortOrder
    actif?: SortOrder
  }

  export type TypeFMPASumOrderByAggregateInput = {
    id?: SortOrder
    dureeHeures?: SortOrder
    periodiciteMois?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumStatutSessionFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutSession | EnumStatutSessionFieldRefInput<$PrismaModel>
    in?: $Enums.StatutSession[] | ListEnumStatutSessionFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutSession[] | ListEnumStatutSessionFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutSessionFilter<$PrismaModel> | $Enums.StatutSession
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TypeFMPARelationFilter = {
    is?: TypeFMPAWhereInput
    isNot?: TypeFMPAWhereInput
  }

  export type SessionFMPACountOrderByAggregateInput = {
    id?: SortOrder
    typeFMPAId?: SortOrder
    centreId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    lieu?: SortOrder
    nombrePlacesMax?: SortOrder
    nombreInscrits?: SortOrder
    formateurPrincipalId?: SortOrder
    statut?: SortOrder
    codeTTA?: SortOrder
    tauxHoraire?: SortOrder
    commentaires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionFMPAAvgOrderByAggregateInput = {
    id?: SortOrder
    typeFMPAId?: SortOrder
    centreId?: SortOrder
    nombrePlacesMax?: SortOrder
    nombreInscrits?: SortOrder
    formateurPrincipalId?: SortOrder
    tauxHoraire?: SortOrder
  }

  export type SessionFMPAMaxOrderByAggregateInput = {
    id?: SortOrder
    typeFMPAId?: SortOrder
    centreId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    lieu?: SortOrder
    nombrePlacesMax?: SortOrder
    nombreInscrits?: SortOrder
    formateurPrincipalId?: SortOrder
    statut?: SortOrder
    codeTTA?: SortOrder
    tauxHoraire?: SortOrder
    commentaires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionFMPAMinOrderByAggregateInput = {
    id?: SortOrder
    typeFMPAId?: SortOrder
    centreId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    lieu?: SortOrder
    nombrePlacesMax?: SortOrder
    nombreInscrits?: SortOrder
    formateurPrincipalId?: SortOrder
    statut?: SortOrder
    codeTTA?: SortOrder
    tauxHoraire?: SortOrder
    commentaires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionFMPASumOrderByAggregateInput = {
    id?: SortOrder
    typeFMPAId?: SortOrder
    centreId?: SortOrder
    nombrePlacesMax?: SortOrder
    nombreInscrits?: SortOrder
    formateurPrincipalId?: SortOrder
    tauxHoraire?: SortOrder
  }

  export type EnumStatutSessionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutSession | EnumStatutSessionFieldRefInput<$PrismaModel>
    in?: $Enums.StatutSession[] | ListEnumStatutSessionFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutSession[] | ListEnumStatutSessionFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutSessionWithAggregatesFilter<$PrismaModel> | $Enums.StatutSession
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutSessionFilter<$PrismaModel>
    _max?: NestedEnumStatutSessionFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SessionFMPARelationFilter = {
    is?: SessionFMPAWhereInput
    isNot?: SessionFMPAWhereInput
  }

  export type SessionFMPAFormateurSessionIdPersonnelIdCompoundUniqueInput = {
    sessionId: number
    personnelId: number
  }

  export type SessionFMPAFormateurCountOrderByAggregateInput = {
    sessionId?: SortOrder
    personnelId?: SortOrder
  }

  export type SessionFMPAFormateurAvgOrderByAggregateInput = {
    sessionId?: SortOrder
    personnelId?: SortOrder
  }

  export type SessionFMPAFormateurMaxOrderByAggregateInput = {
    sessionId?: SortOrder
    personnelId?: SortOrder
  }

  export type SessionFMPAFormateurMinOrderByAggregateInput = {
    sessionId?: SortOrder
    personnelId?: SortOrder
  }

  export type SessionFMPAFormateurSumOrderByAggregateInput = {
    sessionId?: SortOrder
    personnelId?: SortOrder
  }

  export type EnumStatutInscriptionFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutInscription | EnumStatutInscriptionFieldRefInput<$PrismaModel>
    in?: $Enums.StatutInscription[] | ListEnumStatutInscriptionFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutInscription[] | ListEnumStatutInscriptionFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutInscriptionFilter<$PrismaModel> | $Enums.StatutInscription
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type InscriptionFMPASessionFMPAIdPersonnelIdCompoundUniqueInput = {
    sessionFMPAId: number
    personnelId: number
  }

  export type InscriptionFMPACountOrderByAggregateInput = {
    id?: SortOrder
    sessionFMPAId?: SortOrder
    personnelId?: SortOrder
    dateInscription?: SortOrder
    statutInscription?: SortOrder
    heureArrivee?: SortOrder
    heureDepart?: SortOrder
    signatureElectronique?: SortOrder
    dateSignature?: SortOrder
    noteEvaluation?: SortOrder
    acquis?: SortOrder
    commentaireFormateur?: SortOrder
    heuresValidees?: SortOrder
    montantTTA?: SortOrder
    exportePaie?: SortOrder
    dateExportPaie?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InscriptionFMPAAvgOrderByAggregateInput = {
    id?: SortOrder
    sessionFMPAId?: SortOrder
    personnelId?: SortOrder
    noteEvaluation?: SortOrder
    heuresValidees?: SortOrder
    montantTTA?: SortOrder
  }

  export type InscriptionFMPAMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionFMPAId?: SortOrder
    personnelId?: SortOrder
    dateInscription?: SortOrder
    statutInscription?: SortOrder
    heureArrivee?: SortOrder
    heureDepart?: SortOrder
    signatureElectronique?: SortOrder
    dateSignature?: SortOrder
    noteEvaluation?: SortOrder
    acquis?: SortOrder
    commentaireFormateur?: SortOrder
    heuresValidees?: SortOrder
    montantTTA?: SortOrder
    exportePaie?: SortOrder
    dateExportPaie?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InscriptionFMPAMinOrderByAggregateInput = {
    id?: SortOrder
    sessionFMPAId?: SortOrder
    personnelId?: SortOrder
    dateInscription?: SortOrder
    statutInscription?: SortOrder
    heureArrivee?: SortOrder
    heureDepart?: SortOrder
    signatureElectronique?: SortOrder
    dateSignature?: SortOrder
    noteEvaluation?: SortOrder
    acquis?: SortOrder
    commentaireFormateur?: SortOrder
    heuresValidees?: SortOrder
    montantTTA?: SortOrder
    exportePaie?: SortOrder
    dateExportPaie?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InscriptionFMPASumOrderByAggregateInput = {
    id?: SortOrder
    sessionFMPAId?: SortOrder
    personnelId?: SortOrder
    noteEvaluation?: SortOrder
    heuresValidees?: SortOrder
    montantTTA?: SortOrder
  }

  export type EnumStatutInscriptionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutInscription | EnumStatutInscriptionFieldRefInput<$PrismaModel>
    in?: $Enums.StatutInscription[] | ListEnumStatutInscriptionFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutInscription[] | ListEnumStatutInscriptionFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutInscriptionWithAggregatesFilter<$PrismaModel> | $Enums.StatutInscription
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutInscriptionFilter<$PrismaModel>
    _max?: NestedEnumStatutInscriptionFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type SignatureFMPACountOrderByAggregateInput = {
    id?: SortOrder
    sessionFMPAId?: SortOrder
    personnelId?: SortOrder
    type?: SortOrder
    signature?: SortOrder
    dateSignature?: SortOrder
  }

  export type SignatureFMPAAvgOrderByAggregateInput = {
    sessionFMPAId?: SortOrder
    personnelId?: SortOrder
  }

  export type SignatureFMPAMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionFMPAId?: SortOrder
    personnelId?: SortOrder
    type?: SortOrder
    signature?: SortOrder
    dateSignature?: SortOrder
  }

  export type SignatureFMPAMinOrderByAggregateInput = {
    id?: SortOrder
    sessionFMPAId?: SortOrder
    personnelId?: SortOrder
    type?: SortOrder
    signature?: SortOrder
    dateSignature?: SortOrder
  }

  export type SignatureFMPASumOrderByAggregateInput = {
    sessionFMPAId?: SortOrder
    personnelId?: SortOrder
  }

  export type CategorieMaterielCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    actif?: SortOrder
  }

  export type CategorieMaterielAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategorieMaterielMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    actif?: SortOrder
  }

  export type CategorieMaterielMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    description?: SortOrder
    actif?: SortOrder
  }

  export type CategorieMaterielSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumEtatMaterielFilter<$PrismaModel = never> = {
    equals?: $Enums.EtatMateriel | EnumEtatMaterielFieldRefInput<$PrismaModel>
    in?: $Enums.EtatMateriel[] | ListEnumEtatMaterielFieldRefInput<$PrismaModel>
    notIn?: $Enums.EtatMateriel[] | ListEnumEtatMaterielFieldRefInput<$PrismaModel>
    not?: NestedEnumEtatMaterielFilter<$PrismaModel> | $Enums.EtatMateriel
  }

  export type CategorieMaterielRelationFilter = {
    is?: CategorieMaterielWhereInput
    isNot?: CategorieMaterielWhereInput
  }

  export type PersonnelNullableRelationFilter = {
    is?: PersonnelWhereInput | null
    isNot?: PersonnelWhereInput | null
  }

  export type MaterielCountOrderByAggregateInput = {
    id?: SortOrder
    categorieId?: SortOrder
    centreId?: SortOrder
    codeInventaire?: SortOrder
    libelle?: SortOrder
    marque?: SortOrder
    modele?: SortOrder
    numeroSerie?: SortOrder
    dateAcquisition?: SortOrder
    dateMiseService?: SortOrder
    dateReforme?: SortOrder
    etat?: SortOrder
    periodiciteControleJours?: SortOrder
    dateDernierControle?: SortOrder
    dateProchainControle?: SortOrder
    localisation?: SortOrder
    responsableId?: SortOrder
    valeurAchat?: SortOrder
    fournisseur?: SortOrder
    numeroMarche?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterielAvgOrderByAggregateInput = {
    id?: SortOrder
    categorieId?: SortOrder
    centreId?: SortOrder
    periodiciteControleJours?: SortOrder
    responsableId?: SortOrder
    valeurAchat?: SortOrder
  }

  export type MaterielMaxOrderByAggregateInput = {
    id?: SortOrder
    categorieId?: SortOrder
    centreId?: SortOrder
    codeInventaire?: SortOrder
    libelle?: SortOrder
    marque?: SortOrder
    modele?: SortOrder
    numeroSerie?: SortOrder
    dateAcquisition?: SortOrder
    dateMiseService?: SortOrder
    dateReforme?: SortOrder
    etat?: SortOrder
    periodiciteControleJours?: SortOrder
    dateDernierControle?: SortOrder
    dateProchainControle?: SortOrder
    localisation?: SortOrder
    responsableId?: SortOrder
    valeurAchat?: SortOrder
    fournisseur?: SortOrder
    numeroMarche?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterielMinOrderByAggregateInput = {
    id?: SortOrder
    categorieId?: SortOrder
    centreId?: SortOrder
    codeInventaire?: SortOrder
    libelle?: SortOrder
    marque?: SortOrder
    modele?: SortOrder
    numeroSerie?: SortOrder
    dateAcquisition?: SortOrder
    dateMiseService?: SortOrder
    dateReforme?: SortOrder
    etat?: SortOrder
    periodiciteControleJours?: SortOrder
    dateDernierControle?: SortOrder
    dateProchainControle?: SortOrder
    localisation?: SortOrder
    responsableId?: SortOrder
    valeurAchat?: SortOrder
    fournisseur?: SortOrder
    numeroMarche?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaterielSumOrderByAggregateInput = {
    id?: SortOrder
    categorieId?: SortOrder
    centreId?: SortOrder
    periodiciteControleJours?: SortOrder
    responsableId?: SortOrder
    valeurAchat?: SortOrder
  }

  export type EnumEtatMaterielWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EtatMateriel | EnumEtatMaterielFieldRefInput<$PrismaModel>
    in?: $Enums.EtatMateriel[] | ListEnumEtatMaterielFieldRefInput<$PrismaModel>
    notIn?: $Enums.EtatMateriel[] | ListEnumEtatMaterielFieldRefInput<$PrismaModel>
    not?: NestedEnumEtatMaterielWithAggregatesFilter<$PrismaModel> | $Enums.EtatMateriel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEtatMaterielFilter<$PrismaModel>
    _max?: NestedEnumEtatMaterielFilter<$PrismaModel>
  }

  export type EnumTypeIncidentFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeIncident | EnumTypeIncidentFieldRefInput<$PrismaModel>
    in?: $Enums.TypeIncident[] | ListEnumTypeIncidentFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeIncident[] | ListEnumTypeIncidentFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeIncidentFilter<$PrismaModel> | $Enums.TypeIncident
  }

  export type EnumGraviteIncidentFilter<$PrismaModel = never> = {
    equals?: $Enums.GraviteIncident | EnumGraviteIncidentFieldRefInput<$PrismaModel>
    in?: $Enums.GraviteIncident[] | ListEnumGraviteIncidentFieldRefInput<$PrismaModel>
    notIn?: $Enums.GraviteIncident[] | ListEnumGraviteIncidentFieldRefInput<$PrismaModel>
    not?: NestedEnumGraviteIncidentFilter<$PrismaModel> | $Enums.GraviteIncident
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumStatutIncidentFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutIncident | EnumStatutIncidentFieldRefInput<$PrismaModel>
    in?: $Enums.StatutIncident[] | ListEnumStatutIncidentFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutIncident[] | ListEnumStatutIncidentFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutIncidentFilter<$PrismaModel> | $Enums.StatutIncident
  }

  export type MaterielRelationFilter = {
    is?: MaterielWhereInput
    isNot?: MaterielWhereInput
  }

  export type IncidentMaterielCountOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    signaleParId?: SortOrder
    dateIncident?: SortOrder
    typeIncident?: SortOrder
    gravite?: SortOrder
    description?: SortOrder
    photosUrls?: SortOrder
    statut?: SortOrder
    traiteParId?: SortOrder
    dateResolution?: SortOrder
    actionsCorrectives?: SortOrder
    coutReparation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentMaterielAvgOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    signaleParId?: SortOrder
    traiteParId?: SortOrder
    coutReparation?: SortOrder
  }

  export type IncidentMaterielMaxOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    signaleParId?: SortOrder
    dateIncident?: SortOrder
    typeIncident?: SortOrder
    gravite?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    traiteParId?: SortOrder
    dateResolution?: SortOrder
    actionsCorrectives?: SortOrder
    coutReparation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentMaterielMinOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    signaleParId?: SortOrder
    dateIncident?: SortOrder
    typeIncident?: SortOrder
    gravite?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    traiteParId?: SortOrder
    dateResolution?: SortOrder
    actionsCorrectives?: SortOrder
    coutReparation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentMaterielSumOrderByAggregateInput = {
    id?: SortOrder
    materielId?: SortOrder
    signaleParId?: SortOrder
    traiteParId?: SortOrder
    coutReparation?: SortOrder
  }

  export type EnumTypeIncidentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeIncident | EnumTypeIncidentFieldRefInput<$PrismaModel>
    in?: $Enums.TypeIncident[] | ListEnumTypeIncidentFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeIncident[] | ListEnumTypeIncidentFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeIncidentWithAggregatesFilter<$PrismaModel> | $Enums.TypeIncident
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeIncidentFilter<$PrismaModel>
    _max?: NestedEnumTypeIncidentFilter<$PrismaModel>
  }

  export type EnumGraviteIncidentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GraviteIncident | EnumGraviteIncidentFieldRefInput<$PrismaModel>
    in?: $Enums.GraviteIncident[] | ListEnumGraviteIncidentFieldRefInput<$PrismaModel>
    notIn?: $Enums.GraviteIncident[] | ListEnumGraviteIncidentFieldRefInput<$PrismaModel>
    not?: NestedEnumGraviteIncidentWithAggregatesFilter<$PrismaModel> | $Enums.GraviteIncident
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGraviteIncidentFilter<$PrismaModel>
    _max?: NestedEnumGraviteIncidentFilter<$PrismaModel>
  }

  export type EnumStatutIncidentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutIncident | EnumStatutIncidentFieldRefInput<$PrismaModel>
    in?: $Enums.StatutIncident[] | ListEnumStatutIncidentFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutIncident[] | ListEnumStatutIncidentFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutIncidentWithAggregatesFilter<$PrismaModel> | $Enums.StatutIncident
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutIncidentFilter<$PrismaModel>
    _max?: NestedEnumStatutIncidentFilter<$PrismaModel>
  }

  export type EnumEtatEPIFilter<$PrismaModel = never> = {
    equals?: $Enums.EtatEPI | EnumEtatEPIFieldRefInput<$PrismaModel>
    in?: $Enums.EtatEPI[] | ListEnumEtatEPIFieldRefInput<$PrismaModel>
    notIn?: $Enums.EtatEPI[] | ListEnumEtatEPIFieldRefInput<$PrismaModel>
    not?: NestedEnumEtatEPIFilter<$PrismaModel> | $Enums.EtatEPI
  }

  export type EPICountOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
    typeEPI?: SortOrder
    taille?: SortOrder
    numeroSerie?: SortOrder
    dateAttribution?: SortOrder
    datePeremption?: SortOrder
    etat?: SortOrder
    dateDernierControle?: SortOrder
    dateProchainControle?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EPIAvgOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
  }

  export type EPIMaxOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
    typeEPI?: SortOrder
    taille?: SortOrder
    numeroSerie?: SortOrder
    dateAttribution?: SortOrder
    datePeremption?: SortOrder
    etat?: SortOrder
    dateDernierControle?: SortOrder
    dateProchainControle?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EPIMinOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
    typeEPI?: SortOrder
    taille?: SortOrder
    numeroSerie?: SortOrder
    dateAttribution?: SortOrder
    datePeremption?: SortOrder
    etat?: SortOrder
    dateDernierControle?: SortOrder
    dateProchainControle?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EPISumOrderByAggregateInput = {
    id?: SortOrder
    personnelId?: SortOrder
  }

  export type EnumEtatEPIWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EtatEPI | EnumEtatEPIFieldRefInput<$PrismaModel>
    in?: $Enums.EtatEPI[] | ListEnumEtatEPIFieldRefInput<$PrismaModel>
    notIn?: $Enums.EtatEPI[] | ListEnumEtatEPIFieldRefInput<$PrismaModel>
    not?: NestedEnumEtatEPIWithAggregatesFilter<$PrismaModel> | $Enums.EtatEPI
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEtatEPIFilter<$PrismaModel>
    _max?: NestedEnumEtatEPIFilter<$PrismaModel>
  }

  export type EnumTypeConversationFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeConversation | EnumTypeConversationFieldRefInput<$PrismaModel>
    in?: $Enums.TypeConversation[] | ListEnumTypeConversationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeConversation[] | ListEnumTypeConversationFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeConversationFilter<$PrismaModel> | $Enums.TypeConversation
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    nom?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    nom?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    nom?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type EnumTypeConversationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeConversation | EnumTypeConversationFieldRefInput<$PrismaModel>
    in?: $Enums.TypeConversation[] | ListEnumTypeConversationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeConversation[] | ListEnumTypeConversationFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeConversationWithAggregatesFilter<$PrismaModel> | $Enums.TypeConversation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeConversationFilter<$PrismaModel>
    _max?: NestedEnumTypeConversationFilter<$PrismaModel>
  }

  export type EnumRoleConversationFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleConversation | EnumRoleConversationFieldRefInput<$PrismaModel>
    in?: $Enums.RoleConversation[] | ListEnumRoleConversationFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleConversation[] | ListEnumRoleConversationFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleConversationFilter<$PrismaModel> | $Enums.RoleConversation
  }

  export type ConversationRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type ConversationParticipantConversationIdPersonnelIdCompoundUniqueInput = {
    conversationId: number
    personnelId: number
  }

  export type ConversationParticipantCountOrderByAggregateInput = {
    conversationId?: SortOrder
    personnelId?: SortOrder
    dateAjout?: SortOrder
    dateSortie?: SortOrder
    role?: SortOrder
    notificationsActives?: SortOrder
  }

  export type ConversationParticipantAvgOrderByAggregateInput = {
    conversationId?: SortOrder
    personnelId?: SortOrder
  }

  export type ConversationParticipantMaxOrderByAggregateInput = {
    conversationId?: SortOrder
    personnelId?: SortOrder
    dateAjout?: SortOrder
    dateSortie?: SortOrder
    role?: SortOrder
    notificationsActives?: SortOrder
  }

  export type ConversationParticipantMinOrderByAggregateInput = {
    conversationId?: SortOrder
    personnelId?: SortOrder
    dateAjout?: SortOrder
    dateSortie?: SortOrder
    role?: SortOrder
    notificationsActives?: SortOrder
  }

  export type ConversationParticipantSumOrderByAggregateInput = {
    conversationId?: SortOrder
    personnelId?: SortOrder
  }

  export type EnumRoleConversationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleConversation | EnumRoleConversationFieldRefInput<$PrismaModel>
    in?: $Enums.RoleConversation[] | ListEnumRoleConversationFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleConversation[] | ListEnumRoleConversationFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleConversationWithAggregatesFilter<$PrismaModel> | $Enums.RoleConversation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleConversationFilter<$PrismaModel>
    _max?: NestedEnumRoleConversationFilter<$PrismaModel>
  }

  export type EnumTypeMessageFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMessage | EnumTypeMessageFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMessage[] | ListEnumTypeMessageFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMessage[] | ListEnumTypeMessageFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMessageFilter<$PrismaModel> | $Enums.TypeMessage
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    expediteurId?: SortOrder
    contenu?: SortOrder
    typeMessage?: SortOrder
    fichierUrl?: SortOrder
    typeInteractif?: SortOrder
    donneesInteractives?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    expediteurId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    expediteurId?: SortOrder
    contenu?: SortOrder
    typeMessage?: SortOrder
    fichierUrl?: SortOrder
    typeInteractif?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    expediteurId?: SortOrder
    contenu?: SortOrder
    typeMessage?: SortOrder
    fichierUrl?: SortOrder
    typeInteractif?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    expediteurId?: SortOrder
  }

  export type EnumTypeMessageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMessage | EnumTypeMessageFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMessage[] | ListEnumTypeMessageFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMessage[] | ListEnumTypeMessageFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMessageWithAggregatesFilter<$PrismaModel> | $Enums.TypeMessage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeMessageFilter<$PrismaModel>
    _max?: NestedEnumTypeMessageFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type MessageRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageLuMessageIdPersonnelIdCompoundUniqueInput = {
    messageId: number
    personnelId: number
  }

  export type MessageLuCountOrderByAggregateInput = {
    messageId?: SortOrder
    personnelId?: SortOrder
    dateLecture?: SortOrder
  }

  export type MessageLuAvgOrderByAggregateInput = {
    messageId?: SortOrder
    personnelId?: SortOrder
  }

  export type MessageLuMaxOrderByAggregateInput = {
    messageId?: SortOrder
    personnelId?: SortOrder
    dateLecture?: SortOrder
  }

  export type MessageLuMinOrderByAggregateInput = {
    messageId?: SortOrder
    personnelId?: SortOrder
    dateLecture?: SortOrder
  }

  export type MessageLuSumOrderByAggregateInput = {
    messageId?: SortOrder
    personnelId?: SortOrder
  }

  export type EnumNiveauNotificationFilter<$PrismaModel = never> = {
    equals?: $Enums.NiveauNotification | EnumNiveauNotificationFieldRefInput<$PrismaModel>
    in?: $Enums.NiveauNotification[] | ListEnumNiveauNotificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.NiveauNotification[] | ListEnumNiveauNotificationFieldRefInput<$PrismaModel>
    not?: NestedEnumNiveauNotificationFilter<$PrismaModel> | $Enums.NiveauNotification
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    destinataireId?: SortOrder
    typeNotification?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    niveau?: SortOrder
    entiteType?: SortOrder
    entiteId?: SortOrder
    donneesSupplementaires?: SortOrder
    lue?: SortOrder
    dateLecture?: SortOrder
    envoyeePush?: SortOrder
    envoyeeEmail?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    destinataireId?: SortOrder
    entiteId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    destinataireId?: SortOrder
    typeNotification?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    niveau?: SortOrder
    entiteType?: SortOrder
    entiteId?: SortOrder
    lue?: SortOrder
    dateLecture?: SortOrder
    envoyeePush?: SortOrder
    envoyeeEmail?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    destinataireId?: SortOrder
    typeNotification?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    niveau?: SortOrder
    entiteType?: SortOrder
    entiteId?: SortOrder
    lue?: SortOrder
    dateLecture?: SortOrder
    envoyeePush?: SortOrder
    envoyeeEmail?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    destinataireId?: SortOrder
    entiteId?: SortOrder
  }

  export type EnumNiveauNotificationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NiveauNotification | EnumNiveauNotificationFieldRefInput<$PrismaModel>
    in?: $Enums.NiveauNotification[] | ListEnumNiveauNotificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.NiveauNotification[] | ListEnumNiveauNotificationFieldRefInput<$PrismaModel>
    not?: NestedEnumNiveauNotificationWithAggregatesFilter<$PrismaModel> | $Enums.NiveauNotification
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNiveauNotificationFilter<$PrismaModel>
    _max?: NestedEnumNiveauNotificationFilter<$PrismaModel>
  }

  export type EnumVisibiliteEvenementFilter<$PrismaModel = never> = {
    equals?: $Enums.VisibiliteEvenement | EnumVisibiliteEvenementFieldRefInput<$PrismaModel>
    in?: $Enums.VisibiliteEvenement[] | ListEnumVisibiliteEvenementFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisibiliteEvenement[] | ListEnumVisibiliteEvenementFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibiliteEvenementFilter<$PrismaModel> | $Enums.VisibiliteEvenement
  }

  export type EvenementCountOrderByAggregateInput = {
    id?: SortOrder
    createurId?: SortOrder
    centreId?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    lieu?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    journeeEntiere?: SortOrder
    typeEvenement?: SortOrder
    visibilite?: SortOrder
    recurrent?: SortOrder
    patternRecurrence?: SortOrder
    couleur?: SortOrder
    rappels?: SortOrder
    annule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvenementAvgOrderByAggregateInput = {
    id?: SortOrder
    createurId?: SortOrder
    centreId?: SortOrder
  }

  export type EvenementMaxOrderByAggregateInput = {
    id?: SortOrder
    createurId?: SortOrder
    centreId?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    lieu?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    journeeEntiere?: SortOrder
    typeEvenement?: SortOrder
    visibilite?: SortOrder
    recurrent?: SortOrder
    couleur?: SortOrder
    annule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvenementMinOrderByAggregateInput = {
    id?: SortOrder
    createurId?: SortOrder
    centreId?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    lieu?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    journeeEntiere?: SortOrder
    typeEvenement?: SortOrder
    visibilite?: SortOrder
    recurrent?: SortOrder
    couleur?: SortOrder
    annule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvenementSumOrderByAggregateInput = {
    id?: SortOrder
    createurId?: SortOrder
    centreId?: SortOrder
  }

  export type EnumVisibiliteEvenementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisibiliteEvenement | EnumVisibiliteEvenementFieldRefInput<$PrismaModel>
    in?: $Enums.VisibiliteEvenement[] | ListEnumVisibiliteEvenementFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisibiliteEvenement[] | ListEnumVisibiliteEvenementFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibiliteEvenementWithAggregatesFilter<$PrismaModel> | $Enums.VisibiliteEvenement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibiliteEvenementFilter<$PrismaModel>
    _max?: NestedEnumVisibiliteEvenementFilter<$PrismaModel>
  }

  export type EnumStatutInvitationFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutInvitation | EnumStatutInvitationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutInvitation[] | ListEnumStatutInvitationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutInvitation[] | ListEnumStatutInvitationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutInvitationFilter<$PrismaModel> | $Enums.StatutInvitation
  }

  export type EvenementRelationFilter = {
    is?: EvenementWhereInput
    isNot?: EvenementWhereInput
  }

  export type EvenementParticipantEvenementIdPersonnelIdCompoundUniqueInput = {
    evenementId: number
    personnelId: number
  }

  export type EvenementParticipantCountOrderByAggregateInput = {
    evenementId?: SortOrder
    personnelId?: SortOrder
    statutInvitation?: SortOrder
    obligatoire?: SortOrder
    dateReponse?: SortOrder
    commentaire?: SortOrder
  }

  export type EvenementParticipantAvgOrderByAggregateInput = {
    evenementId?: SortOrder
    personnelId?: SortOrder
  }

  export type EvenementParticipantMaxOrderByAggregateInput = {
    evenementId?: SortOrder
    personnelId?: SortOrder
    statutInvitation?: SortOrder
    obligatoire?: SortOrder
    dateReponse?: SortOrder
    commentaire?: SortOrder
  }

  export type EvenementParticipantMinOrderByAggregateInput = {
    evenementId?: SortOrder
    personnelId?: SortOrder
    statutInvitation?: SortOrder
    obligatoire?: SortOrder
    dateReponse?: SortOrder
    commentaire?: SortOrder
  }

  export type EvenementParticipantSumOrderByAggregateInput = {
    evenementId?: SortOrder
    personnelId?: SortOrder
  }

  export type EnumStatutInvitationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutInvitation | EnumStatutInvitationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutInvitation[] | ListEnumStatutInvitationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutInvitation[] | ListEnumStatutInvitationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutInvitationWithAggregatesFilter<$PrismaModel> | $Enums.StatutInvitation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutInvitationFilter<$PrismaModel>
    _max?: NestedEnumStatutInvitationFilter<$PrismaModel>
  }

  export type EnumFormatExportFilter<$PrismaModel = never> = {
    equals?: $Enums.FormatExport | EnumFormatExportFieldRefInput<$PrismaModel>
    in?: $Enums.FormatExport[] | ListEnumFormatExportFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormatExport[] | ListEnumFormatExportFieldRefInput<$PrismaModel>
    not?: NestedEnumFormatExportFilter<$PrismaModel> | $Enums.FormatExport
  }

  export type EnumStatutExportFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutExport | EnumStatutExportFieldRefInput<$PrismaModel>
    in?: $Enums.StatutExport[] | ListEnumStatutExportFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutExport[] | ListEnumStatutExportFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutExportFilter<$PrismaModel> | $Enums.StatutExport
  }

  export type SessionFMPANullableRelationFilter = {
    is?: SessionFMPAWhereInput | null
    isNot?: SessionFMPAWhereInput | null
  }

  export type ExportTTACountOrderByAggregateInput = {
    id?: SortOrder
    periodeDebut?: SortOrder
    periodeFin?: SortOrder
    centreId?: SortOrder
    genereParId?: SortOrder
    dateGeneration?: SortOrder
    nombreLignes?: SortOrder
    montantTotal?: SortOrder
    fichierUrl?: SortOrder
    formatExport?: SortOrder
    statut?: SortOrder
    dateValidation?: SortOrder
    valideParId?: SortOrder
    dateTransmission?: SortOrder
    numeroBordereau?: SortOrder
    commentaires?: SortOrder
    sessionId?: SortOrder
  }

  export type ExportTTAAvgOrderByAggregateInput = {
    id?: SortOrder
    centreId?: SortOrder
    genereParId?: SortOrder
    nombreLignes?: SortOrder
    montantTotal?: SortOrder
    valideParId?: SortOrder
    sessionId?: SortOrder
  }

  export type ExportTTAMaxOrderByAggregateInput = {
    id?: SortOrder
    periodeDebut?: SortOrder
    periodeFin?: SortOrder
    centreId?: SortOrder
    genereParId?: SortOrder
    dateGeneration?: SortOrder
    nombreLignes?: SortOrder
    montantTotal?: SortOrder
    fichierUrl?: SortOrder
    formatExport?: SortOrder
    statut?: SortOrder
    dateValidation?: SortOrder
    valideParId?: SortOrder
    dateTransmission?: SortOrder
    numeroBordereau?: SortOrder
    commentaires?: SortOrder
    sessionId?: SortOrder
  }

  export type ExportTTAMinOrderByAggregateInput = {
    id?: SortOrder
    periodeDebut?: SortOrder
    periodeFin?: SortOrder
    centreId?: SortOrder
    genereParId?: SortOrder
    dateGeneration?: SortOrder
    nombreLignes?: SortOrder
    montantTotal?: SortOrder
    fichierUrl?: SortOrder
    formatExport?: SortOrder
    statut?: SortOrder
    dateValidation?: SortOrder
    valideParId?: SortOrder
    dateTransmission?: SortOrder
    numeroBordereau?: SortOrder
    commentaires?: SortOrder
    sessionId?: SortOrder
  }

  export type ExportTTASumOrderByAggregateInput = {
    id?: SortOrder
    centreId?: SortOrder
    genereParId?: SortOrder
    nombreLignes?: SortOrder
    montantTotal?: SortOrder
    valideParId?: SortOrder
    sessionId?: SortOrder
  }

  export type EnumFormatExportWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormatExport | EnumFormatExportFieldRefInput<$PrismaModel>
    in?: $Enums.FormatExport[] | ListEnumFormatExportFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormatExport[] | ListEnumFormatExportFieldRefInput<$PrismaModel>
    not?: NestedEnumFormatExportWithAggregatesFilter<$PrismaModel> | $Enums.FormatExport
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormatExportFilter<$PrismaModel>
    _max?: NestedEnumFormatExportFilter<$PrismaModel>
  }

  export type EnumStatutExportWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutExport | EnumStatutExportFieldRefInput<$PrismaModel>
    in?: $Enums.StatutExport[] | ListEnumStatutExportFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutExport[] | ListEnumStatutExportFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutExportWithAggregatesFilter<$PrismaModel> | $Enums.StatutExport
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutExportFilter<$PrismaModel>
    _max?: NestedEnumStatutExportFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    action?: SortOrder
    entiteType?: SortOrder
    entiteId?: SortOrder
    anciennesValeurs?: SortOrder
    nouvellesValeurs?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    utilisateurId?: SortOrder
    entiteId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    action?: SortOrder
    entiteType?: SortOrder
    entiteId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    action?: SortOrder
    entiteType?: SortOrder
    entiteId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    utilisateurId?: SortOrder
    entiteId?: SortOrder
  }

  export type PersonnelCreateNestedManyWithoutGradeInput = {
    create?: XOR<PersonnelCreateWithoutGradeInput, PersonnelUncheckedCreateWithoutGradeInput> | PersonnelCreateWithoutGradeInput[] | PersonnelUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutGradeInput | PersonnelCreateOrConnectWithoutGradeInput[]
    createMany?: PersonnelCreateManyGradeInputEnvelope
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
  }

  export type PersonnelUncheckedCreateNestedManyWithoutGradeInput = {
    create?: XOR<PersonnelCreateWithoutGradeInput, PersonnelUncheckedCreateWithoutGradeInput> | PersonnelCreateWithoutGradeInput[] | PersonnelUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutGradeInput | PersonnelCreateOrConnectWithoutGradeInput[]
    createMany?: PersonnelCreateManyGradeInputEnvelope
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumCategorieFieldUpdateOperationsInput = {
    set?: $Enums.Categorie
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PersonnelUpdateManyWithoutGradeNestedInput = {
    create?: XOR<PersonnelCreateWithoutGradeInput, PersonnelUncheckedCreateWithoutGradeInput> | PersonnelCreateWithoutGradeInput[] | PersonnelUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutGradeInput | PersonnelCreateOrConnectWithoutGradeInput[]
    upsert?: PersonnelUpsertWithWhereUniqueWithoutGradeInput | PersonnelUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: PersonnelCreateManyGradeInputEnvelope
    set?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    disconnect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    delete?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    update?: PersonnelUpdateWithWhereUniqueWithoutGradeInput | PersonnelUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: PersonnelUpdateManyWithWhereWithoutGradeInput | PersonnelUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: PersonnelScalarWhereInput | PersonnelScalarWhereInput[]
  }

  export type PersonnelUncheckedUpdateManyWithoutGradeNestedInput = {
    create?: XOR<PersonnelCreateWithoutGradeInput, PersonnelUncheckedCreateWithoutGradeInput> | PersonnelCreateWithoutGradeInput[] | PersonnelUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutGradeInput | PersonnelCreateOrConnectWithoutGradeInput[]
    upsert?: PersonnelUpsertWithWhereUniqueWithoutGradeInput | PersonnelUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: PersonnelCreateManyGradeInputEnvelope
    set?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    disconnect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    delete?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    update?: PersonnelUpdateWithWhereUniqueWithoutGradeInput | PersonnelUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: PersonnelUpdateManyWithWhereWithoutGradeInput | PersonnelUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: PersonnelScalarWhereInput | PersonnelScalarWhereInput[]
  }

  export type PersonnelCreateNestedManyWithoutCentreInput = {
    create?: XOR<PersonnelCreateWithoutCentreInput, PersonnelUncheckedCreateWithoutCentreInput> | PersonnelCreateWithoutCentreInput[] | PersonnelUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutCentreInput | PersonnelCreateOrConnectWithoutCentreInput[]
    createMany?: PersonnelCreateManyCentreInputEnvelope
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
  }

  export type SessionFMPACreateNestedManyWithoutCentreInput = {
    create?: XOR<SessionFMPACreateWithoutCentreInput, SessionFMPAUncheckedCreateWithoutCentreInput> | SessionFMPACreateWithoutCentreInput[] | SessionFMPAUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: SessionFMPACreateOrConnectWithoutCentreInput | SessionFMPACreateOrConnectWithoutCentreInput[]
    createMany?: SessionFMPACreateManyCentreInputEnvelope
    connect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
  }

  export type MaterielCreateNestedManyWithoutCentreInput = {
    create?: XOR<MaterielCreateWithoutCentreInput, MaterielUncheckedCreateWithoutCentreInput> | MaterielCreateWithoutCentreInput[] | MaterielUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: MaterielCreateOrConnectWithoutCentreInput | MaterielCreateOrConnectWithoutCentreInput[]
    createMany?: MaterielCreateManyCentreInputEnvelope
    connect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
  }

  export type EvenementCreateNestedManyWithoutCentreInput = {
    create?: XOR<EvenementCreateWithoutCentreInput, EvenementUncheckedCreateWithoutCentreInput> | EvenementCreateWithoutCentreInput[] | EvenementUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: EvenementCreateOrConnectWithoutCentreInput | EvenementCreateOrConnectWithoutCentreInput[]
    createMany?: EvenementCreateManyCentreInputEnvelope
    connect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
  }

  export type ExportTTACreateNestedManyWithoutCentreInput = {
    create?: XOR<ExportTTACreateWithoutCentreInput, ExportTTAUncheckedCreateWithoutCentreInput> | ExportTTACreateWithoutCentreInput[] | ExportTTAUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutCentreInput | ExportTTACreateOrConnectWithoutCentreInput[]
    createMany?: ExportTTACreateManyCentreInputEnvelope
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
  }

  export type PersonnelUncheckedCreateNestedManyWithoutCentreInput = {
    create?: XOR<PersonnelCreateWithoutCentreInput, PersonnelUncheckedCreateWithoutCentreInput> | PersonnelCreateWithoutCentreInput[] | PersonnelUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutCentreInput | PersonnelCreateOrConnectWithoutCentreInput[]
    createMany?: PersonnelCreateManyCentreInputEnvelope
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
  }

  export type SessionFMPAUncheckedCreateNestedManyWithoutCentreInput = {
    create?: XOR<SessionFMPACreateWithoutCentreInput, SessionFMPAUncheckedCreateWithoutCentreInput> | SessionFMPACreateWithoutCentreInput[] | SessionFMPAUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: SessionFMPACreateOrConnectWithoutCentreInput | SessionFMPACreateOrConnectWithoutCentreInput[]
    createMany?: SessionFMPACreateManyCentreInputEnvelope
    connect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
  }

  export type MaterielUncheckedCreateNestedManyWithoutCentreInput = {
    create?: XOR<MaterielCreateWithoutCentreInput, MaterielUncheckedCreateWithoutCentreInput> | MaterielCreateWithoutCentreInput[] | MaterielUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: MaterielCreateOrConnectWithoutCentreInput | MaterielCreateOrConnectWithoutCentreInput[]
    createMany?: MaterielCreateManyCentreInputEnvelope
    connect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
  }

  export type EvenementUncheckedCreateNestedManyWithoutCentreInput = {
    create?: XOR<EvenementCreateWithoutCentreInput, EvenementUncheckedCreateWithoutCentreInput> | EvenementCreateWithoutCentreInput[] | EvenementUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: EvenementCreateOrConnectWithoutCentreInput | EvenementCreateOrConnectWithoutCentreInput[]
    createMany?: EvenementCreateManyCentreInputEnvelope
    connect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
  }

  export type ExportTTAUncheckedCreateNestedManyWithoutCentreInput = {
    create?: XOR<ExportTTACreateWithoutCentreInput, ExportTTAUncheckedCreateWithoutCentreInput> | ExportTTACreateWithoutCentreInput[] | ExportTTAUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutCentreInput | ExportTTACreateOrConnectWithoutCentreInput[]
    createMany?: ExportTTACreateManyCentreInputEnvelope
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
  }

  export type EnumTypeCentreFieldUpdateOperationsInput = {
    set?: $Enums.TypeCentre
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PersonnelUpdateManyWithoutCentreNestedInput = {
    create?: XOR<PersonnelCreateWithoutCentreInput, PersonnelUncheckedCreateWithoutCentreInput> | PersonnelCreateWithoutCentreInput[] | PersonnelUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutCentreInput | PersonnelCreateOrConnectWithoutCentreInput[]
    upsert?: PersonnelUpsertWithWhereUniqueWithoutCentreInput | PersonnelUpsertWithWhereUniqueWithoutCentreInput[]
    createMany?: PersonnelCreateManyCentreInputEnvelope
    set?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    disconnect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    delete?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    update?: PersonnelUpdateWithWhereUniqueWithoutCentreInput | PersonnelUpdateWithWhereUniqueWithoutCentreInput[]
    updateMany?: PersonnelUpdateManyWithWhereWithoutCentreInput | PersonnelUpdateManyWithWhereWithoutCentreInput[]
    deleteMany?: PersonnelScalarWhereInput | PersonnelScalarWhereInput[]
  }

  export type SessionFMPAUpdateManyWithoutCentreNestedInput = {
    create?: XOR<SessionFMPACreateWithoutCentreInput, SessionFMPAUncheckedCreateWithoutCentreInput> | SessionFMPACreateWithoutCentreInput[] | SessionFMPAUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: SessionFMPACreateOrConnectWithoutCentreInput | SessionFMPACreateOrConnectWithoutCentreInput[]
    upsert?: SessionFMPAUpsertWithWhereUniqueWithoutCentreInput | SessionFMPAUpsertWithWhereUniqueWithoutCentreInput[]
    createMany?: SessionFMPACreateManyCentreInputEnvelope
    set?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    disconnect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    delete?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    connect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    update?: SessionFMPAUpdateWithWhereUniqueWithoutCentreInput | SessionFMPAUpdateWithWhereUniqueWithoutCentreInput[]
    updateMany?: SessionFMPAUpdateManyWithWhereWithoutCentreInput | SessionFMPAUpdateManyWithWhereWithoutCentreInput[]
    deleteMany?: SessionFMPAScalarWhereInput | SessionFMPAScalarWhereInput[]
  }

  export type MaterielUpdateManyWithoutCentreNestedInput = {
    create?: XOR<MaterielCreateWithoutCentreInput, MaterielUncheckedCreateWithoutCentreInput> | MaterielCreateWithoutCentreInput[] | MaterielUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: MaterielCreateOrConnectWithoutCentreInput | MaterielCreateOrConnectWithoutCentreInput[]
    upsert?: MaterielUpsertWithWhereUniqueWithoutCentreInput | MaterielUpsertWithWhereUniqueWithoutCentreInput[]
    createMany?: MaterielCreateManyCentreInputEnvelope
    set?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    disconnect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    delete?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    connect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    update?: MaterielUpdateWithWhereUniqueWithoutCentreInput | MaterielUpdateWithWhereUniqueWithoutCentreInput[]
    updateMany?: MaterielUpdateManyWithWhereWithoutCentreInput | MaterielUpdateManyWithWhereWithoutCentreInput[]
    deleteMany?: MaterielScalarWhereInput | MaterielScalarWhereInput[]
  }

  export type EvenementUpdateManyWithoutCentreNestedInput = {
    create?: XOR<EvenementCreateWithoutCentreInput, EvenementUncheckedCreateWithoutCentreInput> | EvenementCreateWithoutCentreInput[] | EvenementUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: EvenementCreateOrConnectWithoutCentreInput | EvenementCreateOrConnectWithoutCentreInput[]
    upsert?: EvenementUpsertWithWhereUniqueWithoutCentreInput | EvenementUpsertWithWhereUniqueWithoutCentreInput[]
    createMany?: EvenementCreateManyCentreInputEnvelope
    set?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    disconnect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    delete?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    connect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    update?: EvenementUpdateWithWhereUniqueWithoutCentreInput | EvenementUpdateWithWhereUniqueWithoutCentreInput[]
    updateMany?: EvenementUpdateManyWithWhereWithoutCentreInput | EvenementUpdateManyWithWhereWithoutCentreInput[]
    deleteMany?: EvenementScalarWhereInput | EvenementScalarWhereInput[]
  }

  export type ExportTTAUpdateManyWithoutCentreNestedInput = {
    create?: XOR<ExportTTACreateWithoutCentreInput, ExportTTAUncheckedCreateWithoutCentreInput> | ExportTTACreateWithoutCentreInput[] | ExportTTAUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutCentreInput | ExportTTACreateOrConnectWithoutCentreInput[]
    upsert?: ExportTTAUpsertWithWhereUniqueWithoutCentreInput | ExportTTAUpsertWithWhereUniqueWithoutCentreInput[]
    createMany?: ExportTTACreateManyCentreInputEnvelope
    set?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    disconnect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    delete?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    update?: ExportTTAUpdateWithWhereUniqueWithoutCentreInput | ExportTTAUpdateWithWhereUniqueWithoutCentreInput[]
    updateMany?: ExportTTAUpdateManyWithWhereWithoutCentreInput | ExportTTAUpdateManyWithWhereWithoutCentreInput[]
    deleteMany?: ExportTTAScalarWhereInput | ExportTTAScalarWhereInput[]
  }

  export type PersonnelUncheckedUpdateManyWithoutCentreNestedInput = {
    create?: XOR<PersonnelCreateWithoutCentreInput, PersonnelUncheckedCreateWithoutCentreInput> | PersonnelCreateWithoutCentreInput[] | PersonnelUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: PersonnelCreateOrConnectWithoutCentreInput | PersonnelCreateOrConnectWithoutCentreInput[]
    upsert?: PersonnelUpsertWithWhereUniqueWithoutCentreInput | PersonnelUpsertWithWhereUniqueWithoutCentreInput[]
    createMany?: PersonnelCreateManyCentreInputEnvelope
    set?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    disconnect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    delete?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    connect?: PersonnelWhereUniqueInput | PersonnelWhereUniqueInput[]
    update?: PersonnelUpdateWithWhereUniqueWithoutCentreInput | PersonnelUpdateWithWhereUniqueWithoutCentreInput[]
    updateMany?: PersonnelUpdateManyWithWhereWithoutCentreInput | PersonnelUpdateManyWithWhereWithoutCentreInput[]
    deleteMany?: PersonnelScalarWhereInput | PersonnelScalarWhereInput[]
  }

  export type SessionFMPAUncheckedUpdateManyWithoutCentreNestedInput = {
    create?: XOR<SessionFMPACreateWithoutCentreInput, SessionFMPAUncheckedCreateWithoutCentreInput> | SessionFMPACreateWithoutCentreInput[] | SessionFMPAUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: SessionFMPACreateOrConnectWithoutCentreInput | SessionFMPACreateOrConnectWithoutCentreInput[]
    upsert?: SessionFMPAUpsertWithWhereUniqueWithoutCentreInput | SessionFMPAUpsertWithWhereUniqueWithoutCentreInput[]
    createMany?: SessionFMPACreateManyCentreInputEnvelope
    set?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    disconnect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    delete?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    connect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    update?: SessionFMPAUpdateWithWhereUniqueWithoutCentreInput | SessionFMPAUpdateWithWhereUniqueWithoutCentreInput[]
    updateMany?: SessionFMPAUpdateManyWithWhereWithoutCentreInput | SessionFMPAUpdateManyWithWhereWithoutCentreInput[]
    deleteMany?: SessionFMPAScalarWhereInput | SessionFMPAScalarWhereInput[]
  }

  export type MaterielUncheckedUpdateManyWithoutCentreNestedInput = {
    create?: XOR<MaterielCreateWithoutCentreInput, MaterielUncheckedCreateWithoutCentreInput> | MaterielCreateWithoutCentreInput[] | MaterielUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: MaterielCreateOrConnectWithoutCentreInput | MaterielCreateOrConnectWithoutCentreInput[]
    upsert?: MaterielUpsertWithWhereUniqueWithoutCentreInput | MaterielUpsertWithWhereUniqueWithoutCentreInput[]
    createMany?: MaterielCreateManyCentreInputEnvelope
    set?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    disconnect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    delete?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    connect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    update?: MaterielUpdateWithWhereUniqueWithoutCentreInput | MaterielUpdateWithWhereUniqueWithoutCentreInput[]
    updateMany?: MaterielUpdateManyWithWhereWithoutCentreInput | MaterielUpdateManyWithWhereWithoutCentreInput[]
    deleteMany?: MaterielScalarWhereInput | MaterielScalarWhereInput[]
  }

  export type EvenementUncheckedUpdateManyWithoutCentreNestedInput = {
    create?: XOR<EvenementCreateWithoutCentreInput, EvenementUncheckedCreateWithoutCentreInput> | EvenementCreateWithoutCentreInput[] | EvenementUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: EvenementCreateOrConnectWithoutCentreInput | EvenementCreateOrConnectWithoutCentreInput[]
    upsert?: EvenementUpsertWithWhereUniqueWithoutCentreInput | EvenementUpsertWithWhereUniqueWithoutCentreInput[]
    createMany?: EvenementCreateManyCentreInputEnvelope
    set?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    disconnect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    delete?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    connect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    update?: EvenementUpdateWithWhereUniqueWithoutCentreInput | EvenementUpdateWithWhereUniqueWithoutCentreInput[]
    updateMany?: EvenementUpdateManyWithWhereWithoutCentreInput | EvenementUpdateManyWithWhereWithoutCentreInput[]
    deleteMany?: EvenementScalarWhereInput | EvenementScalarWhereInput[]
  }

  export type ExportTTAUncheckedUpdateManyWithoutCentreNestedInput = {
    create?: XOR<ExportTTACreateWithoutCentreInput, ExportTTAUncheckedCreateWithoutCentreInput> | ExportTTACreateWithoutCentreInput[] | ExportTTAUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutCentreInput | ExportTTACreateOrConnectWithoutCentreInput[]
    upsert?: ExportTTAUpsertWithWhereUniqueWithoutCentreInput | ExportTTAUpsertWithWhereUniqueWithoutCentreInput[]
    createMany?: ExportTTACreateManyCentreInputEnvelope
    set?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    disconnect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    delete?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    update?: ExportTTAUpdateWithWhereUniqueWithoutCentreInput | ExportTTAUpdateWithWhereUniqueWithoutCentreInput[]
    updateMany?: ExportTTAUpdateManyWithWhereWithoutCentreInput | ExportTTAUpdateManyWithWhereWithoutCentreInput[]
    deleteMany?: ExportTTAScalarWhereInput | ExportTTAScalarWhereInput[]
  }

  export type CentreCreateNestedOneWithoutPersonnelsInput = {
    create?: XOR<CentreCreateWithoutPersonnelsInput, CentreUncheckedCreateWithoutPersonnelsInput>
    connectOrCreate?: CentreCreateOrConnectWithoutPersonnelsInput
    connect?: CentreWhereUniqueInput
  }

  export type GradeCreateNestedOneWithoutPersonnelsInput = {
    create?: XOR<GradeCreateWithoutPersonnelsInput, GradeUncheckedCreateWithoutPersonnelsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutPersonnelsInput
    connect?: GradeWhereUniqueInput
  }

  export type PersonnelRoleCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<PersonnelRoleCreateWithoutPersonnelInput, PersonnelRoleUncheckedCreateWithoutPersonnelInput> | PersonnelRoleCreateWithoutPersonnelInput[] | PersonnelRoleUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: PersonnelRoleCreateOrConnectWithoutPersonnelInput | PersonnelRoleCreateOrConnectWithoutPersonnelInput[]
    createMany?: PersonnelRoleCreateManyPersonnelInputEnvelope
    connect?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
  }

  export type PersonnelCompetenceCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<PersonnelCompetenceCreateWithoutPersonnelInput, PersonnelCompetenceUncheckedCreateWithoutPersonnelInput> | PersonnelCompetenceCreateWithoutPersonnelInput[] | PersonnelCompetenceUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: PersonnelCompetenceCreateOrConnectWithoutPersonnelInput | PersonnelCompetenceCreateOrConnectWithoutPersonnelInput[]
    createMany?: PersonnelCompetenceCreateManyPersonnelInputEnvelope
    connect?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
  }

  export type AptitudeMedicaleCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<AptitudeMedicaleCreateWithoutPersonnelInput, AptitudeMedicaleUncheckedCreateWithoutPersonnelInput> | AptitudeMedicaleCreateWithoutPersonnelInput[] | AptitudeMedicaleUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: AptitudeMedicaleCreateOrConnectWithoutPersonnelInput | AptitudeMedicaleCreateOrConnectWithoutPersonnelInput[]
    createMany?: AptitudeMedicaleCreateManyPersonnelInputEnvelope
    connect?: AptitudeMedicaleWhereUniqueInput | AptitudeMedicaleWhereUniqueInput[]
  }

  export type InscriptionFMPACreateNestedManyWithoutPersonnelInput = {
    create?: XOR<InscriptionFMPACreateWithoutPersonnelInput, InscriptionFMPAUncheckedCreateWithoutPersonnelInput> | InscriptionFMPACreateWithoutPersonnelInput[] | InscriptionFMPAUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: InscriptionFMPACreateOrConnectWithoutPersonnelInput | InscriptionFMPACreateOrConnectWithoutPersonnelInput[]
    createMany?: InscriptionFMPACreateManyPersonnelInputEnvelope
    connect?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
  }

  export type SessionFMPACreateNestedManyWithoutFormateurPrincipalInput = {
    create?: XOR<SessionFMPACreateWithoutFormateurPrincipalInput, SessionFMPAUncheckedCreateWithoutFormateurPrincipalInput> | SessionFMPACreateWithoutFormateurPrincipalInput[] | SessionFMPAUncheckedCreateWithoutFormateurPrincipalInput[]
    connectOrCreate?: SessionFMPACreateOrConnectWithoutFormateurPrincipalInput | SessionFMPACreateOrConnectWithoutFormateurPrincipalInput[]
    createMany?: SessionFMPACreateManyFormateurPrincipalInputEnvelope
    connect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
  }

  export type SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<SessionFMPAFormateurCreateWithoutPersonnelInput, SessionFMPAFormateurUncheckedCreateWithoutPersonnelInput> | SessionFMPAFormateurCreateWithoutPersonnelInput[] | SessionFMPAFormateurUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: SessionFMPAFormateurCreateOrConnectWithoutPersonnelInput | SessionFMPAFormateurCreateOrConnectWithoutPersonnelInput[]
    createMany?: SessionFMPAFormateurCreateManyPersonnelInputEnvelope
    connect?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
  }

  export type SignatureFMPACreateNestedManyWithoutPersonnelInput = {
    create?: XOR<SignatureFMPACreateWithoutPersonnelInput, SignatureFMPAUncheckedCreateWithoutPersonnelInput> | SignatureFMPACreateWithoutPersonnelInput[] | SignatureFMPAUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: SignatureFMPACreateOrConnectWithoutPersonnelInput | SignatureFMPACreateOrConnectWithoutPersonnelInput[]
    createMany?: SignatureFMPACreateManyPersonnelInputEnvelope
    connect?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
  }

  export type EPICreateNestedManyWithoutPersonnelInput = {
    create?: XOR<EPICreateWithoutPersonnelInput, EPIUncheckedCreateWithoutPersonnelInput> | EPICreateWithoutPersonnelInput[] | EPIUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: EPICreateOrConnectWithoutPersonnelInput | EPICreateOrConnectWithoutPersonnelInput[]
    createMany?: EPICreateManyPersonnelInputEnvelope
    connect?: EPIWhereUniqueInput | EPIWhereUniqueInput[]
  }

  export type MaterielCreateNestedManyWithoutResponsableInput = {
    create?: XOR<MaterielCreateWithoutResponsableInput, MaterielUncheckedCreateWithoutResponsableInput> | MaterielCreateWithoutResponsableInput[] | MaterielUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: MaterielCreateOrConnectWithoutResponsableInput | MaterielCreateOrConnectWithoutResponsableInput[]
    createMany?: MaterielCreateManyResponsableInputEnvelope
    connect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
  }

  export type IncidentMaterielCreateNestedManyWithoutSignaleParInput = {
    create?: XOR<IncidentMaterielCreateWithoutSignaleParInput, IncidentMaterielUncheckedCreateWithoutSignaleParInput> | IncidentMaterielCreateWithoutSignaleParInput[] | IncidentMaterielUncheckedCreateWithoutSignaleParInput[]
    connectOrCreate?: IncidentMaterielCreateOrConnectWithoutSignaleParInput | IncidentMaterielCreateOrConnectWithoutSignaleParInput[]
    createMany?: IncidentMaterielCreateManySignaleParInputEnvelope
    connect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
  }

  export type IncidentMaterielCreateNestedManyWithoutTraiteParInput = {
    create?: XOR<IncidentMaterielCreateWithoutTraiteParInput, IncidentMaterielUncheckedCreateWithoutTraiteParInput> | IncidentMaterielCreateWithoutTraiteParInput[] | IncidentMaterielUncheckedCreateWithoutTraiteParInput[]
    connectOrCreate?: IncidentMaterielCreateOrConnectWithoutTraiteParInput | IncidentMaterielCreateOrConnectWithoutTraiteParInput[]
    createMany?: IncidentMaterielCreateManyTraiteParInputEnvelope
    connect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput> | ConversationCreateWithoutCreatedByInput[] | ConversationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatedByInput | ConversationCreateOrConnectWithoutCreatedByInput[]
    createMany?: ConversationCreateManyCreatedByInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationParticipantCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<ConversationParticipantCreateWithoutPersonnelInput, ConversationParticipantUncheckedCreateWithoutPersonnelInput> | ConversationParticipantCreateWithoutPersonnelInput[] | ConversationParticipantUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutPersonnelInput | ConversationParticipantCreateOrConnectWithoutPersonnelInput[]
    createMany?: ConversationParticipantCreateManyPersonnelInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutExpediteurInput = {
    create?: XOR<MessageCreateWithoutExpediteurInput, MessageUncheckedCreateWithoutExpediteurInput> | MessageCreateWithoutExpediteurInput[] | MessageUncheckedCreateWithoutExpediteurInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutExpediteurInput | MessageCreateOrConnectWithoutExpediteurInput[]
    createMany?: MessageCreateManyExpediteurInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageLuCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<MessageLuCreateWithoutPersonnelInput, MessageLuUncheckedCreateWithoutPersonnelInput> | MessageLuCreateWithoutPersonnelInput[] | MessageLuUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: MessageLuCreateOrConnectWithoutPersonnelInput | MessageLuCreateOrConnectWithoutPersonnelInput[]
    createMany?: MessageLuCreateManyPersonnelInputEnvelope
    connect?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutDestinataireInput = {
    create?: XOR<NotificationCreateWithoutDestinataireInput, NotificationUncheckedCreateWithoutDestinataireInput> | NotificationCreateWithoutDestinataireInput[] | NotificationUncheckedCreateWithoutDestinataireInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDestinataireInput | NotificationCreateOrConnectWithoutDestinataireInput[]
    createMany?: NotificationCreateManyDestinataireInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EvenementCreateNestedManyWithoutCreateurInput = {
    create?: XOR<EvenementCreateWithoutCreateurInput, EvenementUncheckedCreateWithoutCreateurInput> | EvenementCreateWithoutCreateurInput[] | EvenementUncheckedCreateWithoutCreateurInput[]
    connectOrCreate?: EvenementCreateOrConnectWithoutCreateurInput | EvenementCreateOrConnectWithoutCreateurInput[]
    createMany?: EvenementCreateManyCreateurInputEnvelope
    connect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
  }

  export type EvenementParticipantCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<EvenementParticipantCreateWithoutPersonnelInput, EvenementParticipantUncheckedCreateWithoutPersonnelInput> | EvenementParticipantCreateWithoutPersonnelInput[] | EvenementParticipantUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: EvenementParticipantCreateOrConnectWithoutPersonnelInput | EvenementParticipantCreateOrConnectWithoutPersonnelInput[]
    createMany?: EvenementParticipantCreateManyPersonnelInputEnvelope
    connect?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
  }

  export type ExportTTACreateNestedManyWithoutGenereParInput = {
    create?: XOR<ExportTTACreateWithoutGenereParInput, ExportTTAUncheckedCreateWithoutGenereParInput> | ExportTTACreateWithoutGenereParInput[] | ExportTTAUncheckedCreateWithoutGenereParInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutGenereParInput | ExportTTACreateOrConnectWithoutGenereParInput[]
    createMany?: ExportTTACreateManyGenereParInputEnvelope
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
  }

  export type ExportTTACreateNestedManyWithoutValideParInput = {
    create?: XOR<ExportTTACreateWithoutValideParInput, ExportTTAUncheckedCreateWithoutValideParInput> | ExportTTACreateWithoutValideParInput[] | ExportTTAUncheckedCreateWithoutValideParInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutValideParInput | ExportTTACreateOrConnectWithoutValideParInput[]
    createMany?: ExportTTACreateManyValideParInputEnvelope
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<AuditLogCreateWithoutUtilisateurInput, AuditLogUncheckedCreateWithoutUtilisateurInput> | AuditLogCreateWithoutUtilisateurInput[] | AuditLogUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUtilisateurInput | AuditLogCreateOrConnectWithoutUtilisateurInput[]
    createMany?: AuditLogCreateManyUtilisateurInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<PersonnelRoleCreateWithoutPersonnelInput, PersonnelRoleUncheckedCreateWithoutPersonnelInput> | PersonnelRoleCreateWithoutPersonnelInput[] | PersonnelRoleUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: PersonnelRoleCreateOrConnectWithoutPersonnelInput | PersonnelRoleCreateOrConnectWithoutPersonnelInput[]
    createMany?: PersonnelRoleCreateManyPersonnelInputEnvelope
    connect?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
  }

  export type PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<PersonnelCompetenceCreateWithoutPersonnelInput, PersonnelCompetenceUncheckedCreateWithoutPersonnelInput> | PersonnelCompetenceCreateWithoutPersonnelInput[] | PersonnelCompetenceUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: PersonnelCompetenceCreateOrConnectWithoutPersonnelInput | PersonnelCompetenceCreateOrConnectWithoutPersonnelInput[]
    createMany?: PersonnelCompetenceCreateManyPersonnelInputEnvelope
    connect?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
  }

  export type AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<AptitudeMedicaleCreateWithoutPersonnelInput, AptitudeMedicaleUncheckedCreateWithoutPersonnelInput> | AptitudeMedicaleCreateWithoutPersonnelInput[] | AptitudeMedicaleUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: AptitudeMedicaleCreateOrConnectWithoutPersonnelInput | AptitudeMedicaleCreateOrConnectWithoutPersonnelInput[]
    createMany?: AptitudeMedicaleCreateManyPersonnelInputEnvelope
    connect?: AptitudeMedicaleWhereUniqueInput | AptitudeMedicaleWhereUniqueInput[]
  }

  export type InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<InscriptionFMPACreateWithoutPersonnelInput, InscriptionFMPAUncheckedCreateWithoutPersonnelInput> | InscriptionFMPACreateWithoutPersonnelInput[] | InscriptionFMPAUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: InscriptionFMPACreateOrConnectWithoutPersonnelInput | InscriptionFMPACreateOrConnectWithoutPersonnelInput[]
    createMany?: InscriptionFMPACreateManyPersonnelInputEnvelope
    connect?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
  }

  export type SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput = {
    create?: XOR<SessionFMPACreateWithoutFormateurPrincipalInput, SessionFMPAUncheckedCreateWithoutFormateurPrincipalInput> | SessionFMPACreateWithoutFormateurPrincipalInput[] | SessionFMPAUncheckedCreateWithoutFormateurPrincipalInput[]
    connectOrCreate?: SessionFMPACreateOrConnectWithoutFormateurPrincipalInput | SessionFMPACreateOrConnectWithoutFormateurPrincipalInput[]
    createMany?: SessionFMPACreateManyFormateurPrincipalInputEnvelope
    connect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
  }

  export type SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<SessionFMPAFormateurCreateWithoutPersonnelInput, SessionFMPAFormateurUncheckedCreateWithoutPersonnelInput> | SessionFMPAFormateurCreateWithoutPersonnelInput[] | SessionFMPAFormateurUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: SessionFMPAFormateurCreateOrConnectWithoutPersonnelInput | SessionFMPAFormateurCreateOrConnectWithoutPersonnelInput[]
    createMany?: SessionFMPAFormateurCreateManyPersonnelInputEnvelope
    connect?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
  }

  export type SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<SignatureFMPACreateWithoutPersonnelInput, SignatureFMPAUncheckedCreateWithoutPersonnelInput> | SignatureFMPACreateWithoutPersonnelInput[] | SignatureFMPAUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: SignatureFMPACreateOrConnectWithoutPersonnelInput | SignatureFMPACreateOrConnectWithoutPersonnelInput[]
    createMany?: SignatureFMPACreateManyPersonnelInputEnvelope
    connect?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
  }

  export type EPIUncheckedCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<EPICreateWithoutPersonnelInput, EPIUncheckedCreateWithoutPersonnelInput> | EPICreateWithoutPersonnelInput[] | EPIUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: EPICreateOrConnectWithoutPersonnelInput | EPICreateOrConnectWithoutPersonnelInput[]
    createMany?: EPICreateManyPersonnelInputEnvelope
    connect?: EPIWhereUniqueInput | EPIWhereUniqueInput[]
  }

  export type MaterielUncheckedCreateNestedManyWithoutResponsableInput = {
    create?: XOR<MaterielCreateWithoutResponsableInput, MaterielUncheckedCreateWithoutResponsableInput> | MaterielCreateWithoutResponsableInput[] | MaterielUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: MaterielCreateOrConnectWithoutResponsableInput | MaterielCreateOrConnectWithoutResponsableInput[]
    createMany?: MaterielCreateManyResponsableInputEnvelope
    connect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
  }

  export type IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput = {
    create?: XOR<IncidentMaterielCreateWithoutSignaleParInput, IncidentMaterielUncheckedCreateWithoutSignaleParInput> | IncidentMaterielCreateWithoutSignaleParInput[] | IncidentMaterielUncheckedCreateWithoutSignaleParInput[]
    connectOrCreate?: IncidentMaterielCreateOrConnectWithoutSignaleParInput | IncidentMaterielCreateOrConnectWithoutSignaleParInput[]
    createMany?: IncidentMaterielCreateManySignaleParInputEnvelope
    connect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
  }

  export type IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput = {
    create?: XOR<IncidentMaterielCreateWithoutTraiteParInput, IncidentMaterielUncheckedCreateWithoutTraiteParInput> | IncidentMaterielCreateWithoutTraiteParInput[] | IncidentMaterielUncheckedCreateWithoutTraiteParInput[]
    connectOrCreate?: IncidentMaterielCreateOrConnectWithoutTraiteParInput | IncidentMaterielCreateOrConnectWithoutTraiteParInput[]
    createMany?: IncidentMaterielCreateManyTraiteParInputEnvelope
    connect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput> | ConversationCreateWithoutCreatedByInput[] | ConversationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatedByInput | ConversationCreateOrConnectWithoutCreatedByInput[]
    createMany?: ConversationCreateManyCreatedByInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<ConversationParticipantCreateWithoutPersonnelInput, ConversationParticipantUncheckedCreateWithoutPersonnelInput> | ConversationParticipantCreateWithoutPersonnelInput[] | ConversationParticipantUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutPersonnelInput | ConversationParticipantCreateOrConnectWithoutPersonnelInput[]
    createMany?: ConversationParticipantCreateManyPersonnelInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutExpediteurInput = {
    create?: XOR<MessageCreateWithoutExpediteurInput, MessageUncheckedCreateWithoutExpediteurInput> | MessageCreateWithoutExpediteurInput[] | MessageUncheckedCreateWithoutExpediteurInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutExpediteurInput | MessageCreateOrConnectWithoutExpediteurInput[]
    createMany?: MessageCreateManyExpediteurInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageLuUncheckedCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<MessageLuCreateWithoutPersonnelInput, MessageLuUncheckedCreateWithoutPersonnelInput> | MessageLuCreateWithoutPersonnelInput[] | MessageLuUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: MessageLuCreateOrConnectWithoutPersonnelInput | MessageLuCreateOrConnectWithoutPersonnelInput[]
    createMany?: MessageLuCreateManyPersonnelInputEnvelope
    connect?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutDestinataireInput = {
    create?: XOR<NotificationCreateWithoutDestinataireInput, NotificationUncheckedCreateWithoutDestinataireInput> | NotificationCreateWithoutDestinataireInput[] | NotificationUncheckedCreateWithoutDestinataireInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDestinataireInput | NotificationCreateOrConnectWithoutDestinataireInput[]
    createMany?: NotificationCreateManyDestinataireInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EvenementUncheckedCreateNestedManyWithoutCreateurInput = {
    create?: XOR<EvenementCreateWithoutCreateurInput, EvenementUncheckedCreateWithoutCreateurInput> | EvenementCreateWithoutCreateurInput[] | EvenementUncheckedCreateWithoutCreateurInput[]
    connectOrCreate?: EvenementCreateOrConnectWithoutCreateurInput | EvenementCreateOrConnectWithoutCreateurInput[]
    createMany?: EvenementCreateManyCreateurInputEnvelope
    connect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
  }

  export type EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput = {
    create?: XOR<EvenementParticipantCreateWithoutPersonnelInput, EvenementParticipantUncheckedCreateWithoutPersonnelInput> | EvenementParticipantCreateWithoutPersonnelInput[] | EvenementParticipantUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: EvenementParticipantCreateOrConnectWithoutPersonnelInput | EvenementParticipantCreateOrConnectWithoutPersonnelInput[]
    createMany?: EvenementParticipantCreateManyPersonnelInputEnvelope
    connect?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
  }

  export type ExportTTAUncheckedCreateNestedManyWithoutGenereParInput = {
    create?: XOR<ExportTTACreateWithoutGenereParInput, ExportTTAUncheckedCreateWithoutGenereParInput> | ExportTTACreateWithoutGenereParInput[] | ExportTTAUncheckedCreateWithoutGenereParInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutGenereParInput | ExportTTACreateOrConnectWithoutGenereParInput[]
    createMany?: ExportTTACreateManyGenereParInputEnvelope
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
  }

  export type ExportTTAUncheckedCreateNestedManyWithoutValideParInput = {
    create?: XOR<ExportTTACreateWithoutValideParInput, ExportTTAUncheckedCreateWithoutValideParInput> | ExportTTACreateWithoutValideParInput[] | ExportTTAUncheckedCreateWithoutValideParInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutValideParInput | ExportTTACreateOrConnectWithoutValideParInput[]
    createMany?: ExportTTACreateManyValideParInputEnvelope
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<AuditLogCreateWithoutUtilisateurInput, AuditLogUncheckedCreateWithoutUtilisateurInput> | AuditLogCreateWithoutUtilisateurInput[] | AuditLogUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUtilisateurInput | AuditLogCreateOrConnectWithoutUtilisateurInput[]
    createMany?: AuditLogCreateManyUtilisateurInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumSexeFieldUpdateOperationsInput = {
    set?: $Enums.Sexe | null
  }

  export type EnumStatutPersonnelFieldUpdateOperationsInput = {
    set?: $Enums.StatutPersonnel
  }

  export type CentreUpdateOneWithoutPersonnelsNestedInput = {
    create?: XOR<CentreCreateWithoutPersonnelsInput, CentreUncheckedCreateWithoutPersonnelsInput>
    connectOrCreate?: CentreCreateOrConnectWithoutPersonnelsInput
    upsert?: CentreUpsertWithoutPersonnelsInput
    disconnect?: CentreWhereInput | boolean
    delete?: CentreWhereInput | boolean
    connect?: CentreWhereUniqueInput
    update?: XOR<XOR<CentreUpdateToOneWithWhereWithoutPersonnelsInput, CentreUpdateWithoutPersonnelsInput>, CentreUncheckedUpdateWithoutPersonnelsInput>
  }

  export type GradeUpdateOneWithoutPersonnelsNestedInput = {
    create?: XOR<GradeCreateWithoutPersonnelsInput, GradeUncheckedCreateWithoutPersonnelsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutPersonnelsInput
    upsert?: GradeUpsertWithoutPersonnelsInput
    disconnect?: GradeWhereInput | boolean
    delete?: GradeWhereInput | boolean
    connect?: GradeWhereUniqueInput
    update?: XOR<XOR<GradeUpdateToOneWithWhereWithoutPersonnelsInput, GradeUpdateWithoutPersonnelsInput>, GradeUncheckedUpdateWithoutPersonnelsInput>
  }

  export type PersonnelRoleUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<PersonnelRoleCreateWithoutPersonnelInput, PersonnelRoleUncheckedCreateWithoutPersonnelInput> | PersonnelRoleCreateWithoutPersonnelInput[] | PersonnelRoleUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: PersonnelRoleCreateOrConnectWithoutPersonnelInput | PersonnelRoleCreateOrConnectWithoutPersonnelInput[]
    upsert?: PersonnelRoleUpsertWithWhereUniqueWithoutPersonnelInput | PersonnelRoleUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: PersonnelRoleCreateManyPersonnelInputEnvelope
    set?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    disconnect?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    delete?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    connect?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    update?: PersonnelRoleUpdateWithWhereUniqueWithoutPersonnelInput | PersonnelRoleUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: PersonnelRoleUpdateManyWithWhereWithoutPersonnelInput | PersonnelRoleUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: PersonnelRoleScalarWhereInput | PersonnelRoleScalarWhereInput[]
  }

  export type PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<PersonnelCompetenceCreateWithoutPersonnelInput, PersonnelCompetenceUncheckedCreateWithoutPersonnelInput> | PersonnelCompetenceCreateWithoutPersonnelInput[] | PersonnelCompetenceUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: PersonnelCompetenceCreateOrConnectWithoutPersonnelInput | PersonnelCompetenceCreateOrConnectWithoutPersonnelInput[]
    upsert?: PersonnelCompetenceUpsertWithWhereUniqueWithoutPersonnelInput | PersonnelCompetenceUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: PersonnelCompetenceCreateManyPersonnelInputEnvelope
    set?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    disconnect?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    delete?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    connect?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    update?: PersonnelCompetenceUpdateWithWhereUniqueWithoutPersonnelInput | PersonnelCompetenceUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: PersonnelCompetenceUpdateManyWithWhereWithoutPersonnelInput | PersonnelCompetenceUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: PersonnelCompetenceScalarWhereInput | PersonnelCompetenceScalarWhereInput[]
  }

  export type AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<AptitudeMedicaleCreateWithoutPersonnelInput, AptitudeMedicaleUncheckedCreateWithoutPersonnelInput> | AptitudeMedicaleCreateWithoutPersonnelInput[] | AptitudeMedicaleUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: AptitudeMedicaleCreateOrConnectWithoutPersonnelInput | AptitudeMedicaleCreateOrConnectWithoutPersonnelInput[]
    upsert?: AptitudeMedicaleUpsertWithWhereUniqueWithoutPersonnelInput | AptitudeMedicaleUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: AptitudeMedicaleCreateManyPersonnelInputEnvelope
    set?: AptitudeMedicaleWhereUniqueInput | AptitudeMedicaleWhereUniqueInput[]
    disconnect?: AptitudeMedicaleWhereUniqueInput | AptitudeMedicaleWhereUniqueInput[]
    delete?: AptitudeMedicaleWhereUniqueInput | AptitudeMedicaleWhereUniqueInput[]
    connect?: AptitudeMedicaleWhereUniqueInput | AptitudeMedicaleWhereUniqueInput[]
    update?: AptitudeMedicaleUpdateWithWhereUniqueWithoutPersonnelInput | AptitudeMedicaleUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: AptitudeMedicaleUpdateManyWithWhereWithoutPersonnelInput | AptitudeMedicaleUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: AptitudeMedicaleScalarWhereInput | AptitudeMedicaleScalarWhereInput[]
  }

  export type InscriptionFMPAUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<InscriptionFMPACreateWithoutPersonnelInput, InscriptionFMPAUncheckedCreateWithoutPersonnelInput> | InscriptionFMPACreateWithoutPersonnelInput[] | InscriptionFMPAUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: InscriptionFMPACreateOrConnectWithoutPersonnelInput | InscriptionFMPACreateOrConnectWithoutPersonnelInput[]
    upsert?: InscriptionFMPAUpsertWithWhereUniqueWithoutPersonnelInput | InscriptionFMPAUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: InscriptionFMPACreateManyPersonnelInputEnvelope
    set?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    disconnect?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    delete?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    connect?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    update?: InscriptionFMPAUpdateWithWhereUniqueWithoutPersonnelInput | InscriptionFMPAUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: InscriptionFMPAUpdateManyWithWhereWithoutPersonnelInput | InscriptionFMPAUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: InscriptionFMPAScalarWhereInput | InscriptionFMPAScalarWhereInput[]
  }

  export type SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput = {
    create?: XOR<SessionFMPACreateWithoutFormateurPrincipalInput, SessionFMPAUncheckedCreateWithoutFormateurPrincipalInput> | SessionFMPACreateWithoutFormateurPrincipalInput[] | SessionFMPAUncheckedCreateWithoutFormateurPrincipalInput[]
    connectOrCreate?: SessionFMPACreateOrConnectWithoutFormateurPrincipalInput | SessionFMPACreateOrConnectWithoutFormateurPrincipalInput[]
    upsert?: SessionFMPAUpsertWithWhereUniqueWithoutFormateurPrincipalInput | SessionFMPAUpsertWithWhereUniqueWithoutFormateurPrincipalInput[]
    createMany?: SessionFMPACreateManyFormateurPrincipalInputEnvelope
    set?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    disconnect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    delete?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    connect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    update?: SessionFMPAUpdateWithWhereUniqueWithoutFormateurPrincipalInput | SessionFMPAUpdateWithWhereUniqueWithoutFormateurPrincipalInput[]
    updateMany?: SessionFMPAUpdateManyWithWhereWithoutFormateurPrincipalInput | SessionFMPAUpdateManyWithWhereWithoutFormateurPrincipalInput[]
    deleteMany?: SessionFMPAScalarWhereInput | SessionFMPAScalarWhereInput[]
  }

  export type SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<SessionFMPAFormateurCreateWithoutPersonnelInput, SessionFMPAFormateurUncheckedCreateWithoutPersonnelInput> | SessionFMPAFormateurCreateWithoutPersonnelInput[] | SessionFMPAFormateurUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: SessionFMPAFormateurCreateOrConnectWithoutPersonnelInput | SessionFMPAFormateurCreateOrConnectWithoutPersonnelInput[]
    upsert?: SessionFMPAFormateurUpsertWithWhereUniqueWithoutPersonnelInput | SessionFMPAFormateurUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: SessionFMPAFormateurCreateManyPersonnelInputEnvelope
    set?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    disconnect?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    delete?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    connect?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    update?: SessionFMPAFormateurUpdateWithWhereUniqueWithoutPersonnelInput | SessionFMPAFormateurUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: SessionFMPAFormateurUpdateManyWithWhereWithoutPersonnelInput | SessionFMPAFormateurUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: SessionFMPAFormateurScalarWhereInput | SessionFMPAFormateurScalarWhereInput[]
  }

  export type SignatureFMPAUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<SignatureFMPACreateWithoutPersonnelInput, SignatureFMPAUncheckedCreateWithoutPersonnelInput> | SignatureFMPACreateWithoutPersonnelInput[] | SignatureFMPAUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: SignatureFMPACreateOrConnectWithoutPersonnelInput | SignatureFMPACreateOrConnectWithoutPersonnelInput[]
    upsert?: SignatureFMPAUpsertWithWhereUniqueWithoutPersonnelInput | SignatureFMPAUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: SignatureFMPACreateManyPersonnelInputEnvelope
    set?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    disconnect?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    delete?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    connect?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    update?: SignatureFMPAUpdateWithWhereUniqueWithoutPersonnelInput | SignatureFMPAUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: SignatureFMPAUpdateManyWithWhereWithoutPersonnelInput | SignatureFMPAUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: SignatureFMPAScalarWhereInput | SignatureFMPAScalarWhereInput[]
  }

  export type EPIUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<EPICreateWithoutPersonnelInput, EPIUncheckedCreateWithoutPersonnelInput> | EPICreateWithoutPersonnelInput[] | EPIUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: EPICreateOrConnectWithoutPersonnelInput | EPICreateOrConnectWithoutPersonnelInput[]
    upsert?: EPIUpsertWithWhereUniqueWithoutPersonnelInput | EPIUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: EPICreateManyPersonnelInputEnvelope
    set?: EPIWhereUniqueInput | EPIWhereUniqueInput[]
    disconnect?: EPIWhereUniqueInput | EPIWhereUniqueInput[]
    delete?: EPIWhereUniqueInput | EPIWhereUniqueInput[]
    connect?: EPIWhereUniqueInput | EPIWhereUniqueInput[]
    update?: EPIUpdateWithWhereUniqueWithoutPersonnelInput | EPIUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: EPIUpdateManyWithWhereWithoutPersonnelInput | EPIUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: EPIScalarWhereInput | EPIScalarWhereInput[]
  }

  export type MaterielUpdateManyWithoutResponsableNestedInput = {
    create?: XOR<MaterielCreateWithoutResponsableInput, MaterielUncheckedCreateWithoutResponsableInput> | MaterielCreateWithoutResponsableInput[] | MaterielUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: MaterielCreateOrConnectWithoutResponsableInput | MaterielCreateOrConnectWithoutResponsableInput[]
    upsert?: MaterielUpsertWithWhereUniqueWithoutResponsableInput | MaterielUpsertWithWhereUniqueWithoutResponsableInput[]
    createMany?: MaterielCreateManyResponsableInputEnvelope
    set?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    disconnect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    delete?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    connect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    update?: MaterielUpdateWithWhereUniqueWithoutResponsableInput | MaterielUpdateWithWhereUniqueWithoutResponsableInput[]
    updateMany?: MaterielUpdateManyWithWhereWithoutResponsableInput | MaterielUpdateManyWithWhereWithoutResponsableInput[]
    deleteMany?: MaterielScalarWhereInput | MaterielScalarWhereInput[]
  }

  export type IncidentMaterielUpdateManyWithoutSignaleParNestedInput = {
    create?: XOR<IncidentMaterielCreateWithoutSignaleParInput, IncidentMaterielUncheckedCreateWithoutSignaleParInput> | IncidentMaterielCreateWithoutSignaleParInput[] | IncidentMaterielUncheckedCreateWithoutSignaleParInput[]
    connectOrCreate?: IncidentMaterielCreateOrConnectWithoutSignaleParInput | IncidentMaterielCreateOrConnectWithoutSignaleParInput[]
    upsert?: IncidentMaterielUpsertWithWhereUniqueWithoutSignaleParInput | IncidentMaterielUpsertWithWhereUniqueWithoutSignaleParInput[]
    createMany?: IncidentMaterielCreateManySignaleParInputEnvelope
    set?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    disconnect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    delete?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    connect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    update?: IncidentMaterielUpdateWithWhereUniqueWithoutSignaleParInput | IncidentMaterielUpdateWithWhereUniqueWithoutSignaleParInput[]
    updateMany?: IncidentMaterielUpdateManyWithWhereWithoutSignaleParInput | IncidentMaterielUpdateManyWithWhereWithoutSignaleParInput[]
    deleteMany?: IncidentMaterielScalarWhereInput | IncidentMaterielScalarWhereInput[]
  }

  export type IncidentMaterielUpdateManyWithoutTraiteParNestedInput = {
    create?: XOR<IncidentMaterielCreateWithoutTraiteParInput, IncidentMaterielUncheckedCreateWithoutTraiteParInput> | IncidentMaterielCreateWithoutTraiteParInput[] | IncidentMaterielUncheckedCreateWithoutTraiteParInput[]
    connectOrCreate?: IncidentMaterielCreateOrConnectWithoutTraiteParInput | IncidentMaterielCreateOrConnectWithoutTraiteParInput[]
    upsert?: IncidentMaterielUpsertWithWhereUniqueWithoutTraiteParInput | IncidentMaterielUpsertWithWhereUniqueWithoutTraiteParInput[]
    createMany?: IncidentMaterielCreateManyTraiteParInputEnvelope
    set?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    disconnect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    delete?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    connect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    update?: IncidentMaterielUpdateWithWhereUniqueWithoutTraiteParInput | IncidentMaterielUpdateWithWhereUniqueWithoutTraiteParInput[]
    updateMany?: IncidentMaterielUpdateManyWithWhereWithoutTraiteParInput | IncidentMaterielUpdateManyWithWhereWithoutTraiteParInput[]
    deleteMany?: IncidentMaterielScalarWhereInput | IncidentMaterielScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput> | ConversationCreateWithoutCreatedByInput[] | ConversationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatedByInput | ConversationCreateOrConnectWithoutCreatedByInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutCreatedByInput | ConversationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ConversationCreateManyCreatedByInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutCreatedByInput | ConversationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutCreatedByInput | ConversationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationParticipantUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutPersonnelInput, ConversationParticipantUncheckedCreateWithoutPersonnelInput> | ConversationParticipantCreateWithoutPersonnelInput[] | ConversationParticipantUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutPersonnelInput | ConversationParticipantCreateOrConnectWithoutPersonnelInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutPersonnelInput | ConversationParticipantUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: ConversationParticipantCreateManyPersonnelInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutPersonnelInput | ConversationParticipantUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutPersonnelInput | ConversationParticipantUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutExpediteurNestedInput = {
    create?: XOR<MessageCreateWithoutExpediteurInput, MessageUncheckedCreateWithoutExpediteurInput> | MessageCreateWithoutExpediteurInput[] | MessageUncheckedCreateWithoutExpediteurInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutExpediteurInput | MessageCreateOrConnectWithoutExpediteurInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutExpediteurInput | MessageUpsertWithWhereUniqueWithoutExpediteurInput[]
    createMany?: MessageCreateManyExpediteurInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutExpediteurInput | MessageUpdateWithWhereUniqueWithoutExpediteurInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutExpediteurInput | MessageUpdateManyWithWhereWithoutExpediteurInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageLuUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<MessageLuCreateWithoutPersonnelInput, MessageLuUncheckedCreateWithoutPersonnelInput> | MessageLuCreateWithoutPersonnelInput[] | MessageLuUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: MessageLuCreateOrConnectWithoutPersonnelInput | MessageLuCreateOrConnectWithoutPersonnelInput[]
    upsert?: MessageLuUpsertWithWhereUniqueWithoutPersonnelInput | MessageLuUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: MessageLuCreateManyPersonnelInputEnvelope
    set?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    disconnect?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    delete?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    connect?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    update?: MessageLuUpdateWithWhereUniqueWithoutPersonnelInput | MessageLuUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: MessageLuUpdateManyWithWhereWithoutPersonnelInput | MessageLuUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: MessageLuScalarWhereInput | MessageLuScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutDestinataireNestedInput = {
    create?: XOR<NotificationCreateWithoutDestinataireInput, NotificationUncheckedCreateWithoutDestinataireInput> | NotificationCreateWithoutDestinataireInput[] | NotificationUncheckedCreateWithoutDestinataireInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDestinataireInput | NotificationCreateOrConnectWithoutDestinataireInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutDestinataireInput | NotificationUpsertWithWhereUniqueWithoutDestinataireInput[]
    createMany?: NotificationCreateManyDestinataireInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutDestinataireInput | NotificationUpdateWithWhereUniqueWithoutDestinataireInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutDestinataireInput | NotificationUpdateManyWithWhereWithoutDestinataireInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type EvenementUpdateManyWithoutCreateurNestedInput = {
    create?: XOR<EvenementCreateWithoutCreateurInput, EvenementUncheckedCreateWithoutCreateurInput> | EvenementCreateWithoutCreateurInput[] | EvenementUncheckedCreateWithoutCreateurInput[]
    connectOrCreate?: EvenementCreateOrConnectWithoutCreateurInput | EvenementCreateOrConnectWithoutCreateurInput[]
    upsert?: EvenementUpsertWithWhereUniqueWithoutCreateurInput | EvenementUpsertWithWhereUniqueWithoutCreateurInput[]
    createMany?: EvenementCreateManyCreateurInputEnvelope
    set?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    disconnect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    delete?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    connect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    update?: EvenementUpdateWithWhereUniqueWithoutCreateurInput | EvenementUpdateWithWhereUniqueWithoutCreateurInput[]
    updateMany?: EvenementUpdateManyWithWhereWithoutCreateurInput | EvenementUpdateManyWithWhereWithoutCreateurInput[]
    deleteMany?: EvenementScalarWhereInput | EvenementScalarWhereInput[]
  }

  export type EvenementParticipantUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<EvenementParticipantCreateWithoutPersonnelInput, EvenementParticipantUncheckedCreateWithoutPersonnelInput> | EvenementParticipantCreateWithoutPersonnelInput[] | EvenementParticipantUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: EvenementParticipantCreateOrConnectWithoutPersonnelInput | EvenementParticipantCreateOrConnectWithoutPersonnelInput[]
    upsert?: EvenementParticipantUpsertWithWhereUniqueWithoutPersonnelInput | EvenementParticipantUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: EvenementParticipantCreateManyPersonnelInputEnvelope
    set?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    disconnect?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    delete?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    connect?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    update?: EvenementParticipantUpdateWithWhereUniqueWithoutPersonnelInput | EvenementParticipantUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: EvenementParticipantUpdateManyWithWhereWithoutPersonnelInput | EvenementParticipantUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: EvenementParticipantScalarWhereInput | EvenementParticipantScalarWhereInput[]
  }

  export type ExportTTAUpdateManyWithoutGenereParNestedInput = {
    create?: XOR<ExportTTACreateWithoutGenereParInput, ExportTTAUncheckedCreateWithoutGenereParInput> | ExportTTACreateWithoutGenereParInput[] | ExportTTAUncheckedCreateWithoutGenereParInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutGenereParInput | ExportTTACreateOrConnectWithoutGenereParInput[]
    upsert?: ExportTTAUpsertWithWhereUniqueWithoutGenereParInput | ExportTTAUpsertWithWhereUniqueWithoutGenereParInput[]
    createMany?: ExportTTACreateManyGenereParInputEnvelope
    set?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    disconnect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    delete?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    update?: ExportTTAUpdateWithWhereUniqueWithoutGenereParInput | ExportTTAUpdateWithWhereUniqueWithoutGenereParInput[]
    updateMany?: ExportTTAUpdateManyWithWhereWithoutGenereParInput | ExportTTAUpdateManyWithWhereWithoutGenereParInput[]
    deleteMany?: ExportTTAScalarWhereInput | ExportTTAScalarWhereInput[]
  }

  export type ExportTTAUpdateManyWithoutValideParNestedInput = {
    create?: XOR<ExportTTACreateWithoutValideParInput, ExportTTAUncheckedCreateWithoutValideParInput> | ExportTTACreateWithoutValideParInput[] | ExportTTAUncheckedCreateWithoutValideParInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutValideParInput | ExportTTACreateOrConnectWithoutValideParInput[]
    upsert?: ExportTTAUpsertWithWhereUniqueWithoutValideParInput | ExportTTAUpsertWithWhereUniqueWithoutValideParInput[]
    createMany?: ExportTTACreateManyValideParInputEnvelope
    set?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    disconnect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    delete?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    update?: ExportTTAUpdateWithWhereUniqueWithoutValideParInput | ExportTTAUpdateWithWhereUniqueWithoutValideParInput[]
    updateMany?: ExportTTAUpdateManyWithWhereWithoutValideParInput | ExportTTAUpdateManyWithWhereWithoutValideParInput[]
    deleteMany?: ExportTTAScalarWhereInput | ExportTTAScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<AuditLogCreateWithoutUtilisateurInput, AuditLogUncheckedCreateWithoutUtilisateurInput> | AuditLogCreateWithoutUtilisateurInput[] | AuditLogUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUtilisateurInput | AuditLogCreateOrConnectWithoutUtilisateurInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUtilisateurInput | AuditLogUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: AuditLogCreateManyUtilisateurInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUtilisateurInput | AuditLogUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUtilisateurInput | AuditLogUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<PersonnelRoleCreateWithoutPersonnelInput, PersonnelRoleUncheckedCreateWithoutPersonnelInput> | PersonnelRoleCreateWithoutPersonnelInput[] | PersonnelRoleUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: PersonnelRoleCreateOrConnectWithoutPersonnelInput | PersonnelRoleCreateOrConnectWithoutPersonnelInput[]
    upsert?: PersonnelRoleUpsertWithWhereUniqueWithoutPersonnelInput | PersonnelRoleUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: PersonnelRoleCreateManyPersonnelInputEnvelope
    set?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    disconnect?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    delete?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    connect?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    update?: PersonnelRoleUpdateWithWhereUniqueWithoutPersonnelInput | PersonnelRoleUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: PersonnelRoleUpdateManyWithWhereWithoutPersonnelInput | PersonnelRoleUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: PersonnelRoleScalarWhereInput | PersonnelRoleScalarWhereInput[]
  }

  export type PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<PersonnelCompetenceCreateWithoutPersonnelInput, PersonnelCompetenceUncheckedCreateWithoutPersonnelInput> | PersonnelCompetenceCreateWithoutPersonnelInput[] | PersonnelCompetenceUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: PersonnelCompetenceCreateOrConnectWithoutPersonnelInput | PersonnelCompetenceCreateOrConnectWithoutPersonnelInput[]
    upsert?: PersonnelCompetenceUpsertWithWhereUniqueWithoutPersonnelInput | PersonnelCompetenceUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: PersonnelCompetenceCreateManyPersonnelInputEnvelope
    set?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    disconnect?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    delete?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    connect?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    update?: PersonnelCompetenceUpdateWithWhereUniqueWithoutPersonnelInput | PersonnelCompetenceUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: PersonnelCompetenceUpdateManyWithWhereWithoutPersonnelInput | PersonnelCompetenceUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: PersonnelCompetenceScalarWhereInput | PersonnelCompetenceScalarWhereInput[]
  }

  export type AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<AptitudeMedicaleCreateWithoutPersonnelInput, AptitudeMedicaleUncheckedCreateWithoutPersonnelInput> | AptitudeMedicaleCreateWithoutPersonnelInput[] | AptitudeMedicaleUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: AptitudeMedicaleCreateOrConnectWithoutPersonnelInput | AptitudeMedicaleCreateOrConnectWithoutPersonnelInput[]
    upsert?: AptitudeMedicaleUpsertWithWhereUniqueWithoutPersonnelInput | AptitudeMedicaleUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: AptitudeMedicaleCreateManyPersonnelInputEnvelope
    set?: AptitudeMedicaleWhereUniqueInput | AptitudeMedicaleWhereUniqueInput[]
    disconnect?: AptitudeMedicaleWhereUniqueInput | AptitudeMedicaleWhereUniqueInput[]
    delete?: AptitudeMedicaleWhereUniqueInput | AptitudeMedicaleWhereUniqueInput[]
    connect?: AptitudeMedicaleWhereUniqueInput | AptitudeMedicaleWhereUniqueInput[]
    update?: AptitudeMedicaleUpdateWithWhereUniqueWithoutPersonnelInput | AptitudeMedicaleUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: AptitudeMedicaleUpdateManyWithWhereWithoutPersonnelInput | AptitudeMedicaleUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: AptitudeMedicaleScalarWhereInput | AptitudeMedicaleScalarWhereInput[]
  }

  export type InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<InscriptionFMPACreateWithoutPersonnelInput, InscriptionFMPAUncheckedCreateWithoutPersonnelInput> | InscriptionFMPACreateWithoutPersonnelInput[] | InscriptionFMPAUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: InscriptionFMPACreateOrConnectWithoutPersonnelInput | InscriptionFMPACreateOrConnectWithoutPersonnelInput[]
    upsert?: InscriptionFMPAUpsertWithWhereUniqueWithoutPersonnelInput | InscriptionFMPAUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: InscriptionFMPACreateManyPersonnelInputEnvelope
    set?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    disconnect?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    delete?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    connect?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    update?: InscriptionFMPAUpdateWithWhereUniqueWithoutPersonnelInput | InscriptionFMPAUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: InscriptionFMPAUpdateManyWithWhereWithoutPersonnelInput | InscriptionFMPAUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: InscriptionFMPAScalarWhereInput | InscriptionFMPAScalarWhereInput[]
  }

  export type SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput = {
    create?: XOR<SessionFMPACreateWithoutFormateurPrincipalInput, SessionFMPAUncheckedCreateWithoutFormateurPrincipalInput> | SessionFMPACreateWithoutFormateurPrincipalInput[] | SessionFMPAUncheckedCreateWithoutFormateurPrincipalInput[]
    connectOrCreate?: SessionFMPACreateOrConnectWithoutFormateurPrincipalInput | SessionFMPACreateOrConnectWithoutFormateurPrincipalInput[]
    upsert?: SessionFMPAUpsertWithWhereUniqueWithoutFormateurPrincipalInput | SessionFMPAUpsertWithWhereUniqueWithoutFormateurPrincipalInput[]
    createMany?: SessionFMPACreateManyFormateurPrincipalInputEnvelope
    set?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    disconnect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    delete?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    connect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    update?: SessionFMPAUpdateWithWhereUniqueWithoutFormateurPrincipalInput | SessionFMPAUpdateWithWhereUniqueWithoutFormateurPrincipalInput[]
    updateMany?: SessionFMPAUpdateManyWithWhereWithoutFormateurPrincipalInput | SessionFMPAUpdateManyWithWhereWithoutFormateurPrincipalInput[]
    deleteMany?: SessionFMPAScalarWhereInput | SessionFMPAScalarWhereInput[]
  }

  export type SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<SessionFMPAFormateurCreateWithoutPersonnelInput, SessionFMPAFormateurUncheckedCreateWithoutPersonnelInput> | SessionFMPAFormateurCreateWithoutPersonnelInput[] | SessionFMPAFormateurUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: SessionFMPAFormateurCreateOrConnectWithoutPersonnelInput | SessionFMPAFormateurCreateOrConnectWithoutPersonnelInput[]
    upsert?: SessionFMPAFormateurUpsertWithWhereUniqueWithoutPersonnelInput | SessionFMPAFormateurUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: SessionFMPAFormateurCreateManyPersonnelInputEnvelope
    set?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    disconnect?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    delete?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    connect?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    update?: SessionFMPAFormateurUpdateWithWhereUniqueWithoutPersonnelInput | SessionFMPAFormateurUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: SessionFMPAFormateurUpdateManyWithWhereWithoutPersonnelInput | SessionFMPAFormateurUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: SessionFMPAFormateurScalarWhereInput | SessionFMPAFormateurScalarWhereInput[]
  }

  export type SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<SignatureFMPACreateWithoutPersonnelInput, SignatureFMPAUncheckedCreateWithoutPersonnelInput> | SignatureFMPACreateWithoutPersonnelInput[] | SignatureFMPAUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: SignatureFMPACreateOrConnectWithoutPersonnelInput | SignatureFMPACreateOrConnectWithoutPersonnelInput[]
    upsert?: SignatureFMPAUpsertWithWhereUniqueWithoutPersonnelInput | SignatureFMPAUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: SignatureFMPACreateManyPersonnelInputEnvelope
    set?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    disconnect?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    delete?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    connect?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    update?: SignatureFMPAUpdateWithWhereUniqueWithoutPersonnelInput | SignatureFMPAUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: SignatureFMPAUpdateManyWithWhereWithoutPersonnelInput | SignatureFMPAUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: SignatureFMPAScalarWhereInput | SignatureFMPAScalarWhereInput[]
  }

  export type EPIUncheckedUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<EPICreateWithoutPersonnelInput, EPIUncheckedCreateWithoutPersonnelInput> | EPICreateWithoutPersonnelInput[] | EPIUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: EPICreateOrConnectWithoutPersonnelInput | EPICreateOrConnectWithoutPersonnelInput[]
    upsert?: EPIUpsertWithWhereUniqueWithoutPersonnelInput | EPIUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: EPICreateManyPersonnelInputEnvelope
    set?: EPIWhereUniqueInput | EPIWhereUniqueInput[]
    disconnect?: EPIWhereUniqueInput | EPIWhereUniqueInput[]
    delete?: EPIWhereUniqueInput | EPIWhereUniqueInput[]
    connect?: EPIWhereUniqueInput | EPIWhereUniqueInput[]
    update?: EPIUpdateWithWhereUniqueWithoutPersonnelInput | EPIUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: EPIUpdateManyWithWhereWithoutPersonnelInput | EPIUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: EPIScalarWhereInput | EPIScalarWhereInput[]
  }

  export type MaterielUncheckedUpdateManyWithoutResponsableNestedInput = {
    create?: XOR<MaterielCreateWithoutResponsableInput, MaterielUncheckedCreateWithoutResponsableInput> | MaterielCreateWithoutResponsableInput[] | MaterielUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: MaterielCreateOrConnectWithoutResponsableInput | MaterielCreateOrConnectWithoutResponsableInput[]
    upsert?: MaterielUpsertWithWhereUniqueWithoutResponsableInput | MaterielUpsertWithWhereUniqueWithoutResponsableInput[]
    createMany?: MaterielCreateManyResponsableInputEnvelope
    set?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    disconnect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    delete?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    connect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    update?: MaterielUpdateWithWhereUniqueWithoutResponsableInput | MaterielUpdateWithWhereUniqueWithoutResponsableInput[]
    updateMany?: MaterielUpdateManyWithWhereWithoutResponsableInput | MaterielUpdateManyWithWhereWithoutResponsableInput[]
    deleteMany?: MaterielScalarWhereInput | MaterielScalarWhereInput[]
  }

  export type IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput = {
    create?: XOR<IncidentMaterielCreateWithoutSignaleParInput, IncidentMaterielUncheckedCreateWithoutSignaleParInput> | IncidentMaterielCreateWithoutSignaleParInput[] | IncidentMaterielUncheckedCreateWithoutSignaleParInput[]
    connectOrCreate?: IncidentMaterielCreateOrConnectWithoutSignaleParInput | IncidentMaterielCreateOrConnectWithoutSignaleParInput[]
    upsert?: IncidentMaterielUpsertWithWhereUniqueWithoutSignaleParInput | IncidentMaterielUpsertWithWhereUniqueWithoutSignaleParInput[]
    createMany?: IncidentMaterielCreateManySignaleParInputEnvelope
    set?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    disconnect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    delete?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    connect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    update?: IncidentMaterielUpdateWithWhereUniqueWithoutSignaleParInput | IncidentMaterielUpdateWithWhereUniqueWithoutSignaleParInput[]
    updateMany?: IncidentMaterielUpdateManyWithWhereWithoutSignaleParInput | IncidentMaterielUpdateManyWithWhereWithoutSignaleParInput[]
    deleteMany?: IncidentMaterielScalarWhereInput | IncidentMaterielScalarWhereInput[]
  }

  export type IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput = {
    create?: XOR<IncidentMaterielCreateWithoutTraiteParInput, IncidentMaterielUncheckedCreateWithoutTraiteParInput> | IncidentMaterielCreateWithoutTraiteParInput[] | IncidentMaterielUncheckedCreateWithoutTraiteParInput[]
    connectOrCreate?: IncidentMaterielCreateOrConnectWithoutTraiteParInput | IncidentMaterielCreateOrConnectWithoutTraiteParInput[]
    upsert?: IncidentMaterielUpsertWithWhereUniqueWithoutTraiteParInput | IncidentMaterielUpsertWithWhereUniqueWithoutTraiteParInput[]
    createMany?: IncidentMaterielCreateManyTraiteParInputEnvelope
    set?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    disconnect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    delete?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    connect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    update?: IncidentMaterielUpdateWithWhereUniqueWithoutTraiteParInput | IncidentMaterielUpdateWithWhereUniqueWithoutTraiteParInput[]
    updateMany?: IncidentMaterielUpdateManyWithWhereWithoutTraiteParInput | IncidentMaterielUpdateManyWithWhereWithoutTraiteParInput[]
    deleteMany?: IncidentMaterielScalarWhereInput | IncidentMaterielScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput> | ConversationCreateWithoutCreatedByInput[] | ConversationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatedByInput | ConversationCreateOrConnectWithoutCreatedByInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutCreatedByInput | ConversationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ConversationCreateManyCreatedByInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutCreatedByInput | ConversationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutCreatedByInput | ConversationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutPersonnelInput, ConversationParticipantUncheckedCreateWithoutPersonnelInput> | ConversationParticipantCreateWithoutPersonnelInput[] | ConversationParticipantUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutPersonnelInput | ConversationParticipantCreateOrConnectWithoutPersonnelInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutPersonnelInput | ConversationParticipantUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: ConversationParticipantCreateManyPersonnelInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutPersonnelInput | ConversationParticipantUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutPersonnelInput | ConversationParticipantUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutExpediteurNestedInput = {
    create?: XOR<MessageCreateWithoutExpediteurInput, MessageUncheckedCreateWithoutExpediteurInput> | MessageCreateWithoutExpediteurInput[] | MessageUncheckedCreateWithoutExpediteurInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutExpediteurInput | MessageCreateOrConnectWithoutExpediteurInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutExpediteurInput | MessageUpsertWithWhereUniqueWithoutExpediteurInput[]
    createMany?: MessageCreateManyExpediteurInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutExpediteurInput | MessageUpdateWithWhereUniqueWithoutExpediteurInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutExpediteurInput | MessageUpdateManyWithWhereWithoutExpediteurInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<MessageLuCreateWithoutPersonnelInput, MessageLuUncheckedCreateWithoutPersonnelInput> | MessageLuCreateWithoutPersonnelInput[] | MessageLuUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: MessageLuCreateOrConnectWithoutPersonnelInput | MessageLuCreateOrConnectWithoutPersonnelInput[]
    upsert?: MessageLuUpsertWithWhereUniqueWithoutPersonnelInput | MessageLuUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: MessageLuCreateManyPersonnelInputEnvelope
    set?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    disconnect?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    delete?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    connect?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    update?: MessageLuUpdateWithWhereUniqueWithoutPersonnelInput | MessageLuUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: MessageLuUpdateManyWithWhereWithoutPersonnelInput | MessageLuUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: MessageLuScalarWhereInput | MessageLuScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutDestinataireNestedInput = {
    create?: XOR<NotificationCreateWithoutDestinataireInput, NotificationUncheckedCreateWithoutDestinataireInput> | NotificationCreateWithoutDestinataireInput[] | NotificationUncheckedCreateWithoutDestinataireInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutDestinataireInput | NotificationCreateOrConnectWithoutDestinataireInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutDestinataireInput | NotificationUpsertWithWhereUniqueWithoutDestinataireInput[]
    createMany?: NotificationCreateManyDestinataireInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutDestinataireInput | NotificationUpdateWithWhereUniqueWithoutDestinataireInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutDestinataireInput | NotificationUpdateManyWithWhereWithoutDestinataireInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type EvenementUncheckedUpdateManyWithoutCreateurNestedInput = {
    create?: XOR<EvenementCreateWithoutCreateurInput, EvenementUncheckedCreateWithoutCreateurInput> | EvenementCreateWithoutCreateurInput[] | EvenementUncheckedCreateWithoutCreateurInput[]
    connectOrCreate?: EvenementCreateOrConnectWithoutCreateurInput | EvenementCreateOrConnectWithoutCreateurInput[]
    upsert?: EvenementUpsertWithWhereUniqueWithoutCreateurInput | EvenementUpsertWithWhereUniqueWithoutCreateurInput[]
    createMany?: EvenementCreateManyCreateurInputEnvelope
    set?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    disconnect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    delete?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    connect?: EvenementWhereUniqueInput | EvenementWhereUniqueInput[]
    update?: EvenementUpdateWithWhereUniqueWithoutCreateurInput | EvenementUpdateWithWhereUniqueWithoutCreateurInput[]
    updateMany?: EvenementUpdateManyWithWhereWithoutCreateurInput | EvenementUpdateManyWithWhereWithoutCreateurInput[]
    deleteMany?: EvenementScalarWhereInput | EvenementScalarWhereInput[]
  }

  export type EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput = {
    create?: XOR<EvenementParticipantCreateWithoutPersonnelInput, EvenementParticipantUncheckedCreateWithoutPersonnelInput> | EvenementParticipantCreateWithoutPersonnelInput[] | EvenementParticipantUncheckedCreateWithoutPersonnelInput[]
    connectOrCreate?: EvenementParticipantCreateOrConnectWithoutPersonnelInput | EvenementParticipantCreateOrConnectWithoutPersonnelInput[]
    upsert?: EvenementParticipantUpsertWithWhereUniqueWithoutPersonnelInput | EvenementParticipantUpsertWithWhereUniqueWithoutPersonnelInput[]
    createMany?: EvenementParticipantCreateManyPersonnelInputEnvelope
    set?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    disconnect?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    delete?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    connect?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    update?: EvenementParticipantUpdateWithWhereUniqueWithoutPersonnelInput | EvenementParticipantUpdateWithWhereUniqueWithoutPersonnelInput[]
    updateMany?: EvenementParticipantUpdateManyWithWhereWithoutPersonnelInput | EvenementParticipantUpdateManyWithWhereWithoutPersonnelInput[]
    deleteMany?: EvenementParticipantScalarWhereInput | EvenementParticipantScalarWhereInput[]
  }

  export type ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput = {
    create?: XOR<ExportTTACreateWithoutGenereParInput, ExportTTAUncheckedCreateWithoutGenereParInput> | ExportTTACreateWithoutGenereParInput[] | ExportTTAUncheckedCreateWithoutGenereParInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutGenereParInput | ExportTTACreateOrConnectWithoutGenereParInput[]
    upsert?: ExportTTAUpsertWithWhereUniqueWithoutGenereParInput | ExportTTAUpsertWithWhereUniqueWithoutGenereParInput[]
    createMany?: ExportTTACreateManyGenereParInputEnvelope
    set?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    disconnect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    delete?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    update?: ExportTTAUpdateWithWhereUniqueWithoutGenereParInput | ExportTTAUpdateWithWhereUniqueWithoutGenereParInput[]
    updateMany?: ExportTTAUpdateManyWithWhereWithoutGenereParInput | ExportTTAUpdateManyWithWhereWithoutGenereParInput[]
    deleteMany?: ExportTTAScalarWhereInput | ExportTTAScalarWhereInput[]
  }

  export type ExportTTAUncheckedUpdateManyWithoutValideParNestedInput = {
    create?: XOR<ExportTTACreateWithoutValideParInput, ExportTTAUncheckedCreateWithoutValideParInput> | ExportTTACreateWithoutValideParInput[] | ExportTTAUncheckedCreateWithoutValideParInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutValideParInput | ExportTTACreateOrConnectWithoutValideParInput[]
    upsert?: ExportTTAUpsertWithWhereUniqueWithoutValideParInput | ExportTTAUpsertWithWhereUniqueWithoutValideParInput[]
    createMany?: ExportTTACreateManyValideParInputEnvelope
    set?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    disconnect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    delete?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    update?: ExportTTAUpdateWithWhereUniqueWithoutValideParInput | ExportTTAUpdateWithWhereUniqueWithoutValideParInput[]
    updateMany?: ExportTTAUpdateManyWithWhereWithoutValideParInput | ExportTTAUpdateManyWithWhereWithoutValideParInput[]
    deleteMany?: ExportTTAScalarWhereInput | ExportTTAScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<AuditLogCreateWithoutUtilisateurInput, AuditLogUncheckedCreateWithoutUtilisateurInput> | AuditLogCreateWithoutUtilisateurInput[] | AuditLogUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUtilisateurInput | AuditLogCreateOrConnectWithoutUtilisateurInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUtilisateurInput | AuditLogUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: AuditLogCreateManyUtilisateurInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUtilisateurInput | AuditLogUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUtilisateurInput | AuditLogUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PersonnelRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<PersonnelRoleCreateWithoutRoleInput, PersonnelRoleUncheckedCreateWithoutRoleInput> | PersonnelRoleCreateWithoutRoleInput[] | PersonnelRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PersonnelRoleCreateOrConnectWithoutRoleInput | PersonnelRoleCreateOrConnectWithoutRoleInput[]
    createMany?: PersonnelRoleCreateManyRoleInputEnvelope
    connect?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
  }

  export type PersonnelRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<PersonnelRoleCreateWithoutRoleInput, PersonnelRoleUncheckedCreateWithoutRoleInput> | PersonnelRoleCreateWithoutRoleInput[] | PersonnelRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PersonnelRoleCreateOrConnectWithoutRoleInput | PersonnelRoleCreateOrConnectWithoutRoleInput[]
    createMany?: PersonnelRoleCreateManyRoleInputEnvelope
    connect?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
  }

  export type PersonnelRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<PersonnelRoleCreateWithoutRoleInput, PersonnelRoleUncheckedCreateWithoutRoleInput> | PersonnelRoleCreateWithoutRoleInput[] | PersonnelRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PersonnelRoleCreateOrConnectWithoutRoleInput | PersonnelRoleCreateOrConnectWithoutRoleInput[]
    upsert?: PersonnelRoleUpsertWithWhereUniqueWithoutRoleInput | PersonnelRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: PersonnelRoleCreateManyRoleInputEnvelope
    set?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    disconnect?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    delete?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    connect?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    update?: PersonnelRoleUpdateWithWhereUniqueWithoutRoleInput | PersonnelRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: PersonnelRoleUpdateManyWithWhereWithoutRoleInput | PersonnelRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: PersonnelRoleScalarWhereInput | PersonnelRoleScalarWhereInput[]
  }

  export type PersonnelRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<PersonnelRoleCreateWithoutRoleInput, PersonnelRoleUncheckedCreateWithoutRoleInput> | PersonnelRoleCreateWithoutRoleInput[] | PersonnelRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PersonnelRoleCreateOrConnectWithoutRoleInput | PersonnelRoleCreateOrConnectWithoutRoleInput[]
    upsert?: PersonnelRoleUpsertWithWhereUniqueWithoutRoleInput | PersonnelRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: PersonnelRoleCreateManyRoleInputEnvelope
    set?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    disconnect?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    delete?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    connect?: PersonnelRoleWhereUniqueInput | PersonnelRoleWhereUniqueInput[]
    update?: PersonnelRoleUpdateWithWhereUniqueWithoutRoleInput | PersonnelRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: PersonnelRoleUpdateManyWithWhereWithoutRoleInput | PersonnelRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: PersonnelRoleScalarWhereInput | PersonnelRoleScalarWhereInput[]
  }

  export type PersonnelCreateNestedOneWithoutPersonnelRolesInput = {
    create?: XOR<PersonnelCreateWithoutPersonnelRolesInput, PersonnelUncheckedCreateWithoutPersonnelRolesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutPersonnelRolesInput
    connect?: PersonnelWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutPersonnelsInput = {
    create?: XOR<RoleCreateWithoutPersonnelsInput, RoleUncheckedCreateWithoutPersonnelsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPersonnelsInput
    connect?: RoleWhereUniqueInput
  }

  export type PersonnelUpdateOneRequiredWithoutPersonnelRolesNestedInput = {
    create?: XOR<PersonnelCreateWithoutPersonnelRolesInput, PersonnelUncheckedCreateWithoutPersonnelRolesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutPersonnelRolesInput
    upsert?: PersonnelUpsertWithoutPersonnelRolesInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutPersonnelRolesInput, PersonnelUpdateWithoutPersonnelRolesInput>, PersonnelUncheckedUpdateWithoutPersonnelRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutPersonnelsNestedInput = {
    create?: XOR<RoleCreateWithoutPersonnelsInput, RoleUncheckedCreateWithoutPersonnelsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPersonnelsInput
    upsert?: RoleUpsertWithoutPersonnelsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPersonnelsInput, RoleUpdateWithoutPersonnelsInput>, RoleUncheckedUpdateWithoutPersonnelsInput>
  }

  export type PersonnelCompetenceCreateNestedManyWithoutTypeCompetenceInput = {
    create?: XOR<PersonnelCompetenceCreateWithoutTypeCompetenceInput, PersonnelCompetenceUncheckedCreateWithoutTypeCompetenceInput> | PersonnelCompetenceCreateWithoutTypeCompetenceInput[] | PersonnelCompetenceUncheckedCreateWithoutTypeCompetenceInput[]
    connectOrCreate?: PersonnelCompetenceCreateOrConnectWithoutTypeCompetenceInput | PersonnelCompetenceCreateOrConnectWithoutTypeCompetenceInput[]
    createMany?: PersonnelCompetenceCreateManyTypeCompetenceInputEnvelope
    connect?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
  }

  export type PersonnelCompetenceUncheckedCreateNestedManyWithoutTypeCompetenceInput = {
    create?: XOR<PersonnelCompetenceCreateWithoutTypeCompetenceInput, PersonnelCompetenceUncheckedCreateWithoutTypeCompetenceInput> | PersonnelCompetenceCreateWithoutTypeCompetenceInput[] | PersonnelCompetenceUncheckedCreateWithoutTypeCompetenceInput[]
    connectOrCreate?: PersonnelCompetenceCreateOrConnectWithoutTypeCompetenceInput | PersonnelCompetenceCreateOrConnectWithoutTypeCompetenceInput[]
    createMany?: PersonnelCompetenceCreateManyTypeCompetenceInputEnvelope
    connect?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
  }

  export type PersonnelCompetenceUpdateManyWithoutTypeCompetenceNestedInput = {
    create?: XOR<PersonnelCompetenceCreateWithoutTypeCompetenceInput, PersonnelCompetenceUncheckedCreateWithoutTypeCompetenceInput> | PersonnelCompetenceCreateWithoutTypeCompetenceInput[] | PersonnelCompetenceUncheckedCreateWithoutTypeCompetenceInput[]
    connectOrCreate?: PersonnelCompetenceCreateOrConnectWithoutTypeCompetenceInput | PersonnelCompetenceCreateOrConnectWithoutTypeCompetenceInput[]
    upsert?: PersonnelCompetenceUpsertWithWhereUniqueWithoutTypeCompetenceInput | PersonnelCompetenceUpsertWithWhereUniqueWithoutTypeCompetenceInput[]
    createMany?: PersonnelCompetenceCreateManyTypeCompetenceInputEnvelope
    set?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    disconnect?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    delete?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    connect?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    update?: PersonnelCompetenceUpdateWithWhereUniqueWithoutTypeCompetenceInput | PersonnelCompetenceUpdateWithWhereUniqueWithoutTypeCompetenceInput[]
    updateMany?: PersonnelCompetenceUpdateManyWithWhereWithoutTypeCompetenceInput | PersonnelCompetenceUpdateManyWithWhereWithoutTypeCompetenceInput[]
    deleteMany?: PersonnelCompetenceScalarWhereInput | PersonnelCompetenceScalarWhereInput[]
  }

  export type PersonnelCompetenceUncheckedUpdateManyWithoutTypeCompetenceNestedInput = {
    create?: XOR<PersonnelCompetenceCreateWithoutTypeCompetenceInput, PersonnelCompetenceUncheckedCreateWithoutTypeCompetenceInput> | PersonnelCompetenceCreateWithoutTypeCompetenceInput[] | PersonnelCompetenceUncheckedCreateWithoutTypeCompetenceInput[]
    connectOrCreate?: PersonnelCompetenceCreateOrConnectWithoutTypeCompetenceInput | PersonnelCompetenceCreateOrConnectWithoutTypeCompetenceInput[]
    upsert?: PersonnelCompetenceUpsertWithWhereUniqueWithoutTypeCompetenceInput | PersonnelCompetenceUpsertWithWhereUniqueWithoutTypeCompetenceInput[]
    createMany?: PersonnelCompetenceCreateManyTypeCompetenceInputEnvelope
    set?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    disconnect?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    delete?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    connect?: PersonnelCompetenceWhereUniqueInput | PersonnelCompetenceWhereUniqueInput[]
    update?: PersonnelCompetenceUpdateWithWhereUniqueWithoutTypeCompetenceInput | PersonnelCompetenceUpdateWithWhereUniqueWithoutTypeCompetenceInput[]
    updateMany?: PersonnelCompetenceUpdateManyWithWhereWithoutTypeCompetenceInput | PersonnelCompetenceUpdateManyWithWhereWithoutTypeCompetenceInput[]
    deleteMany?: PersonnelCompetenceScalarWhereInput | PersonnelCompetenceScalarWhereInput[]
  }

  export type PersonnelCreateNestedOneWithoutCompetencesInput = {
    create?: XOR<PersonnelCreateWithoutCompetencesInput, PersonnelUncheckedCreateWithoutCompetencesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutCompetencesInput
    connect?: PersonnelWhereUniqueInput
  }

  export type TypeCompetenceCreateNestedOneWithoutCompetencesInput = {
    create?: XOR<TypeCompetenceCreateWithoutCompetencesInput, TypeCompetenceUncheckedCreateWithoutCompetencesInput>
    connectOrCreate?: TypeCompetenceCreateOrConnectWithoutCompetencesInput
    connect?: TypeCompetenceWhereUniqueInput
  }

  export type PersonnelUpdateOneRequiredWithoutCompetencesNestedInput = {
    create?: XOR<PersonnelCreateWithoutCompetencesInput, PersonnelUncheckedCreateWithoutCompetencesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutCompetencesInput
    upsert?: PersonnelUpsertWithoutCompetencesInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutCompetencesInput, PersonnelUpdateWithoutCompetencesInput>, PersonnelUncheckedUpdateWithoutCompetencesInput>
  }

  export type TypeCompetenceUpdateOneRequiredWithoutCompetencesNestedInput = {
    create?: XOR<TypeCompetenceCreateWithoutCompetencesInput, TypeCompetenceUncheckedCreateWithoutCompetencesInput>
    connectOrCreate?: TypeCompetenceCreateOrConnectWithoutCompetencesInput
    upsert?: TypeCompetenceUpsertWithoutCompetencesInput
    connect?: TypeCompetenceWhereUniqueInput
    update?: XOR<XOR<TypeCompetenceUpdateToOneWithWhereWithoutCompetencesInput, TypeCompetenceUpdateWithoutCompetencesInput>, TypeCompetenceUncheckedUpdateWithoutCompetencesInput>
  }

  export type PersonnelCreateNestedOneWithoutAptitudesMedicalesInput = {
    create?: XOR<PersonnelCreateWithoutAptitudesMedicalesInput, PersonnelUncheckedCreateWithoutAptitudesMedicalesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutAptitudesMedicalesInput
    connect?: PersonnelWhereUniqueInput
  }

  export type EnumStatutAptitudeFieldUpdateOperationsInput = {
    set?: $Enums.StatutAptitude
  }

  export type PersonnelUpdateOneRequiredWithoutAptitudesMedicalesNestedInput = {
    create?: XOR<PersonnelCreateWithoutAptitudesMedicalesInput, PersonnelUncheckedCreateWithoutAptitudesMedicalesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutAptitudesMedicalesInput
    upsert?: PersonnelUpsertWithoutAptitudesMedicalesInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutAptitudesMedicalesInput, PersonnelUpdateWithoutAptitudesMedicalesInput>, PersonnelUncheckedUpdateWithoutAptitudesMedicalesInput>
  }

  export type SessionFMPACreateNestedManyWithoutTypeFMPAInput = {
    create?: XOR<SessionFMPACreateWithoutTypeFMPAInput, SessionFMPAUncheckedCreateWithoutTypeFMPAInput> | SessionFMPACreateWithoutTypeFMPAInput[] | SessionFMPAUncheckedCreateWithoutTypeFMPAInput[]
    connectOrCreate?: SessionFMPACreateOrConnectWithoutTypeFMPAInput | SessionFMPACreateOrConnectWithoutTypeFMPAInput[]
    createMany?: SessionFMPACreateManyTypeFMPAInputEnvelope
    connect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
  }

  export type SessionFMPAUncheckedCreateNestedManyWithoutTypeFMPAInput = {
    create?: XOR<SessionFMPACreateWithoutTypeFMPAInput, SessionFMPAUncheckedCreateWithoutTypeFMPAInput> | SessionFMPACreateWithoutTypeFMPAInput[] | SessionFMPAUncheckedCreateWithoutTypeFMPAInput[]
    connectOrCreate?: SessionFMPACreateOrConnectWithoutTypeFMPAInput | SessionFMPACreateOrConnectWithoutTypeFMPAInput[]
    createMany?: SessionFMPACreateManyTypeFMPAInputEnvelope
    connect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SessionFMPAUpdateManyWithoutTypeFMPANestedInput = {
    create?: XOR<SessionFMPACreateWithoutTypeFMPAInput, SessionFMPAUncheckedCreateWithoutTypeFMPAInput> | SessionFMPACreateWithoutTypeFMPAInput[] | SessionFMPAUncheckedCreateWithoutTypeFMPAInput[]
    connectOrCreate?: SessionFMPACreateOrConnectWithoutTypeFMPAInput | SessionFMPACreateOrConnectWithoutTypeFMPAInput[]
    upsert?: SessionFMPAUpsertWithWhereUniqueWithoutTypeFMPAInput | SessionFMPAUpsertWithWhereUniqueWithoutTypeFMPAInput[]
    createMany?: SessionFMPACreateManyTypeFMPAInputEnvelope
    set?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    disconnect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    delete?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    connect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    update?: SessionFMPAUpdateWithWhereUniqueWithoutTypeFMPAInput | SessionFMPAUpdateWithWhereUniqueWithoutTypeFMPAInput[]
    updateMany?: SessionFMPAUpdateManyWithWhereWithoutTypeFMPAInput | SessionFMPAUpdateManyWithWhereWithoutTypeFMPAInput[]
    deleteMany?: SessionFMPAScalarWhereInput | SessionFMPAScalarWhereInput[]
  }

  export type SessionFMPAUncheckedUpdateManyWithoutTypeFMPANestedInput = {
    create?: XOR<SessionFMPACreateWithoutTypeFMPAInput, SessionFMPAUncheckedCreateWithoutTypeFMPAInput> | SessionFMPACreateWithoutTypeFMPAInput[] | SessionFMPAUncheckedCreateWithoutTypeFMPAInput[]
    connectOrCreate?: SessionFMPACreateOrConnectWithoutTypeFMPAInput | SessionFMPACreateOrConnectWithoutTypeFMPAInput[]
    upsert?: SessionFMPAUpsertWithWhereUniqueWithoutTypeFMPAInput | SessionFMPAUpsertWithWhereUniqueWithoutTypeFMPAInput[]
    createMany?: SessionFMPACreateManyTypeFMPAInputEnvelope
    set?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    disconnect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    delete?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    connect?: SessionFMPAWhereUniqueInput | SessionFMPAWhereUniqueInput[]
    update?: SessionFMPAUpdateWithWhereUniqueWithoutTypeFMPAInput | SessionFMPAUpdateWithWhereUniqueWithoutTypeFMPAInput[]
    updateMany?: SessionFMPAUpdateManyWithWhereWithoutTypeFMPAInput | SessionFMPAUpdateManyWithWhereWithoutTypeFMPAInput[]
    deleteMany?: SessionFMPAScalarWhereInput | SessionFMPAScalarWhereInput[]
  }

  export type TypeFMPACreateNestedOneWithoutSessionsInput = {
    create?: XOR<TypeFMPACreateWithoutSessionsInput, TypeFMPAUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TypeFMPACreateOrConnectWithoutSessionsInput
    connect?: TypeFMPAWhereUniqueInput
  }

  export type CentreCreateNestedOneWithoutSessionsInput = {
    create?: XOR<CentreCreateWithoutSessionsInput, CentreUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CentreCreateOrConnectWithoutSessionsInput
    connect?: CentreWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutSessionsFMPAFormateurInput = {
    create?: XOR<PersonnelCreateWithoutSessionsFMPAFormateurInput, PersonnelUncheckedCreateWithoutSessionsFMPAFormateurInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutSessionsFMPAFormateurInput
    connect?: PersonnelWhereUniqueInput
  }

  export type SessionFMPAFormateurCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionFMPAFormateurCreateWithoutSessionInput, SessionFMPAFormateurUncheckedCreateWithoutSessionInput> | SessionFMPAFormateurCreateWithoutSessionInput[] | SessionFMPAFormateurUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionFMPAFormateurCreateOrConnectWithoutSessionInput | SessionFMPAFormateurCreateOrConnectWithoutSessionInput[]
    createMany?: SessionFMPAFormateurCreateManySessionInputEnvelope
    connect?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
  }

  export type InscriptionFMPACreateNestedManyWithoutSessionInput = {
    create?: XOR<InscriptionFMPACreateWithoutSessionInput, InscriptionFMPAUncheckedCreateWithoutSessionInput> | InscriptionFMPACreateWithoutSessionInput[] | InscriptionFMPAUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InscriptionFMPACreateOrConnectWithoutSessionInput | InscriptionFMPACreateOrConnectWithoutSessionInput[]
    createMany?: InscriptionFMPACreateManySessionInputEnvelope
    connect?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
  }

  export type SignatureFMPACreateNestedManyWithoutSessionInput = {
    create?: XOR<SignatureFMPACreateWithoutSessionInput, SignatureFMPAUncheckedCreateWithoutSessionInput> | SignatureFMPACreateWithoutSessionInput[] | SignatureFMPAUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SignatureFMPACreateOrConnectWithoutSessionInput | SignatureFMPACreateOrConnectWithoutSessionInput[]
    createMany?: SignatureFMPACreateManySessionInputEnvelope
    connect?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
  }

  export type ExportTTACreateNestedManyWithoutSessionInput = {
    create?: XOR<ExportTTACreateWithoutSessionInput, ExportTTAUncheckedCreateWithoutSessionInput> | ExportTTACreateWithoutSessionInput[] | ExportTTAUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutSessionInput | ExportTTACreateOrConnectWithoutSessionInput[]
    createMany?: ExportTTACreateManySessionInputEnvelope
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
  }

  export type SessionFMPAFormateurUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionFMPAFormateurCreateWithoutSessionInput, SessionFMPAFormateurUncheckedCreateWithoutSessionInput> | SessionFMPAFormateurCreateWithoutSessionInput[] | SessionFMPAFormateurUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionFMPAFormateurCreateOrConnectWithoutSessionInput | SessionFMPAFormateurCreateOrConnectWithoutSessionInput[]
    createMany?: SessionFMPAFormateurCreateManySessionInputEnvelope
    connect?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
  }

  export type InscriptionFMPAUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<InscriptionFMPACreateWithoutSessionInput, InscriptionFMPAUncheckedCreateWithoutSessionInput> | InscriptionFMPACreateWithoutSessionInput[] | InscriptionFMPAUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InscriptionFMPACreateOrConnectWithoutSessionInput | InscriptionFMPACreateOrConnectWithoutSessionInput[]
    createMany?: InscriptionFMPACreateManySessionInputEnvelope
    connect?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
  }

  export type SignatureFMPAUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SignatureFMPACreateWithoutSessionInput, SignatureFMPAUncheckedCreateWithoutSessionInput> | SignatureFMPACreateWithoutSessionInput[] | SignatureFMPAUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SignatureFMPACreateOrConnectWithoutSessionInput | SignatureFMPACreateOrConnectWithoutSessionInput[]
    createMany?: SignatureFMPACreateManySessionInputEnvelope
    connect?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
  }

  export type ExportTTAUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ExportTTACreateWithoutSessionInput, ExportTTAUncheckedCreateWithoutSessionInput> | ExportTTACreateWithoutSessionInput[] | ExportTTAUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutSessionInput | ExportTTACreateOrConnectWithoutSessionInput[]
    createMany?: ExportTTACreateManySessionInputEnvelope
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
  }

  export type EnumStatutSessionFieldUpdateOperationsInput = {
    set?: $Enums.StatutSession
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TypeFMPAUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<TypeFMPACreateWithoutSessionsInput, TypeFMPAUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TypeFMPACreateOrConnectWithoutSessionsInput
    upsert?: TypeFMPAUpsertWithoutSessionsInput
    connect?: TypeFMPAWhereUniqueInput
    update?: XOR<XOR<TypeFMPAUpdateToOneWithWhereWithoutSessionsInput, TypeFMPAUpdateWithoutSessionsInput>, TypeFMPAUncheckedUpdateWithoutSessionsInput>
  }

  export type CentreUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<CentreCreateWithoutSessionsInput, CentreUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CentreCreateOrConnectWithoutSessionsInput
    upsert?: CentreUpsertWithoutSessionsInput
    disconnect?: CentreWhereInput | boolean
    delete?: CentreWhereInput | boolean
    connect?: CentreWhereUniqueInput
    update?: XOR<XOR<CentreUpdateToOneWithWhereWithoutSessionsInput, CentreUpdateWithoutSessionsInput>, CentreUncheckedUpdateWithoutSessionsInput>
  }

  export type PersonnelUpdateOneRequiredWithoutSessionsFMPAFormateurNestedInput = {
    create?: XOR<PersonnelCreateWithoutSessionsFMPAFormateurInput, PersonnelUncheckedCreateWithoutSessionsFMPAFormateurInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutSessionsFMPAFormateurInput
    upsert?: PersonnelUpsertWithoutSessionsFMPAFormateurInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutSessionsFMPAFormateurInput, PersonnelUpdateWithoutSessionsFMPAFormateurInput>, PersonnelUncheckedUpdateWithoutSessionsFMPAFormateurInput>
  }

  export type SessionFMPAFormateurUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionFMPAFormateurCreateWithoutSessionInput, SessionFMPAFormateurUncheckedCreateWithoutSessionInput> | SessionFMPAFormateurCreateWithoutSessionInput[] | SessionFMPAFormateurUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionFMPAFormateurCreateOrConnectWithoutSessionInput | SessionFMPAFormateurCreateOrConnectWithoutSessionInput[]
    upsert?: SessionFMPAFormateurUpsertWithWhereUniqueWithoutSessionInput | SessionFMPAFormateurUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionFMPAFormateurCreateManySessionInputEnvelope
    set?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    disconnect?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    delete?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    connect?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    update?: SessionFMPAFormateurUpdateWithWhereUniqueWithoutSessionInput | SessionFMPAFormateurUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionFMPAFormateurUpdateManyWithWhereWithoutSessionInput | SessionFMPAFormateurUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionFMPAFormateurScalarWhereInput | SessionFMPAFormateurScalarWhereInput[]
  }

  export type InscriptionFMPAUpdateManyWithoutSessionNestedInput = {
    create?: XOR<InscriptionFMPACreateWithoutSessionInput, InscriptionFMPAUncheckedCreateWithoutSessionInput> | InscriptionFMPACreateWithoutSessionInput[] | InscriptionFMPAUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InscriptionFMPACreateOrConnectWithoutSessionInput | InscriptionFMPACreateOrConnectWithoutSessionInput[]
    upsert?: InscriptionFMPAUpsertWithWhereUniqueWithoutSessionInput | InscriptionFMPAUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: InscriptionFMPACreateManySessionInputEnvelope
    set?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    disconnect?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    delete?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    connect?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    update?: InscriptionFMPAUpdateWithWhereUniqueWithoutSessionInput | InscriptionFMPAUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: InscriptionFMPAUpdateManyWithWhereWithoutSessionInput | InscriptionFMPAUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: InscriptionFMPAScalarWhereInput | InscriptionFMPAScalarWhereInput[]
  }

  export type SignatureFMPAUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SignatureFMPACreateWithoutSessionInput, SignatureFMPAUncheckedCreateWithoutSessionInput> | SignatureFMPACreateWithoutSessionInput[] | SignatureFMPAUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SignatureFMPACreateOrConnectWithoutSessionInput | SignatureFMPACreateOrConnectWithoutSessionInput[]
    upsert?: SignatureFMPAUpsertWithWhereUniqueWithoutSessionInput | SignatureFMPAUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SignatureFMPACreateManySessionInputEnvelope
    set?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    disconnect?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    delete?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    connect?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    update?: SignatureFMPAUpdateWithWhereUniqueWithoutSessionInput | SignatureFMPAUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SignatureFMPAUpdateManyWithWhereWithoutSessionInput | SignatureFMPAUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SignatureFMPAScalarWhereInput | SignatureFMPAScalarWhereInput[]
  }

  export type ExportTTAUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ExportTTACreateWithoutSessionInput, ExportTTAUncheckedCreateWithoutSessionInput> | ExportTTACreateWithoutSessionInput[] | ExportTTAUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutSessionInput | ExportTTACreateOrConnectWithoutSessionInput[]
    upsert?: ExportTTAUpsertWithWhereUniqueWithoutSessionInput | ExportTTAUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ExportTTACreateManySessionInputEnvelope
    set?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    disconnect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    delete?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    update?: ExportTTAUpdateWithWhereUniqueWithoutSessionInput | ExportTTAUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ExportTTAUpdateManyWithWhereWithoutSessionInput | ExportTTAUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ExportTTAScalarWhereInput | ExportTTAScalarWhereInput[]
  }

  export type SessionFMPAFormateurUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionFMPAFormateurCreateWithoutSessionInput, SessionFMPAFormateurUncheckedCreateWithoutSessionInput> | SessionFMPAFormateurCreateWithoutSessionInput[] | SessionFMPAFormateurUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionFMPAFormateurCreateOrConnectWithoutSessionInput | SessionFMPAFormateurCreateOrConnectWithoutSessionInput[]
    upsert?: SessionFMPAFormateurUpsertWithWhereUniqueWithoutSessionInput | SessionFMPAFormateurUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionFMPAFormateurCreateManySessionInputEnvelope
    set?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    disconnect?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    delete?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    connect?: SessionFMPAFormateurWhereUniqueInput | SessionFMPAFormateurWhereUniqueInput[]
    update?: SessionFMPAFormateurUpdateWithWhereUniqueWithoutSessionInput | SessionFMPAFormateurUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionFMPAFormateurUpdateManyWithWhereWithoutSessionInput | SessionFMPAFormateurUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionFMPAFormateurScalarWhereInput | SessionFMPAFormateurScalarWhereInput[]
  }

  export type InscriptionFMPAUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<InscriptionFMPACreateWithoutSessionInput, InscriptionFMPAUncheckedCreateWithoutSessionInput> | InscriptionFMPACreateWithoutSessionInput[] | InscriptionFMPAUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InscriptionFMPACreateOrConnectWithoutSessionInput | InscriptionFMPACreateOrConnectWithoutSessionInput[]
    upsert?: InscriptionFMPAUpsertWithWhereUniqueWithoutSessionInput | InscriptionFMPAUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: InscriptionFMPACreateManySessionInputEnvelope
    set?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    disconnect?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    delete?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    connect?: InscriptionFMPAWhereUniqueInput | InscriptionFMPAWhereUniqueInput[]
    update?: InscriptionFMPAUpdateWithWhereUniqueWithoutSessionInput | InscriptionFMPAUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: InscriptionFMPAUpdateManyWithWhereWithoutSessionInput | InscriptionFMPAUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: InscriptionFMPAScalarWhereInput | InscriptionFMPAScalarWhereInput[]
  }

  export type SignatureFMPAUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SignatureFMPACreateWithoutSessionInput, SignatureFMPAUncheckedCreateWithoutSessionInput> | SignatureFMPACreateWithoutSessionInput[] | SignatureFMPAUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SignatureFMPACreateOrConnectWithoutSessionInput | SignatureFMPACreateOrConnectWithoutSessionInput[]
    upsert?: SignatureFMPAUpsertWithWhereUniqueWithoutSessionInput | SignatureFMPAUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SignatureFMPACreateManySessionInputEnvelope
    set?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    disconnect?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    delete?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    connect?: SignatureFMPAWhereUniqueInput | SignatureFMPAWhereUniqueInput[]
    update?: SignatureFMPAUpdateWithWhereUniqueWithoutSessionInput | SignatureFMPAUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SignatureFMPAUpdateManyWithWhereWithoutSessionInput | SignatureFMPAUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SignatureFMPAScalarWhereInput | SignatureFMPAScalarWhereInput[]
  }

  export type ExportTTAUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ExportTTACreateWithoutSessionInput, ExportTTAUncheckedCreateWithoutSessionInput> | ExportTTACreateWithoutSessionInput[] | ExportTTAUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ExportTTACreateOrConnectWithoutSessionInput | ExportTTACreateOrConnectWithoutSessionInput[]
    upsert?: ExportTTAUpsertWithWhereUniqueWithoutSessionInput | ExportTTAUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ExportTTACreateManySessionInputEnvelope
    set?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    disconnect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    delete?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    connect?: ExportTTAWhereUniqueInput | ExportTTAWhereUniqueInput[]
    update?: ExportTTAUpdateWithWhereUniqueWithoutSessionInput | ExportTTAUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ExportTTAUpdateManyWithWhereWithoutSessionInput | ExportTTAUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ExportTTAScalarWhereInput | ExportTTAScalarWhereInput[]
  }

  export type SessionFMPACreateNestedOneWithoutFormateursAdditionnelsInput = {
    create?: XOR<SessionFMPACreateWithoutFormateursAdditionnelsInput, SessionFMPAUncheckedCreateWithoutFormateursAdditionnelsInput>
    connectOrCreate?: SessionFMPACreateOrConnectWithoutFormateursAdditionnelsInput
    connect?: SessionFMPAWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutSessionsFMPAAdditionnelsInput = {
    create?: XOR<PersonnelCreateWithoutSessionsFMPAAdditionnelsInput, PersonnelUncheckedCreateWithoutSessionsFMPAAdditionnelsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutSessionsFMPAAdditionnelsInput
    connect?: PersonnelWhereUniqueInput
  }

  export type SessionFMPAUpdateOneRequiredWithoutFormateursAdditionnelsNestedInput = {
    create?: XOR<SessionFMPACreateWithoutFormateursAdditionnelsInput, SessionFMPAUncheckedCreateWithoutFormateursAdditionnelsInput>
    connectOrCreate?: SessionFMPACreateOrConnectWithoutFormateursAdditionnelsInput
    upsert?: SessionFMPAUpsertWithoutFormateursAdditionnelsInput
    connect?: SessionFMPAWhereUniqueInput
    update?: XOR<XOR<SessionFMPAUpdateToOneWithWhereWithoutFormateursAdditionnelsInput, SessionFMPAUpdateWithoutFormateursAdditionnelsInput>, SessionFMPAUncheckedUpdateWithoutFormateursAdditionnelsInput>
  }

  export type PersonnelUpdateOneRequiredWithoutSessionsFMPAAdditionnelsNestedInput = {
    create?: XOR<PersonnelCreateWithoutSessionsFMPAAdditionnelsInput, PersonnelUncheckedCreateWithoutSessionsFMPAAdditionnelsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutSessionsFMPAAdditionnelsInput
    upsert?: PersonnelUpsertWithoutSessionsFMPAAdditionnelsInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutSessionsFMPAAdditionnelsInput, PersonnelUpdateWithoutSessionsFMPAAdditionnelsInput>, PersonnelUncheckedUpdateWithoutSessionsFMPAAdditionnelsInput>
  }

  export type SessionFMPACreateNestedOneWithoutInscriptionsInput = {
    create?: XOR<SessionFMPACreateWithoutInscriptionsInput, SessionFMPAUncheckedCreateWithoutInscriptionsInput>
    connectOrCreate?: SessionFMPACreateOrConnectWithoutInscriptionsInput
    connect?: SessionFMPAWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutInscriptionsFMPAInput = {
    create?: XOR<PersonnelCreateWithoutInscriptionsFMPAInput, PersonnelUncheckedCreateWithoutInscriptionsFMPAInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutInscriptionsFMPAInput
    connect?: PersonnelWhereUniqueInput
  }

  export type EnumStatutInscriptionFieldUpdateOperationsInput = {
    set?: $Enums.StatutInscription
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type SessionFMPAUpdateOneRequiredWithoutInscriptionsNestedInput = {
    create?: XOR<SessionFMPACreateWithoutInscriptionsInput, SessionFMPAUncheckedCreateWithoutInscriptionsInput>
    connectOrCreate?: SessionFMPACreateOrConnectWithoutInscriptionsInput
    upsert?: SessionFMPAUpsertWithoutInscriptionsInput
    connect?: SessionFMPAWhereUniqueInput
    update?: XOR<XOR<SessionFMPAUpdateToOneWithWhereWithoutInscriptionsInput, SessionFMPAUpdateWithoutInscriptionsInput>, SessionFMPAUncheckedUpdateWithoutInscriptionsInput>
  }

  export type PersonnelUpdateOneRequiredWithoutInscriptionsFMPANestedInput = {
    create?: XOR<PersonnelCreateWithoutInscriptionsFMPAInput, PersonnelUncheckedCreateWithoutInscriptionsFMPAInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutInscriptionsFMPAInput
    upsert?: PersonnelUpsertWithoutInscriptionsFMPAInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutInscriptionsFMPAInput, PersonnelUpdateWithoutInscriptionsFMPAInput>, PersonnelUncheckedUpdateWithoutInscriptionsFMPAInput>
  }

  export type SessionFMPACreateNestedOneWithoutSignaturesInput = {
    create?: XOR<SessionFMPACreateWithoutSignaturesInput, SessionFMPAUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: SessionFMPACreateOrConnectWithoutSignaturesInput
    connect?: SessionFMPAWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutSignaturesFMPAInput = {
    create?: XOR<PersonnelCreateWithoutSignaturesFMPAInput, PersonnelUncheckedCreateWithoutSignaturesFMPAInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutSignaturesFMPAInput
    connect?: PersonnelWhereUniqueInput
  }

  export type SessionFMPAUpdateOneRequiredWithoutSignaturesNestedInput = {
    create?: XOR<SessionFMPACreateWithoutSignaturesInput, SessionFMPAUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: SessionFMPACreateOrConnectWithoutSignaturesInput
    upsert?: SessionFMPAUpsertWithoutSignaturesInput
    connect?: SessionFMPAWhereUniqueInput
    update?: XOR<XOR<SessionFMPAUpdateToOneWithWhereWithoutSignaturesInput, SessionFMPAUpdateWithoutSignaturesInput>, SessionFMPAUncheckedUpdateWithoutSignaturesInput>
  }

  export type PersonnelUpdateOneRequiredWithoutSignaturesFMPANestedInput = {
    create?: XOR<PersonnelCreateWithoutSignaturesFMPAInput, PersonnelUncheckedCreateWithoutSignaturesFMPAInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutSignaturesFMPAInput
    upsert?: PersonnelUpsertWithoutSignaturesFMPAInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutSignaturesFMPAInput, PersonnelUpdateWithoutSignaturesFMPAInput>, PersonnelUncheckedUpdateWithoutSignaturesFMPAInput>
  }

  export type MaterielCreateNestedManyWithoutCategorieInput = {
    create?: XOR<MaterielCreateWithoutCategorieInput, MaterielUncheckedCreateWithoutCategorieInput> | MaterielCreateWithoutCategorieInput[] | MaterielUncheckedCreateWithoutCategorieInput[]
    connectOrCreate?: MaterielCreateOrConnectWithoutCategorieInput | MaterielCreateOrConnectWithoutCategorieInput[]
    createMany?: MaterielCreateManyCategorieInputEnvelope
    connect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
  }

  export type MaterielUncheckedCreateNestedManyWithoutCategorieInput = {
    create?: XOR<MaterielCreateWithoutCategorieInput, MaterielUncheckedCreateWithoutCategorieInput> | MaterielCreateWithoutCategorieInput[] | MaterielUncheckedCreateWithoutCategorieInput[]
    connectOrCreate?: MaterielCreateOrConnectWithoutCategorieInput | MaterielCreateOrConnectWithoutCategorieInput[]
    createMany?: MaterielCreateManyCategorieInputEnvelope
    connect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
  }

  export type MaterielUpdateManyWithoutCategorieNestedInput = {
    create?: XOR<MaterielCreateWithoutCategorieInput, MaterielUncheckedCreateWithoutCategorieInput> | MaterielCreateWithoutCategorieInput[] | MaterielUncheckedCreateWithoutCategorieInput[]
    connectOrCreate?: MaterielCreateOrConnectWithoutCategorieInput | MaterielCreateOrConnectWithoutCategorieInput[]
    upsert?: MaterielUpsertWithWhereUniqueWithoutCategorieInput | MaterielUpsertWithWhereUniqueWithoutCategorieInput[]
    createMany?: MaterielCreateManyCategorieInputEnvelope
    set?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    disconnect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    delete?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    connect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    update?: MaterielUpdateWithWhereUniqueWithoutCategorieInput | MaterielUpdateWithWhereUniqueWithoutCategorieInput[]
    updateMany?: MaterielUpdateManyWithWhereWithoutCategorieInput | MaterielUpdateManyWithWhereWithoutCategorieInput[]
    deleteMany?: MaterielScalarWhereInput | MaterielScalarWhereInput[]
  }

  export type MaterielUncheckedUpdateManyWithoutCategorieNestedInput = {
    create?: XOR<MaterielCreateWithoutCategorieInput, MaterielUncheckedCreateWithoutCategorieInput> | MaterielCreateWithoutCategorieInput[] | MaterielUncheckedCreateWithoutCategorieInput[]
    connectOrCreate?: MaterielCreateOrConnectWithoutCategorieInput | MaterielCreateOrConnectWithoutCategorieInput[]
    upsert?: MaterielUpsertWithWhereUniqueWithoutCategorieInput | MaterielUpsertWithWhereUniqueWithoutCategorieInput[]
    createMany?: MaterielCreateManyCategorieInputEnvelope
    set?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    disconnect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    delete?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    connect?: MaterielWhereUniqueInput | MaterielWhereUniqueInput[]
    update?: MaterielUpdateWithWhereUniqueWithoutCategorieInput | MaterielUpdateWithWhereUniqueWithoutCategorieInput[]
    updateMany?: MaterielUpdateManyWithWhereWithoutCategorieInput | MaterielUpdateManyWithWhereWithoutCategorieInput[]
    deleteMany?: MaterielScalarWhereInput | MaterielScalarWhereInput[]
  }

  export type CategorieMaterielCreateNestedOneWithoutMaterielsInput = {
    create?: XOR<CategorieMaterielCreateWithoutMaterielsInput, CategorieMaterielUncheckedCreateWithoutMaterielsInput>
    connectOrCreate?: CategorieMaterielCreateOrConnectWithoutMaterielsInput
    connect?: CategorieMaterielWhereUniqueInput
  }

  export type CentreCreateNestedOneWithoutMaterielsInput = {
    create?: XOR<CentreCreateWithoutMaterielsInput, CentreUncheckedCreateWithoutMaterielsInput>
    connectOrCreate?: CentreCreateOrConnectWithoutMaterielsInput
    connect?: CentreWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutMaterielsResponsableInput = {
    create?: XOR<PersonnelCreateWithoutMaterielsResponsableInput, PersonnelUncheckedCreateWithoutMaterielsResponsableInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutMaterielsResponsableInput
    connect?: PersonnelWhereUniqueInput
  }

  export type IncidentMaterielCreateNestedManyWithoutMaterielInput = {
    create?: XOR<IncidentMaterielCreateWithoutMaterielInput, IncidentMaterielUncheckedCreateWithoutMaterielInput> | IncidentMaterielCreateWithoutMaterielInput[] | IncidentMaterielUncheckedCreateWithoutMaterielInput[]
    connectOrCreate?: IncidentMaterielCreateOrConnectWithoutMaterielInput | IncidentMaterielCreateOrConnectWithoutMaterielInput[]
    createMany?: IncidentMaterielCreateManyMaterielInputEnvelope
    connect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
  }

  export type IncidentMaterielUncheckedCreateNestedManyWithoutMaterielInput = {
    create?: XOR<IncidentMaterielCreateWithoutMaterielInput, IncidentMaterielUncheckedCreateWithoutMaterielInput> | IncidentMaterielCreateWithoutMaterielInput[] | IncidentMaterielUncheckedCreateWithoutMaterielInput[]
    connectOrCreate?: IncidentMaterielCreateOrConnectWithoutMaterielInput | IncidentMaterielCreateOrConnectWithoutMaterielInput[]
    createMany?: IncidentMaterielCreateManyMaterielInputEnvelope
    connect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
  }

  export type EnumEtatMaterielFieldUpdateOperationsInput = {
    set?: $Enums.EtatMateriel
  }

  export type CategorieMaterielUpdateOneRequiredWithoutMaterielsNestedInput = {
    create?: XOR<CategorieMaterielCreateWithoutMaterielsInput, CategorieMaterielUncheckedCreateWithoutMaterielsInput>
    connectOrCreate?: CategorieMaterielCreateOrConnectWithoutMaterielsInput
    upsert?: CategorieMaterielUpsertWithoutMaterielsInput
    connect?: CategorieMaterielWhereUniqueInput
    update?: XOR<XOR<CategorieMaterielUpdateToOneWithWhereWithoutMaterielsInput, CategorieMaterielUpdateWithoutMaterielsInput>, CategorieMaterielUncheckedUpdateWithoutMaterielsInput>
  }

  export type CentreUpdateOneWithoutMaterielsNestedInput = {
    create?: XOR<CentreCreateWithoutMaterielsInput, CentreUncheckedCreateWithoutMaterielsInput>
    connectOrCreate?: CentreCreateOrConnectWithoutMaterielsInput
    upsert?: CentreUpsertWithoutMaterielsInput
    disconnect?: CentreWhereInput | boolean
    delete?: CentreWhereInput | boolean
    connect?: CentreWhereUniqueInput
    update?: XOR<XOR<CentreUpdateToOneWithWhereWithoutMaterielsInput, CentreUpdateWithoutMaterielsInput>, CentreUncheckedUpdateWithoutMaterielsInput>
  }

  export type PersonnelUpdateOneWithoutMaterielsResponsableNestedInput = {
    create?: XOR<PersonnelCreateWithoutMaterielsResponsableInput, PersonnelUncheckedCreateWithoutMaterielsResponsableInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutMaterielsResponsableInput
    upsert?: PersonnelUpsertWithoutMaterielsResponsableInput
    disconnect?: PersonnelWhereInput | boolean
    delete?: PersonnelWhereInput | boolean
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutMaterielsResponsableInput, PersonnelUpdateWithoutMaterielsResponsableInput>, PersonnelUncheckedUpdateWithoutMaterielsResponsableInput>
  }

  export type IncidentMaterielUpdateManyWithoutMaterielNestedInput = {
    create?: XOR<IncidentMaterielCreateWithoutMaterielInput, IncidentMaterielUncheckedCreateWithoutMaterielInput> | IncidentMaterielCreateWithoutMaterielInput[] | IncidentMaterielUncheckedCreateWithoutMaterielInput[]
    connectOrCreate?: IncidentMaterielCreateOrConnectWithoutMaterielInput | IncidentMaterielCreateOrConnectWithoutMaterielInput[]
    upsert?: IncidentMaterielUpsertWithWhereUniqueWithoutMaterielInput | IncidentMaterielUpsertWithWhereUniqueWithoutMaterielInput[]
    createMany?: IncidentMaterielCreateManyMaterielInputEnvelope
    set?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    disconnect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    delete?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    connect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    update?: IncidentMaterielUpdateWithWhereUniqueWithoutMaterielInput | IncidentMaterielUpdateWithWhereUniqueWithoutMaterielInput[]
    updateMany?: IncidentMaterielUpdateManyWithWhereWithoutMaterielInput | IncidentMaterielUpdateManyWithWhereWithoutMaterielInput[]
    deleteMany?: IncidentMaterielScalarWhereInput | IncidentMaterielScalarWhereInput[]
  }

  export type IncidentMaterielUncheckedUpdateManyWithoutMaterielNestedInput = {
    create?: XOR<IncidentMaterielCreateWithoutMaterielInput, IncidentMaterielUncheckedCreateWithoutMaterielInput> | IncidentMaterielCreateWithoutMaterielInput[] | IncidentMaterielUncheckedCreateWithoutMaterielInput[]
    connectOrCreate?: IncidentMaterielCreateOrConnectWithoutMaterielInput | IncidentMaterielCreateOrConnectWithoutMaterielInput[]
    upsert?: IncidentMaterielUpsertWithWhereUniqueWithoutMaterielInput | IncidentMaterielUpsertWithWhereUniqueWithoutMaterielInput[]
    createMany?: IncidentMaterielCreateManyMaterielInputEnvelope
    set?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    disconnect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    delete?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    connect?: IncidentMaterielWhereUniqueInput | IncidentMaterielWhereUniqueInput[]
    update?: IncidentMaterielUpdateWithWhereUniqueWithoutMaterielInput | IncidentMaterielUpdateWithWhereUniqueWithoutMaterielInput[]
    updateMany?: IncidentMaterielUpdateManyWithWhereWithoutMaterielInput | IncidentMaterielUpdateManyWithWhereWithoutMaterielInput[]
    deleteMany?: IncidentMaterielScalarWhereInput | IncidentMaterielScalarWhereInput[]
  }

  export type IncidentMaterielCreatephotosUrlsInput = {
    set: string[]
  }

  export type MaterielCreateNestedOneWithoutIncidentsInput = {
    create?: XOR<MaterielCreateWithoutIncidentsInput, MaterielUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: MaterielCreateOrConnectWithoutIncidentsInput
    connect?: MaterielWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutIncidentsSignalesInput = {
    create?: XOR<PersonnelCreateWithoutIncidentsSignalesInput, PersonnelUncheckedCreateWithoutIncidentsSignalesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutIncidentsSignalesInput
    connect?: PersonnelWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutIncidentsTraitesInput = {
    create?: XOR<PersonnelCreateWithoutIncidentsTraitesInput, PersonnelUncheckedCreateWithoutIncidentsTraitesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutIncidentsTraitesInput
    connect?: PersonnelWhereUniqueInput
  }

  export type EnumTypeIncidentFieldUpdateOperationsInput = {
    set?: $Enums.TypeIncident
  }

  export type EnumGraviteIncidentFieldUpdateOperationsInput = {
    set?: $Enums.GraviteIncident
  }

  export type IncidentMaterielUpdatephotosUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumStatutIncidentFieldUpdateOperationsInput = {
    set?: $Enums.StatutIncident
  }

  export type MaterielUpdateOneRequiredWithoutIncidentsNestedInput = {
    create?: XOR<MaterielCreateWithoutIncidentsInput, MaterielUncheckedCreateWithoutIncidentsInput>
    connectOrCreate?: MaterielCreateOrConnectWithoutIncidentsInput
    upsert?: MaterielUpsertWithoutIncidentsInput
    connect?: MaterielWhereUniqueInput
    update?: XOR<XOR<MaterielUpdateToOneWithWhereWithoutIncidentsInput, MaterielUpdateWithoutIncidentsInput>, MaterielUncheckedUpdateWithoutIncidentsInput>
  }

  export type PersonnelUpdateOneRequiredWithoutIncidentsSignalesNestedInput = {
    create?: XOR<PersonnelCreateWithoutIncidentsSignalesInput, PersonnelUncheckedCreateWithoutIncidentsSignalesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutIncidentsSignalesInput
    upsert?: PersonnelUpsertWithoutIncidentsSignalesInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutIncidentsSignalesInput, PersonnelUpdateWithoutIncidentsSignalesInput>, PersonnelUncheckedUpdateWithoutIncidentsSignalesInput>
  }

  export type PersonnelUpdateOneWithoutIncidentsTraitesNestedInput = {
    create?: XOR<PersonnelCreateWithoutIncidentsTraitesInput, PersonnelUncheckedCreateWithoutIncidentsTraitesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutIncidentsTraitesInput
    upsert?: PersonnelUpsertWithoutIncidentsTraitesInput
    disconnect?: PersonnelWhereInput | boolean
    delete?: PersonnelWhereInput | boolean
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutIncidentsTraitesInput, PersonnelUpdateWithoutIncidentsTraitesInput>, PersonnelUncheckedUpdateWithoutIncidentsTraitesInput>
  }

  export type PersonnelCreateNestedOneWithoutEpiInput = {
    create?: XOR<PersonnelCreateWithoutEpiInput, PersonnelUncheckedCreateWithoutEpiInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutEpiInput
    connect?: PersonnelWhereUniqueInput
  }

  export type EnumEtatEPIFieldUpdateOperationsInput = {
    set?: $Enums.EtatEPI
  }

  export type PersonnelUpdateOneRequiredWithoutEpiNestedInput = {
    create?: XOR<PersonnelCreateWithoutEpiInput, PersonnelUncheckedCreateWithoutEpiInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutEpiInput
    upsert?: PersonnelUpsertWithoutEpiInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutEpiInput, PersonnelUpdateWithoutEpiInput>, PersonnelUncheckedUpdateWithoutEpiInput>
  }

  export type PersonnelCreateNestedOneWithoutConversationsCreeesInput = {
    create?: XOR<PersonnelCreateWithoutConversationsCreeesInput, PersonnelUncheckedCreateWithoutConversationsCreeesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutConversationsCreeesInput
    connect?: PersonnelWhereUniqueInput
  }

  export type ConversationParticipantCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EnumTypeConversationFieldUpdateOperationsInput = {
    set?: $Enums.TypeConversation
  }

  export type PersonnelUpdateOneRequiredWithoutConversationsCreeesNestedInput = {
    create?: XOR<PersonnelCreateWithoutConversationsCreeesInput, PersonnelUncheckedCreateWithoutConversationsCreeesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutConversationsCreeesInput
    upsert?: PersonnelUpsertWithoutConversationsCreeesInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutConversationsCreeesInput, PersonnelUpdateWithoutConversationsCreeesInput>, PersonnelUncheckedUpdateWithoutConversationsCreeesInput>
  }

  export type ConversationParticipantUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutParticipationsInput = {
    create?: XOR<PersonnelCreateWithoutParticipationsInput, PersonnelUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutParticipationsInput
    connect?: PersonnelWhereUniqueInput
  }

  export type EnumRoleConversationFieldUpdateOperationsInput = {
    set?: $Enums.RoleConversation
  }

  export type ConversationUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    upsert?: ConversationUpsertWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutParticipantsInput, ConversationUpdateWithoutParticipantsInput>, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type PersonnelUpdateOneRequiredWithoutParticipationsNestedInput = {
    create?: XOR<PersonnelCreateWithoutParticipationsInput, PersonnelUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutParticipationsInput
    upsert?: PersonnelUpsertWithoutParticipationsInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutParticipationsInput, PersonnelUpdateWithoutParticipationsInput>, PersonnelUncheckedUpdateWithoutParticipationsInput>
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutMessagesEnvoyesInput = {
    create?: XOR<PersonnelCreateWithoutMessagesEnvoyesInput, PersonnelUncheckedCreateWithoutMessagesEnvoyesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutMessagesEnvoyesInput
    connect?: PersonnelWhereUniqueInput
  }

  export type MessageLuCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageLuCreateWithoutMessageInput, MessageLuUncheckedCreateWithoutMessageInput> | MessageLuCreateWithoutMessageInput[] | MessageLuUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageLuCreateOrConnectWithoutMessageInput | MessageLuCreateOrConnectWithoutMessageInput[]
    createMany?: MessageLuCreateManyMessageInputEnvelope
    connect?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
  }

  export type MessageLuUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageLuCreateWithoutMessageInput, MessageLuUncheckedCreateWithoutMessageInput> | MessageLuCreateWithoutMessageInput[] | MessageLuUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageLuCreateOrConnectWithoutMessageInput | MessageLuCreateOrConnectWithoutMessageInput[]
    createMany?: MessageLuCreateManyMessageInputEnvelope
    connect?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
  }

  export type EnumTypeMessageFieldUpdateOperationsInput = {
    set?: $Enums.TypeMessage
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type PersonnelUpdateOneRequiredWithoutMessagesEnvoyesNestedInput = {
    create?: XOR<PersonnelCreateWithoutMessagesEnvoyesInput, PersonnelUncheckedCreateWithoutMessagesEnvoyesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutMessagesEnvoyesInput
    upsert?: PersonnelUpsertWithoutMessagesEnvoyesInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutMessagesEnvoyesInput, PersonnelUpdateWithoutMessagesEnvoyesInput>, PersonnelUncheckedUpdateWithoutMessagesEnvoyesInput>
  }

  export type MessageLuUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageLuCreateWithoutMessageInput, MessageLuUncheckedCreateWithoutMessageInput> | MessageLuCreateWithoutMessageInput[] | MessageLuUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageLuCreateOrConnectWithoutMessageInput | MessageLuCreateOrConnectWithoutMessageInput[]
    upsert?: MessageLuUpsertWithWhereUniqueWithoutMessageInput | MessageLuUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageLuCreateManyMessageInputEnvelope
    set?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    disconnect?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    delete?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    connect?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    update?: MessageLuUpdateWithWhereUniqueWithoutMessageInput | MessageLuUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageLuUpdateManyWithWhereWithoutMessageInput | MessageLuUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageLuScalarWhereInput | MessageLuScalarWhereInput[]
  }

  export type MessageLuUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageLuCreateWithoutMessageInput, MessageLuUncheckedCreateWithoutMessageInput> | MessageLuCreateWithoutMessageInput[] | MessageLuUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageLuCreateOrConnectWithoutMessageInput | MessageLuCreateOrConnectWithoutMessageInput[]
    upsert?: MessageLuUpsertWithWhereUniqueWithoutMessageInput | MessageLuUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageLuCreateManyMessageInputEnvelope
    set?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    disconnect?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    delete?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    connect?: MessageLuWhereUniqueInput | MessageLuWhereUniqueInput[]
    update?: MessageLuUpdateWithWhereUniqueWithoutMessageInput | MessageLuUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageLuUpdateManyWithWhereWithoutMessageInput | MessageLuUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageLuScalarWhereInput | MessageLuScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutMessagesLusInput = {
    create?: XOR<MessageCreateWithoutMessagesLusInput, MessageUncheckedCreateWithoutMessagesLusInput>
    connectOrCreate?: MessageCreateOrConnectWithoutMessagesLusInput
    connect?: MessageWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutMessagesLusInput = {
    create?: XOR<PersonnelCreateWithoutMessagesLusInput, PersonnelUncheckedCreateWithoutMessagesLusInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutMessagesLusInput
    connect?: PersonnelWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutMessagesLusNestedInput = {
    create?: XOR<MessageCreateWithoutMessagesLusInput, MessageUncheckedCreateWithoutMessagesLusInput>
    connectOrCreate?: MessageCreateOrConnectWithoutMessagesLusInput
    upsert?: MessageUpsertWithoutMessagesLusInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutMessagesLusInput, MessageUpdateWithoutMessagesLusInput>, MessageUncheckedUpdateWithoutMessagesLusInput>
  }

  export type PersonnelUpdateOneRequiredWithoutMessagesLusNestedInput = {
    create?: XOR<PersonnelCreateWithoutMessagesLusInput, PersonnelUncheckedCreateWithoutMessagesLusInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutMessagesLusInput
    upsert?: PersonnelUpsertWithoutMessagesLusInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutMessagesLusInput, PersonnelUpdateWithoutMessagesLusInput>, PersonnelUncheckedUpdateWithoutMessagesLusInput>
  }

  export type PersonnelCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<PersonnelCreateWithoutNotificationsInput, PersonnelUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutNotificationsInput
    connect?: PersonnelWhereUniqueInput
  }

  export type EnumNiveauNotificationFieldUpdateOperationsInput = {
    set?: $Enums.NiveauNotification
  }

  export type PersonnelUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<PersonnelCreateWithoutNotificationsInput, PersonnelUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutNotificationsInput
    upsert?: PersonnelUpsertWithoutNotificationsInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutNotificationsInput, PersonnelUpdateWithoutNotificationsInput>, PersonnelUncheckedUpdateWithoutNotificationsInput>
  }

  export type PersonnelCreateNestedOneWithoutEvenementsCreeesInput = {
    create?: XOR<PersonnelCreateWithoutEvenementsCreeesInput, PersonnelUncheckedCreateWithoutEvenementsCreeesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutEvenementsCreeesInput
    connect?: PersonnelWhereUniqueInput
  }

  export type CentreCreateNestedOneWithoutEvenementsInput = {
    create?: XOR<CentreCreateWithoutEvenementsInput, CentreUncheckedCreateWithoutEvenementsInput>
    connectOrCreate?: CentreCreateOrConnectWithoutEvenementsInput
    connect?: CentreWhereUniqueInput
  }

  export type EvenementParticipantCreateNestedManyWithoutEvenementInput = {
    create?: XOR<EvenementParticipantCreateWithoutEvenementInput, EvenementParticipantUncheckedCreateWithoutEvenementInput> | EvenementParticipantCreateWithoutEvenementInput[] | EvenementParticipantUncheckedCreateWithoutEvenementInput[]
    connectOrCreate?: EvenementParticipantCreateOrConnectWithoutEvenementInput | EvenementParticipantCreateOrConnectWithoutEvenementInput[]
    createMany?: EvenementParticipantCreateManyEvenementInputEnvelope
    connect?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
  }

  export type EvenementParticipantUncheckedCreateNestedManyWithoutEvenementInput = {
    create?: XOR<EvenementParticipantCreateWithoutEvenementInput, EvenementParticipantUncheckedCreateWithoutEvenementInput> | EvenementParticipantCreateWithoutEvenementInput[] | EvenementParticipantUncheckedCreateWithoutEvenementInput[]
    connectOrCreate?: EvenementParticipantCreateOrConnectWithoutEvenementInput | EvenementParticipantCreateOrConnectWithoutEvenementInput[]
    createMany?: EvenementParticipantCreateManyEvenementInputEnvelope
    connect?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
  }

  export type EnumVisibiliteEvenementFieldUpdateOperationsInput = {
    set?: $Enums.VisibiliteEvenement
  }

  export type PersonnelUpdateOneRequiredWithoutEvenementsCreeesNestedInput = {
    create?: XOR<PersonnelCreateWithoutEvenementsCreeesInput, PersonnelUncheckedCreateWithoutEvenementsCreeesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutEvenementsCreeesInput
    upsert?: PersonnelUpsertWithoutEvenementsCreeesInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutEvenementsCreeesInput, PersonnelUpdateWithoutEvenementsCreeesInput>, PersonnelUncheckedUpdateWithoutEvenementsCreeesInput>
  }

  export type CentreUpdateOneWithoutEvenementsNestedInput = {
    create?: XOR<CentreCreateWithoutEvenementsInput, CentreUncheckedCreateWithoutEvenementsInput>
    connectOrCreate?: CentreCreateOrConnectWithoutEvenementsInput
    upsert?: CentreUpsertWithoutEvenementsInput
    disconnect?: CentreWhereInput | boolean
    delete?: CentreWhereInput | boolean
    connect?: CentreWhereUniqueInput
    update?: XOR<XOR<CentreUpdateToOneWithWhereWithoutEvenementsInput, CentreUpdateWithoutEvenementsInput>, CentreUncheckedUpdateWithoutEvenementsInput>
  }

  export type EvenementParticipantUpdateManyWithoutEvenementNestedInput = {
    create?: XOR<EvenementParticipantCreateWithoutEvenementInput, EvenementParticipantUncheckedCreateWithoutEvenementInput> | EvenementParticipantCreateWithoutEvenementInput[] | EvenementParticipantUncheckedCreateWithoutEvenementInput[]
    connectOrCreate?: EvenementParticipantCreateOrConnectWithoutEvenementInput | EvenementParticipantCreateOrConnectWithoutEvenementInput[]
    upsert?: EvenementParticipantUpsertWithWhereUniqueWithoutEvenementInput | EvenementParticipantUpsertWithWhereUniqueWithoutEvenementInput[]
    createMany?: EvenementParticipantCreateManyEvenementInputEnvelope
    set?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    disconnect?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    delete?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    connect?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    update?: EvenementParticipantUpdateWithWhereUniqueWithoutEvenementInput | EvenementParticipantUpdateWithWhereUniqueWithoutEvenementInput[]
    updateMany?: EvenementParticipantUpdateManyWithWhereWithoutEvenementInput | EvenementParticipantUpdateManyWithWhereWithoutEvenementInput[]
    deleteMany?: EvenementParticipantScalarWhereInput | EvenementParticipantScalarWhereInput[]
  }

  export type EvenementParticipantUncheckedUpdateManyWithoutEvenementNestedInput = {
    create?: XOR<EvenementParticipantCreateWithoutEvenementInput, EvenementParticipantUncheckedCreateWithoutEvenementInput> | EvenementParticipantCreateWithoutEvenementInput[] | EvenementParticipantUncheckedCreateWithoutEvenementInput[]
    connectOrCreate?: EvenementParticipantCreateOrConnectWithoutEvenementInput | EvenementParticipantCreateOrConnectWithoutEvenementInput[]
    upsert?: EvenementParticipantUpsertWithWhereUniqueWithoutEvenementInput | EvenementParticipantUpsertWithWhereUniqueWithoutEvenementInput[]
    createMany?: EvenementParticipantCreateManyEvenementInputEnvelope
    set?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    disconnect?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    delete?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    connect?: EvenementParticipantWhereUniqueInput | EvenementParticipantWhereUniqueInput[]
    update?: EvenementParticipantUpdateWithWhereUniqueWithoutEvenementInput | EvenementParticipantUpdateWithWhereUniqueWithoutEvenementInput[]
    updateMany?: EvenementParticipantUpdateManyWithWhereWithoutEvenementInput | EvenementParticipantUpdateManyWithWhereWithoutEvenementInput[]
    deleteMany?: EvenementParticipantScalarWhereInput | EvenementParticipantScalarWhereInput[]
  }

  export type EvenementCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<EvenementCreateWithoutParticipantsInput, EvenementUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: EvenementCreateOrConnectWithoutParticipantsInput
    connect?: EvenementWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutParticipationsEvenementsInput = {
    create?: XOR<PersonnelCreateWithoutParticipationsEvenementsInput, PersonnelUncheckedCreateWithoutParticipationsEvenementsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutParticipationsEvenementsInput
    connect?: PersonnelWhereUniqueInput
  }

  export type EnumStatutInvitationFieldUpdateOperationsInput = {
    set?: $Enums.StatutInvitation
  }

  export type EvenementUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<EvenementCreateWithoutParticipantsInput, EvenementUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: EvenementCreateOrConnectWithoutParticipantsInput
    upsert?: EvenementUpsertWithoutParticipantsInput
    connect?: EvenementWhereUniqueInput
    update?: XOR<XOR<EvenementUpdateToOneWithWhereWithoutParticipantsInput, EvenementUpdateWithoutParticipantsInput>, EvenementUncheckedUpdateWithoutParticipantsInput>
  }

  export type PersonnelUpdateOneRequiredWithoutParticipationsEvenementsNestedInput = {
    create?: XOR<PersonnelCreateWithoutParticipationsEvenementsInput, PersonnelUncheckedCreateWithoutParticipationsEvenementsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutParticipationsEvenementsInput
    upsert?: PersonnelUpsertWithoutParticipationsEvenementsInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutParticipationsEvenementsInput, PersonnelUpdateWithoutParticipationsEvenementsInput>, PersonnelUncheckedUpdateWithoutParticipationsEvenementsInput>
  }

  export type CentreCreateNestedOneWithoutExportsTTAInput = {
    create?: XOR<CentreCreateWithoutExportsTTAInput, CentreUncheckedCreateWithoutExportsTTAInput>
    connectOrCreate?: CentreCreateOrConnectWithoutExportsTTAInput
    connect?: CentreWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutExportsTTAGeneresInput = {
    create?: XOR<PersonnelCreateWithoutExportsTTAGeneresInput, PersonnelUncheckedCreateWithoutExportsTTAGeneresInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutExportsTTAGeneresInput
    connect?: PersonnelWhereUniqueInput
  }

  export type PersonnelCreateNestedOneWithoutExportsTTAValidesInput = {
    create?: XOR<PersonnelCreateWithoutExportsTTAValidesInput, PersonnelUncheckedCreateWithoutExportsTTAValidesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutExportsTTAValidesInput
    connect?: PersonnelWhereUniqueInput
  }

  export type SessionFMPACreateNestedOneWithoutExportsTTAInput = {
    create?: XOR<SessionFMPACreateWithoutExportsTTAInput, SessionFMPAUncheckedCreateWithoutExportsTTAInput>
    connectOrCreate?: SessionFMPACreateOrConnectWithoutExportsTTAInput
    connect?: SessionFMPAWhereUniqueInput
  }

  export type EnumFormatExportFieldUpdateOperationsInput = {
    set?: $Enums.FormatExport
  }

  export type EnumStatutExportFieldUpdateOperationsInput = {
    set?: $Enums.StatutExport
  }

  export type CentreUpdateOneWithoutExportsTTANestedInput = {
    create?: XOR<CentreCreateWithoutExportsTTAInput, CentreUncheckedCreateWithoutExportsTTAInput>
    connectOrCreate?: CentreCreateOrConnectWithoutExportsTTAInput
    upsert?: CentreUpsertWithoutExportsTTAInput
    disconnect?: CentreWhereInput | boolean
    delete?: CentreWhereInput | boolean
    connect?: CentreWhereUniqueInput
    update?: XOR<XOR<CentreUpdateToOneWithWhereWithoutExportsTTAInput, CentreUpdateWithoutExportsTTAInput>, CentreUncheckedUpdateWithoutExportsTTAInput>
  }

  export type PersonnelUpdateOneRequiredWithoutExportsTTAGeneresNestedInput = {
    create?: XOR<PersonnelCreateWithoutExportsTTAGeneresInput, PersonnelUncheckedCreateWithoutExportsTTAGeneresInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutExportsTTAGeneresInput
    upsert?: PersonnelUpsertWithoutExportsTTAGeneresInput
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutExportsTTAGeneresInput, PersonnelUpdateWithoutExportsTTAGeneresInput>, PersonnelUncheckedUpdateWithoutExportsTTAGeneresInput>
  }

  export type PersonnelUpdateOneWithoutExportsTTAValidesNestedInput = {
    create?: XOR<PersonnelCreateWithoutExportsTTAValidesInput, PersonnelUncheckedCreateWithoutExportsTTAValidesInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutExportsTTAValidesInput
    upsert?: PersonnelUpsertWithoutExportsTTAValidesInput
    disconnect?: PersonnelWhereInput | boolean
    delete?: PersonnelWhereInput | boolean
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutExportsTTAValidesInput, PersonnelUpdateWithoutExportsTTAValidesInput>, PersonnelUncheckedUpdateWithoutExportsTTAValidesInput>
  }

  export type SessionFMPAUpdateOneWithoutExportsTTANestedInput = {
    create?: XOR<SessionFMPACreateWithoutExportsTTAInput, SessionFMPAUncheckedCreateWithoutExportsTTAInput>
    connectOrCreate?: SessionFMPACreateOrConnectWithoutExportsTTAInput
    upsert?: SessionFMPAUpsertWithoutExportsTTAInput
    disconnect?: SessionFMPAWhereInput | boolean
    delete?: SessionFMPAWhereInput | boolean
    connect?: SessionFMPAWhereUniqueInput
    update?: XOR<XOR<SessionFMPAUpdateToOneWithWhereWithoutExportsTTAInput, SessionFMPAUpdateWithoutExportsTTAInput>, SessionFMPAUncheckedUpdateWithoutExportsTTAInput>
  }

  export type PersonnelCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<PersonnelCreateWithoutAuditLogsInput, PersonnelUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutAuditLogsInput
    connect?: PersonnelWhereUniqueInput
  }

  export type PersonnelUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<PersonnelCreateWithoutAuditLogsInput, PersonnelUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: PersonnelCreateOrConnectWithoutAuditLogsInput
    upsert?: PersonnelUpsertWithoutAuditLogsInput
    disconnect?: PersonnelWhereInput | boolean
    delete?: PersonnelWhereInput | boolean
    connect?: PersonnelWhereUniqueInput
    update?: XOR<XOR<PersonnelUpdateToOneWithWhereWithoutAuditLogsInput, PersonnelUpdateWithoutAuditLogsInput>, PersonnelUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumCategorieFilter<$PrismaModel = never> = {
    equals?: $Enums.Categorie | EnumCategorieFieldRefInput<$PrismaModel>
    in?: $Enums.Categorie[] | ListEnumCategorieFieldRefInput<$PrismaModel>
    notIn?: $Enums.Categorie[] | ListEnumCategorieFieldRefInput<$PrismaModel>
    not?: NestedEnumCategorieFilter<$PrismaModel> | $Enums.Categorie
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumCategorieWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Categorie | EnumCategorieFieldRefInput<$PrismaModel>
    in?: $Enums.Categorie[] | ListEnumCategorieFieldRefInput<$PrismaModel>
    notIn?: $Enums.Categorie[] | ListEnumCategorieFieldRefInput<$PrismaModel>
    not?: NestedEnumCategorieWithAggregatesFilter<$PrismaModel> | $Enums.Categorie
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategorieFilter<$PrismaModel>
    _max?: NestedEnumCategorieFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumTypeCentreFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeCentre | EnumTypeCentreFieldRefInput<$PrismaModel>
    in?: $Enums.TypeCentre[] | ListEnumTypeCentreFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeCentre[] | ListEnumTypeCentreFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeCentreFilter<$PrismaModel> | $Enums.TypeCentre
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumTypeCentreWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeCentre | EnumTypeCentreFieldRefInput<$PrismaModel>
    in?: $Enums.TypeCentre[] | ListEnumTypeCentreFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeCentre[] | ListEnumTypeCentreFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeCentreWithAggregatesFilter<$PrismaModel> | $Enums.TypeCentre
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeCentreFilter<$PrismaModel>
    _max?: NestedEnumTypeCentreFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSexeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexe | EnumSexeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexeNullableFilter<$PrismaModel> | $Enums.Sexe | null
  }

  export type NestedEnumStatutPersonnelFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutPersonnel | EnumStatutPersonnelFieldRefInput<$PrismaModel>
    in?: $Enums.StatutPersonnel[] | ListEnumStatutPersonnelFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutPersonnel[] | ListEnumStatutPersonnelFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutPersonnelFilter<$PrismaModel> | $Enums.StatutPersonnel
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSexeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexe | EnumSexeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sexe | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSexeNullableFilter<$PrismaModel>
    _max?: NestedEnumSexeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumStatutPersonnelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutPersonnel | EnumStatutPersonnelFieldRefInput<$PrismaModel>
    in?: $Enums.StatutPersonnel[] | ListEnumStatutPersonnelFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutPersonnel[] | ListEnumStatutPersonnelFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutPersonnelWithAggregatesFilter<$PrismaModel> | $Enums.StatutPersonnel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutPersonnelFilter<$PrismaModel>
    _max?: NestedEnumStatutPersonnelFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumStatutAptitudeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAptitude | EnumStatutAptitudeFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAptitude[] | ListEnumStatutAptitudeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutAptitude[] | ListEnumStatutAptitudeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutAptitudeFilter<$PrismaModel> | $Enums.StatutAptitude
  }

  export type NestedEnumStatutAptitudeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAptitude | EnumStatutAptitudeFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAptitude[] | ListEnumStatutAptitudeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutAptitude[] | ListEnumStatutAptitudeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutAptitudeWithAggregatesFilter<$PrismaModel> | $Enums.StatutAptitude
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutAptitudeFilter<$PrismaModel>
    _max?: NestedEnumStatutAptitudeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumStatutSessionFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutSession | EnumStatutSessionFieldRefInput<$PrismaModel>
    in?: $Enums.StatutSession[] | ListEnumStatutSessionFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutSession[] | ListEnumStatutSessionFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutSessionFilter<$PrismaModel> | $Enums.StatutSession
  }

  export type NestedEnumStatutSessionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutSession | EnumStatutSessionFieldRefInput<$PrismaModel>
    in?: $Enums.StatutSession[] | ListEnumStatutSessionFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutSession[] | ListEnumStatutSessionFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutSessionWithAggregatesFilter<$PrismaModel> | $Enums.StatutSession
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutSessionFilter<$PrismaModel>
    _max?: NestedEnumStatutSessionFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatutInscriptionFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutInscription | EnumStatutInscriptionFieldRefInput<$PrismaModel>
    in?: $Enums.StatutInscription[] | ListEnumStatutInscriptionFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutInscription[] | ListEnumStatutInscriptionFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutInscriptionFilter<$PrismaModel> | $Enums.StatutInscription
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumStatutInscriptionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutInscription | EnumStatutInscriptionFieldRefInput<$PrismaModel>
    in?: $Enums.StatutInscription[] | ListEnumStatutInscriptionFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutInscription[] | ListEnumStatutInscriptionFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutInscriptionWithAggregatesFilter<$PrismaModel> | $Enums.StatutInscription
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutInscriptionFilter<$PrismaModel>
    _max?: NestedEnumStatutInscriptionFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumEtatMaterielFilter<$PrismaModel = never> = {
    equals?: $Enums.EtatMateriel | EnumEtatMaterielFieldRefInput<$PrismaModel>
    in?: $Enums.EtatMateriel[] | ListEnumEtatMaterielFieldRefInput<$PrismaModel>
    notIn?: $Enums.EtatMateriel[] | ListEnumEtatMaterielFieldRefInput<$PrismaModel>
    not?: NestedEnumEtatMaterielFilter<$PrismaModel> | $Enums.EtatMateriel
  }

  export type NestedEnumEtatMaterielWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EtatMateriel | EnumEtatMaterielFieldRefInput<$PrismaModel>
    in?: $Enums.EtatMateriel[] | ListEnumEtatMaterielFieldRefInput<$PrismaModel>
    notIn?: $Enums.EtatMateriel[] | ListEnumEtatMaterielFieldRefInput<$PrismaModel>
    not?: NestedEnumEtatMaterielWithAggregatesFilter<$PrismaModel> | $Enums.EtatMateriel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEtatMaterielFilter<$PrismaModel>
    _max?: NestedEnumEtatMaterielFilter<$PrismaModel>
  }

  export type NestedEnumTypeIncidentFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeIncident | EnumTypeIncidentFieldRefInput<$PrismaModel>
    in?: $Enums.TypeIncident[] | ListEnumTypeIncidentFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeIncident[] | ListEnumTypeIncidentFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeIncidentFilter<$PrismaModel> | $Enums.TypeIncident
  }

  export type NestedEnumGraviteIncidentFilter<$PrismaModel = never> = {
    equals?: $Enums.GraviteIncident | EnumGraviteIncidentFieldRefInput<$PrismaModel>
    in?: $Enums.GraviteIncident[] | ListEnumGraviteIncidentFieldRefInput<$PrismaModel>
    notIn?: $Enums.GraviteIncident[] | ListEnumGraviteIncidentFieldRefInput<$PrismaModel>
    not?: NestedEnumGraviteIncidentFilter<$PrismaModel> | $Enums.GraviteIncident
  }

  export type NestedEnumStatutIncidentFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutIncident | EnumStatutIncidentFieldRefInput<$PrismaModel>
    in?: $Enums.StatutIncident[] | ListEnumStatutIncidentFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutIncident[] | ListEnumStatutIncidentFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutIncidentFilter<$PrismaModel> | $Enums.StatutIncident
  }

  export type NestedEnumTypeIncidentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeIncident | EnumTypeIncidentFieldRefInput<$PrismaModel>
    in?: $Enums.TypeIncident[] | ListEnumTypeIncidentFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeIncident[] | ListEnumTypeIncidentFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeIncidentWithAggregatesFilter<$PrismaModel> | $Enums.TypeIncident
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeIncidentFilter<$PrismaModel>
    _max?: NestedEnumTypeIncidentFilter<$PrismaModel>
  }

  export type NestedEnumGraviteIncidentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GraviteIncident | EnumGraviteIncidentFieldRefInput<$PrismaModel>
    in?: $Enums.GraviteIncident[] | ListEnumGraviteIncidentFieldRefInput<$PrismaModel>
    notIn?: $Enums.GraviteIncident[] | ListEnumGraviteIncidentFieldRefInput<$PrismaModel>
    not?: NestedEnumGraviteIncidentWithAggregatesFilter<$PrismaModel> | $Enums.GraviteIncident
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGraviteIncidentFilter<$PrismaModel>
    _max?: NestedEnumGraviteIncidentFilter<$PrismaModel>
  }

  export type NestedEnumStatutIncidentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutIncident | EnumStatutIncidentFieldRefInput<$PrismaModel>
    in?: $Enums.StatutIncident[] | ListEnumStatutIncidentFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutIncident[] | ListEnumStatutIncidentFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutIncidentWithAggregatesFilter<$PrismaModel> | $Enums.StatutIncident
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutIncidentFilter<$PrismaModel>
    _max?: NestedEnumStatutIncidentFilter<$PrismaModel>
  }

  export type NestedEnumEtatEPIFilter<$PrismaModel = never> = {
    equals?: $Enums.EtatEPI | EnumEtatEPIFieldRefInput<$PrismaModel>
    in?: $Enums.EtatEPI[] | ListEnumEtatEPIFieldRefInput<$PrismaModel>
    notIn?: $Enums.EtatEPI[] | ListEnumEtatEPIFieldRefInput<$PrismaModel>
    not?: NestedEnumEtatEPIFilter<$PrismaModel> | $Enums.EtatEPI
  }

  export type NestedEnumEtatEPIWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EtatEPI | EnumEtatEPIFieldRefInput<$PrismaModel>
    in?: $Enums.EtatEPI[] | ListEnumEtatEPIFieldRefInput<$PrismaModel>
    notIn?: $Enums.EtatEPI[] | ListEnumEtatEPIFieldRefInput<$PrismaModel>
    not?: NestedEnumEtatEPIWithAggregatesFilter<$PrismaModel> | $Enums.EtatEPI
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEtatEPIFilter<$PrismaModel>
    _max?: NestedEnumEtatEPIFilter<$PrismaModel>
  }

  export type NestedEnumTypeConversationFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeConversation | EnumTypeConversationFieldRefInput<$PrismaModel>
    in?: $Enums.TypeConversation[] | ListEnumTypeConversationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeConversation[] | ListEnumTypeConversationFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeConversationFilter<$PrismaModel> | $Enums.TypeConversation
  }

  export type NestedEnumTypeConversationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeConversation | EnumTypeConversationFieldRefInput<$PrismaModel>
    in?: $Enums.TypeConversation[] | ListEnumTypeConversationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeConversation[] | ListEnumTypeConversationFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeConversationWithAggregatesFilter<$PrismaModel> | $Enums.TypeConversation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeConversationFilter<$PrismaModel>
    _max?: NestedEnumTypeConversationFilter<$PrismaModel>
  }

  export type NestedEnumRoleConversationFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleConversation | EnumRoleConversationFieldRefInput<$PrismaModel>
    in?: $Enums.RoleConversation[] | ListEnumRoleConversationFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleConversation[] | ListEnumRoleConversationFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleConversationFilter<$PrismaModel> | $Enums.RoleConversation
  }

  export type NestedEnumRoleConversationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleConversation | EnumRoleConversationFieldRefInput<$PrismaModel>
    in?: $Enums.RoleConversation[] | ListEnumRoleConversationFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleConversation[] | ListEnumRoleConversationFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleConversationWithAggregatesFilter<$PrismaModel> | $Enums.RoleConversation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleConversationFilter<$PrismaModel>
    _max?: NestedEnumRoleConversationFilter<$PrismaModel>
  }

  export type NestedEnumTypeMessageFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMessage | EnumTypeMessageFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMessage[] | ListEnumTypeMessageFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMessage[] | ListEnumTypeMessageFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMessageFilter<$PrismaModel> | $Enums.TypeMessage
  }

  export type NestedEnumTypeMessageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMessage | EnumTypeMessageFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMessage[] | ListEnumTypeMessageFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMessage[] | ListEnumTypeMessageFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMessageWithAggregatesFilter<$PrismaModel> | $Enums.TypeMessage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeMessageFilter<$PrismaModel>
    _max?: NestedEnumTypeMessageFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumNiveauNotificationFilter<$PrismaModel = never> = {
    equals?: $Enums.NiveauNotification | EnumNiveauNotificationFieldRefInput<$PrismaModel>
    in?: $Enums.NiveauNotification[] | ListEnumNiveauNotificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.NiveauNotification[] | ListEnumNiveauNotificationFieldRefInput<$PrismaModel>
    not?: NestedEnumNiveauNotificationFilter<$PrismaModel> | $Enums.NiveauNotification
  }

  export type NestedEnumNiveauNotificationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NiveauNotification | EnumNiveauNotificationFieldRefInput<$PrismaModel>
    in?: $Enums.NiveauNotification[] | ListEnumNiveauNotificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.NiveauNotification[] | ListEnumNiveauNotificationFieldRefInput<$PrismaModel>
    not?: NestedEnumNiveauNotificationWithAggregatesFilter<$PrismaModel> | $Enums.NiveauNotification
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNiveauNotificationFilter<$PrismaModel>
    _max?: NestedEnumNiveauNotificationFilter<$PrismaModel>
  }

  export type NestedEnumVisibiliteEvenementFilter<$PrismaModel = never> = {
    equals?: $Enums.VisibiliteEvenement | EnumVisibiliteEvenementFieldRefInput<$PrismaModel>
    in?: $Enums.VisibiliteEvenement[] | ListEnumVisibiliteEvenementFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisibiliteEvenement[] | ListEnumVisibiliteEvenementFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibiliteEvenementFilter<$PrismaModel> | $Enums.VisibiliteEvenement
  }

  export type NestedEnumVisibiliteEvenementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisibiliteEvenement | EnumVisibiliteEvenementFieldRefInput<$PrismaModel>
    in?: $Enums.VisibiliteEvenement[] | ListEnumVisibiliteEvenementFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisibiliteEvenement[] | ListEnumVisibiliteEvenementFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibiliteEvenementWithAggregatesFilter<$PrismaModel> | $Enums.VisibiliteEvenement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibiliteEvenementFilter<$PrismaModel>
    _max?: NestedEnumVisibiliteEvenementFilter<$PrismaModel>
  }

  export type NestedEnumStatutInvitationFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutInvitation | EnumStatutInvitationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutInvitation[] | ListEnumStatutInvitationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutInvitation[] | ListEnumStatutInvitationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutInvitationFilter<$PrismaModel> | $Enums.StatutInvitation
  }

  export type NestedEnumStatutInvitationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutInvitation | EnumStatutInvitationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutInvitation[] | ListEnumStatutInvitationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutInvitation[] | ListEnumStatutInvitationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutInvitationWithAggregatesFilter<$PrismaModel> | $Enums.StatutInvitation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutInvitationFilter<$PrismaModel>
    _max?: NestedEnumStatutInvitationFilter<$PrismaModel>
  }

  export type NestedEnumFormatExportFilter<$PrismaModel = never> = {
    equals?: $Enums.FormatExport | EnumFormatExportFieldRefInput<$PrismaModel>
    in?: $Enums.FormatExport[] | ListEnumFormatExportFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormatExport[] | ListEnumFormatExportFieldRefInput<$PrismaModel>
    not?: NestedEnumFormatExportFilter<$PrismaModel> | $Enums.FormatExport
  }

  export type NestedEnumStatutExportFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutExport | EnumStatutExportFieldRefInput<$PrismaModel>
    in?: $Enums.StatutExport[] | ListEnumStatutExportFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutExport[] | ListEnumStatutExportFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutExportFilter<$PrismaModel> | $Enums.StatutExport
  }

  export type NestedEnumFormatExportWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormatExport | EnumFormatExportFieldRefInput<$PrismaModel>
    in?: $Enums.FormatExport[] | ListEnumFormatExportFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormatExport[] | ListEnumFormatExportFieldRefInput<$PrismaModel>
    not?: NestedEnumFormatExportWithAggregatesFilter<$PrismaModel> | $Enums.FormatExport
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormatExportFilter<$PrismaModel>
    _max?: NestedEnumFormatExportFilter<$PrismaModel>
  }

  export type NestedEnumStatutExportWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutExport | EnumStatutExportFieldRefInput<$PrismaModel>
    in?: $Enums.StatutExport[] | ListEnumStatutExportFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutExport[] | ListEnumStatutExportFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutExportWithAggregatesFilter<$PrismaModel> | $Enums.StatutExport
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutExportFilter<$PrismaModel>
    _max?: NestedEnumStatutExportFilter<$PrismaModel>
  }

  export type PersonnelCreateWithoutGradeInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutGradeInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutGradeInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutGradeInput, PersonnelUncheckedCreateWithoutGradeInput>
  }

  export type PersonnelCreateManyGradeInputEnvelope = {
    data: PersonnelCreateManyGradeInput | PersonnelCreateManyGradeInput[]
    skipDuplicates?: boolean
  }

  export type PersonnelUpsertWithWhereUniqueWithoutGradeInput = {
    where: PersonnelWhereUniqueInput
    update: XOR<PersonnelUpdateWithoutGradeInput, PersonnelUncheckedUpdateWithoutGradeInput>
    create: XOR<PersonnelCreateWithoutGradeInput, PersonnelUncheckedCreateWithoutGradeInput>
  }

  export type PersonnelUpdateWithWhereUniqueWithoutGradeInput = {
    where: PersonnelWhereUniqueInput
    data: XOR<PersonnelUpdateWithoutGradeInput, PersonnelUncheckedUpdateWithoutGradeInput>
  }

  export type PersonnelUpdateManyWithWhereWithoutGradeInput = {
    where: PersonnelScalarWhereInput
    data: XOR<PersonnelUpdateManyMutationInput, PersonnelUncheckedUpdateManyWithoutGradeInput>
  }

  export type PersonnelScalarWhereInput = {
    AND?: PersonnelScalarWhereInput | PersonnelScalarWhereInput[]
    OR?: PersonnelScalarWhereInput[]
    NOT?: PersonnelScalarWhereInput | PersonnelScalarWhereInput[]
    id?: IntFilter<"Personnel"> | number
    matricule?: StringFilter<"Personnel"> | string
    nom?: StringFilter<"Personnel"> | string
    prenom?: StringFilter<"Personnel"> | string
    dateNaissance?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    sexe?: EnumSexeNullableFilter<"Personnel"> | $Enums.Sexe | null
    email?: StringNullableFilter<"Personnel"> | string | null
    telephoneMobile?: StringNullableFilter<"Personnel"> | string | null
    telephoneFixe?: StringNullableFilter<"Personnel"> | string | null
    adresse?: StringNullableFilter<"Personnel"> | string | null
    ville?: StringNullableFilter<"Personnel"> | string | null
    codePostal?: StringNullableFilter<"Personnel"> | string | null
    centreId?: IntNullableFilter<"Personnel"> | number | null
    gradeId?: IntNullableFilter<"Personnel"> | number | null
    categorie?: EnumCategorieFilter<"Personnel"> | $Enums.Categorie
    dateEngagement?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    dateFinEngagement?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    statut?: EnumStatutPersonnelFilter<"Personnel"> | $Enums.StatutPersonnel
    password?: StringFilter<"Personnel"> | string
    refreshToken?: StringNullableFilter<"Personnel"> | string | null
    lastLogin?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    resetToken?: StringNullableFilter<"Personnel"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"Personnel"> | Date | string | null
    photoUrl?: StringNullableFilter<"Personnel"> | string | null
    createdAt?: DateTimeFilter<"Personnel"> | Date | string
    updatedAt?: DateTimeFilter<"Personnel"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Personnel"> | Date | string | null
  }

  export type PersonnelCreateWithoutCentreInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutCentreInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutCentreInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutCentreInput, PersonnelUncheckedCreateWithoutCentreInput>
  }

  export type PersonnelCreateManyCentreInputEnvelope = {
    data: PersonnelCreateManyCentreInput | PersonnelCreateManyCentreInput[]
    skipDuplicates?: boolean
  }

  export type SessionFMPACreateWithoutCentreInput = {
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    typeFMPA: TypeFMPACreateNestedOneWithoutSessionsInput
    formateurPrincipal: PersonnelCreateNestedOneWithoutSessionsFMPAFormateurInput
    formateursAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutSessionInput
    inscriptions?: InscriptionFMPACreateNestedManyWithoutSessionInput
    signatures?: SignatureFMPACreateNestedManyWithoutSessionInput
    exportsTTA?: ExportTTACreateNestedManyWithoutSessionInput
  }

  export type SessionFMPAUncheckedCreateWithoutCentreInput = {
    id?: number
    typeFMPAId: number
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    formateurPrincipalId: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    formateursAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutSessionInput
    inscriptions?: InscriptionFMPAUncheckedCreateNestedManyWithoutSessionInput
    signatures?: SignatureFMPAUncheckedCreateNestedManyWithoutSessionInput
    exportsTTA?: ExportTTAUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionFMPACreateOrConnectWithoutCentreInput = {
    where: SessionFMPAWhereUniqueInput
    create: XOR<SessionFMPACreateWithoutCentreInput, SessionFMPAUncheckedCreateWithoutCentreInput>
  }

  export type SessionFMPACreateManyCentreInputEnvelope = {
    data: SessionFMPACreateManyCentreInput | SessionFMPACreateManyCentreInput[]
    skipDuplicates?: boolean
  }

  export type MaterielCreateWithoutCentreInput = {
    codeInventaire: string
    libelle: string
    marque?: string | null
    modele?: string | null
    numeroSerie?: string | null
    dateAcquisition?: Date | string | null
    dateMiseService?: Date | string | null
    dateReforme?: Date | string | null
    etat?: $Enums.EtatMateriel
    periodiciteControleJours?: number | null
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    localisation?: string | null
    valeurAchat?: number | null
    fournisseur?: string | null
    numeroMarche?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categorie: CategorieMaterielCreateNestedOneWithoutMaterielsInput
    responsable?: PersonnelCreateNestedOneWithoutMaterielsResponsableInput
    incidents?: IncidentMaterielCreateNestedManyWithoutMaterielInput
  }

  export type MaterielUncheckedCreateWithoutCentreInput = {
    id?: number
    categorieId: number
    codeInventaire: string
    libelle: string
    marque?: string | null
    modele?: string | null
    numeroSerie?: string | null
    dateAcquisition?: Date | string | null
    dateMiseService?: Date | string | null
    dateReforme?: Date | string | null
    etat?: $Enums.EtatMateriel
    periodiciteControleJours?: number | null
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    localisation?: string | null
    responsableId?: number | null
    valeurAchat?: number | null
    fournisseur?: string | null
    numeroMarche?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    incidents?: IncidentMaterielUncheckedCreateNestedManyWithoutMaterielInput
  }

  export type MaterielCreateOrConnectWithoutCentreInput = {
    where: MaterielWhereUniqueInput
    create: XOR<MaterielCreateWithoutCentreInput, MaterielUncheckedCreateWithoutCentreInput>
  }

  export type MaterielCreateManyCentreInputEnvelope = {
    data: MaterielCreateManyCentreInput | MaterielCreateManyCentreInput[]
    skipDuplicates?: boolean
  }

  export type EvenementCreateWithoutCentreInput = {
    titre: string
    description?: string | null
    lieu?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    journeeEntiere?: boolean
    typeEvenement?: string | null
    visibilite?: $Enums.VisibiliteEvenement
    recurrent?: boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createur: PersonnelCreateNestedOneWithoutEvenementsCreeesInput
    participants?: EvenementParticipantCreateNestedManyWithoutEvenementInput
  }

  export type EvenementUncheckedCreateWithoutCentreInput = {
    id?: number
    createurId: number
    titre: string
    description?: string | null
    lieu?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    journeeEntiere?: boolean
    typeEvenement?: string | null
    visibilite?: $Enums.VisibiliteEvenement
    recurrent?: boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: EvenementParticipantUncheckedCreateNestedManyWithoutEvenementInput
  }

  export type EvenementCreateOrConnectWithoutCentreInput = {
    where: EvenementWhereUniqueInput
    create: XOR<EvenementCreateWithoutCentreInput, EvenementUncheckedCreateWithoutCentreInput>
  }

  export type EvenementCreateManyCentreInputEnvelope = {
    data: EvenementCreateManyCentreInput | EvenementCreateManyCentreInput[]
    skipDuplicates?: boolean
  }

  export type ExportTTACreateWithoutCentreInput = {
    periodeDebut: Date | string
    periodeFin: Date | string
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
    generePar: PersonnelCreateNestedOneWithoutExportsTTAGeneresInput
    validePar?: PersonnelCreateNestedOneWithoutExportsTTAValidesInput
    session?: SessionFMPACreateNestedOneWithoutExportsTTAInput
  }

  export type ExportTTAUncheckedCreateWithoutCentreInput = {
    id?: number
    periodeDebut: Date | string
    periodeFin: Date | string
    genereParId: number
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    valideParId?: number | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
    sessionId?: number | null
  }

  export type ExportTTACreateOrConnectWithoutCentreInput = {
    where: ExportTTAWhereUniqueInput
    create: XOR<ExportTTACreateWithoutCentreInput, ExportTTAUncheckedCreateWithoutCentreInput>
  }

  export type ExportTTACreateManyCentreInputEnvelope = {
    data: ExportTTACreateManyCentreInput | ExportTTACreateManyCentreInput[]
    skipDuplicates?: boolean
  }

  export type PersonnelUpsertWithWhereUniqueWithoutCentreInput = {
    where: PersonnelWhereUniqueInput
    update: XOR<PersonnelUpdateWithoutCentreInput, PersonnelUncheckedUpdateWithoutCentreInput>
    create: XOR<PersonnelCreateWithoutCentreInput, PersonnelUncheckedCreateWithoutCentreInput>
  }

  export type PersonnelUpdateWithWhereUniqueWithoutCentreInput = {
    where: PersonnelWhereUniqueInput
    data: XOR<PersonnelUpdateWithoutCentreInput, PersonnelUncheckedUpdateWithoutCentreInput>
  }

  export type PersonnelUpdateManyWithWhereWithoutCentreInput = {
    where: PersonnelScalarWhereInput
    data: XOR<PersonnelUpdateManyMutationInput, PersonnelUncheckedUpdateManyWithoutCentreInput>
  }

  export type SessionFMPAUpsertWithWhereUniqueWithoutCentreInput = {
    where: SessionFMPAWhereUniqueInput
    update: XOR<SessionFMPAUpdateWithoutCentreInput, SessionFMPAUncheckedUpdateWithoutCentreInput>
    create: XOR<SessionFMPACreateWithoutCentreInput, SessionFMPAUncheckedCreateWithoutCentreInput>
  }

  export type SessionFMPAUpdateWithWhereUniqueWithoutCentreInput = {
    where: SessionFMPAWhereUniqueInput
    data: XOR<SessionFMPAUpdateWithoutCentreInput, SessionFMPAUncheckedUpdateWithoutCentreInput>
  }

  export type SessionFMPAUpdateManyWithWhereWithoutCentreInput = {
    where: SessionFMPAScalarWhereInput
    data: XOR<SessionFMPAUpdateManyMutationInput, SessionFMPAUncheckedUpdateManyWithoutCentreInput>
  }

  export type SessionFMPAScalarWhereInput = {
    AND?: SessionFMPAScalarWhereInput | SessionFMPAScalarWhereInput[]
    OR?: SessionFMPAScalarWhereInput[]
    NOT?: SessionFMPAScalarWhereInput | SessionFMPAScalarWhereInput[]
    id?: IntFilter<"SessionFMPA"> | number
    typeFMPAId?: IntFilter<"SessionFMPA"> | number
    centreId?: IntNullableFilter<"SessionFMPA"> | number | null
    dateDebut?: DateTimeFilter<"SessionFMPA"> | Date | string
    dateFin?: DateTimeFilter<"SessionFMPA"> | Date | string
    lieu?: StringNullableFilter<"SessionFMPA"> | string | null
    nombrePlacesMax?: IntNullableFilter<"SessionFMPA"> | number | null
    nombreInscrits?: IntFilter<"SessionFMPA"> | number
    formateurPrincipalId?: IntFilter<"SessionFMPA"> | number
    statut?: EnumStatutSessionFilter<"SessionFMPA"> | $Enums.StatutSession
    codeTTA?: StringNullableFilter<"SessionFMPA"> | string | null
    tauxHoraire?: FloatNullableFilter<"SessionFMPA"> | number | null
    commentaires?: StringNullableFilter<"SessionFMPA"> | string | null
    createdAt?: DateTimeFilter<"SessionFMPA"> | Date | string
    updatedAt?: DateTimeFilter<"SessionFMPA"> | Date | string
  }

  export type MaterielUpsertWithWhereUniqueWithoutCentreInput = {
    where: MaterielWhereUniqueInput
    update: XOR<MaterielUpdateWithoutCentreInput, MaterielUncheckedUpdateWithoutCentreInput>
    create: XOR<MaterielCreateWithoutCentreInput, MaterielUncheckedCreateWithoutCentreInput>
  }

  export type MaterielUpdateWithWhereUniqueWithoutCentreInput = {
    where: MaterielWhereUniqueInput
    data: XOR<MaterielUpdateWithoutCentreInput, MaterielUncheckedUpdateWithoutCentreInput>
  }

  export type MaterielUpdateManyWithWhereWithoutCentreInput = {
    where: MaterielScalarWhereInput
    data: XOR<MaterielUpdateManyMutationInput, MaterielUncheckedUpdateManyWithoutCentreInput>
  }

  export type MaterielScalarWhereInput = {
    AND?: MaterielScalarWhereInput | MaterielScalarWhereInput[]
    OR?: MaterielScalarWhereInput[]
    NOT?: MaterielScalarWhereInput | MaterielScalarWhereInput[]
    id?: IntFilter<"Materiel"> | number
    categorieId?: IntFilter<"Materiel"> | number
    centreId?: IntNullableFilter<"Materiel"> | number | null
    codeInventaire?: StringFilter<"Materiel"> | string
    libelle?: StringFilter<"Materiel"> | string
    marque?: StringNullableFilter<"Materiel"> | string | null
    modele?: StringNullableFilter<"Materiel"> | string | null
    numeroSerie?: StringNullableFilter<"Materiel"> | string | null
    dateAcquisition?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    dateMiseService?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    dateReforme?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    etat?: EnumEtatMaterielFilter<"Materiel"> | $Enums.EtatMateriel
    periodiciteControleJours?: IntNullableFilter<"Materiel"> | number | null
    dateDernierControle?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    dateProchainControle?: DateTimeNullableFilter<"Materiel"> | Date | string | null
    localisation?: StringNullableFilter<"Materiel"> | string | null
    responsableId?: IntNullableFilter<"Materiel"> | number | null
    valeurAchat?: FloatNullableFilter<"Materiel"> | number | null
    fournisseur?: StringNullableFilter<"Materiel"> | string | null
    numeroMarche?: StringNullableFilter<"Materiel"> | string | null
    createdAt?: DateTimeFilter<"Materiel"> | Date | string
    updatedAt?: DateTimeFilter<"Materiel"> | Date | string
  }

  export type EvenementUpsertWithWhereUniqueWithoutCentreInput = {
    where: EvenementWhereUniqueInput
    update: XOR<EvenementUpdateWithoutCentreInput, EvenementUncheckedUpdateWithoutCentreInput>
    create: XOR<EvenementCreateWithoutCentreInput, EvenementUncheckedCreateWithoutCentreInput>
  }

  export type EvenementUpdateWithWhereUniqueWithoutCentreInput = {
    where: EvenementWhereUniqueInput
    data: XOR<EvenementUpdateWithoutCentreInput, EvenementUncheckedUpdateWithoutCentreInput>
  }

  export type EvenementUpdateManyWithWhereWithoutCentreInput = {
    where: EvenementScalarWhereInput
    data: XOR<EvenementUpdateManyMutationInput, EvenementUncheckedUpdateManyWithoutCentreInput>
  }

  export type EvenementScalarWhereInput = {
    AND?: EvenementScalarWhereInput | EvenementScalarWhereInput[]
    OR?: EvenementScalarWhereInput[]
    NOT?: EvenementScalarWhereInput | EvenementScalarWhereInput[]
    id?: IntFilter<"Evenement"> | number
    createurId?: IntFilter<"Evenement"> | number
    centreId?: IntNullableFilter<"Evenement"> | number | null
    titre?: StringFilter<"Evenement"> | string
    description?: StringNullableFilter<"Evenement"> | string | null
    lieu?: StringNullableFilter<"Evenement"> | string | null
    dateDebut?: DateTimeFilter<"Evenement"> | Date | string
    dateFin?: DateTimeFilter<"Evenement"> | Date | string
    journeeEntiere?: BoolFilter<"Evenement"> | boolean
    typeEvenement?: StringNullableFilter<"Evenement"> | string | null
    visibilite?: EnumVisibiliteEvenementFilter<"Evenement"> | $Enums.VisibiliteEvenement
    recurrent?: BoolFilter<"Evenement"> | boolean
    patternRecurrence?: JsonNullableFilter<"Evenement">
    couleur?: StringNullableFilter<"Evenement"> | string | null
    rappels?: JsonFilter<"Evenement">
    annule?: BoolFilter<"Evenement"> | boolean
    createdAt?: DateTimeFilter<"Evenement"> | Date | string
    updatedAt?: DateTimeFilter<"Evenement"> | Date | string
  }

  export type ExportTTAUpsertWithWhereUniqueWithoutCentreInput = {
    where: ExportTTAWhereUniqueInput
    update: XOR<ExportTTAUpdateWithoutCentreInput, ExportTTAUncheckedUpdateWithoutCentreInput>
    create: XOR<ExportTTACreateWithoutCentreInput, ExportTTAUncheckedCreateWithoutCentreInput>
  }

  export type ExportTTAUpdateWithWhereUniqueWithoutCentreInput = {
    where: ExportTTAWhereUniqueInput
    data: XOR<ExportTTAUpdateWithoutCentreInput, ExportTTAUncheckedUpdateWithoutCentreInput>
  }

  export type ExportTTAUpdateManyWithWhereWithoutCentreInput = {
    where: ExportTTAScalarWhereInput
    data: XOR<ExportTTAUpdateManyMutationInput, ExportTTAUncheckedUpdateManyWithoutCentreInput>
  }

  export type ExportTTAScalarWhereInput = {
    AND?: ExportTTAScalarWhereInput | ExportTTAScalarWhereInput[]
    OR?: ExportTTAScalarWhereInput[]
    NOT?: ExportTTAScalarWhereInput | ExportTTAScalarWhereInput[]
    id?: IntFilter<"ExportTTA"> | number
    periodeDebut?: DateTimeFilter<"ExportTTA"> | Date | string
    periodeFin?: DateTimeFilter<"ExportTTA"> | Date | string
    centreId?: IntNullableFilter<"ExportTTA"> | number | null
    genereParId?: IntFilter<"ExportTTA"> | number
    dateGeneration?: DateTimeFilter<"ExportTTA"> | Date | string
    nombreLignes?: IntNullableFilter<"ExportTTA"> | number | null
    montantTotal?: FloatNullableFilter<"ExportTTA"> | number | null
    fichierUrl?: StringNullableFilter<"ExportTTA"> | string | null
    formatExport?: EnumFormatExportFilter<"ExportTTA"> | $Enums.FormatExport
    statut?: EnumStatutExportFilter<"ExportTTA"> | $Enums.StatutExport
    dateValidation?: DateTimeNullableFilter<"ExportTTA"> | Date | string | null
    valideParId?: IntNullableFilter<"ExportTTA"> | number | null
    dateTransmission?: DateTimeNullableFilter<"ExportTTA"> | Date | string | null
    numeroBordereau?: StringNullableFilter<"ExportTTA"> | string | null
    commentaires?: StringNullableFilter<"ExportTTA"> | string | null
    sessionId?: IntNullableFilter<"ExportTTA"> | number | null
  }

  export type CentreCreateWithoutPersonnelsInput = {
    code: string
    nom: string
    type: $Enums.TypeCentre
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    telephone?: string | null
    email?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionFMPACreateNestedManyWithoutCentreInput
    materiels?: MaterielCreateNestedManyWithoutCentreInput
    evenements?: EvenementCreateNestedManyWithoutCentreInput
    exportsTTA?: ExportTTACreateNestedManyWithoutCentreInput
  }

  export type CentreUncheckedCreateWithoutPersonnelsInput = {
    id?: number
    code: string
    nom: string
    type: $Enums.TypeCentre
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    telephone?: string | null
    email?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionFMPAUncheckedCreateNestedManyWithoutCentreInput
    materiels?: MaterielUncheckedCreateNestedManyWithoutCentreInput
    evenements?: EvenementUncheckedCreateNestedManyWithoutCentreInput
    exportsTTA?: ExportTTAUncheckedCreateNestedManyWithoutCentreInput
  }

  export type CentreCreateOrConnectWithoutPersonnelsInput = {
    where: CentreWhereUniqueInput
    create: XOR<CentreCreateWithoutPersonnelsInput, CentreUncheckedCreateWithoutPersonnelsInput>
  }

  export type GradeCreateWithoutPersonnelsInput = {
    code: string
    libelle: string
    categorie: $Enums.Categorie
    ordreHierarchique: number
    actif?: boolean
  }

  export type GradeUncheckedCreateWithoutPersonnelsInput = {
    id?: number
    code: string
    libelle: string
    categorie: $Enums.Categorie
    ordreHierarchique: number
    actif?: boolean
  }

  export type GradeCreateOrConnectWithoutPersonnelsInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutPersonnelsInput, GradeUncheckedCreateWithoutPersonnelsInput>
  }

  export type PersonnelRoleCreateWithoutPersonnelInput = {
    dateAttribution?: Date | string
    dateFin?: Date | string | null
    role: RoleCreateNestedOneWithoutPersonnelsInput
  }

  export type PersonnelRoleUncheckedCreateWithoutPersonnelInput = {
    roleId: number
    dateAttribution?: Date | string
    dateFin?: Date | string | null
  }

  export type PersonnelRoleCreateOrConnectWithoutPersonnelInput = {
    where: PersonnelRoleWhereUniqueInput
    create: XOR<PersonnelRoleCreateWithoutPersonnelInput, PersonnelRoleUncheckedCreateWithoutPersonnelInput>
  }

  export type PersonnelRoleCreateManyPersonnelInputEnvelope = {
    data: PersonnelRoleCreateManyPersonnelInput | PersonnelRoleCreateManyPersonnelInput[]
    skipDuplicates?: boolean
  }

  export type PersonnelCompetenceCreateWithoutPersonnelInput = {
    dateObtention: Date | string
    dateExpiration?: Date | string | null
    niveau?: string | null
    numeroDiplome?: string | null
    organismeDelivrance?: string | null
    actif?: boolean
    createdAt?: Date | string
    typeCompetence: TypeCompetenceCreateNestedOneWithoutCompetencesInput
  }

  export type PersonnelCompetenceUncheckedCreateWithoutPersonnelInput = {
    id?: number
    typeCompetenceId: number
    dateObtention: Date | string
    dateExpiration?: Date | string | null
    niveau?: string | null
    numeroDiplome?: string | null
    organismeDelivrance?: string | null
    actif?: boolean
    createdAt?: Date | string
  }

  export type PersonnelCompetenceCreateOrConnectWithoutPersonnelInput = {
    where: PersonnelCompetenceWhereUniqueInput
    create: XOR<PersonnelCompetenceCreateWithoutPersonnelInput, PersonnelCompetenceUncheckedCreateWithoutPersonnelInput>
  }

  export type PersonnelCompetenceCreateManyPersonnelInputEnvelope = {
    data: PersonnelCompetenceCreateManyPersonnelInput | PersonnelCompetenceCreateManyPersonnelInput[]
    skipDuplicates?: boolean
  }

  export type AptitudeMedicaleCreateWithoutPersonnelInput = {
    dateVisite: Date | string
    dateProchaineVisite?: Date | string | null
    aptitude: $Enums.StatutAptitude
    restrictions?: string | null
    medecin?: string | null
    commentaires?: string | null
    createdAt?: Date | string
  }

  export type AptitudeMedicaleUncheckedCreateWithoutPersonnelInput = {
    id?: number
    dateVisite: Date | string
    dateProchaineVisite?: Date | string | null
    aptitude: $Enums.StatutAptitude
    restrictions?: string | null
    medecin?: string | null
    commentaires?: string | null
    createdAt?: Date | string
  }

  export type AptitudeMedicaleCreateOrConnectWithoutPersonnelInput = {
    where: AptitudeMedicaleWhereUniqueInput
    create: XOR<AptitudeMedicaleCreateWithoutPersonnelInput, AptitudeMedicaleUncheckedCreateWithoutPersonnelInput>
  }

  export type AptitudeMedicaleCreateManyPersonnelInputEnvelope = {
    data: AptitudeMedicaleCreateManyPersonnelInput | AptitudeMedicaleCreateManyPersonnelInput[]
    skipDuplicates?: boolean
  }

  export type InscriptionFMPACreateWithoutPersonnelInput = {
    dateInscription?: Date | string
    statutInscription?: $Enums.StatutInscription
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    signatureElectronique?: string | null
    dateSignature?: Date | string | null
    noteEvaluation?: number | null
    acquis?: boolean | null
    commentaireFormateur?: string | null
    heuresValidees?: number | null
    montantTTA?: number | null
    exportePaie?: boolean
    dateExportPaie?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: SessionFMPACreateNestedOneWithoutInscriptionsInput
  }

  export type InscriptionFMPAUncheckedCreateWithoutPersonnelInput = {
    id?: number
    sessionFMPAId: number
    dateInscription?: Date | string
    statutInscription?: $Enums.StatutInscription
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    signatureElectronique?: string | null
    dateSignature?: Date | string | null
    noteEvaluation?: number | null
    acquis?: boolean | null
    commentaireFormateur?: string | null
    heuresValidees?: number | null
    montantTTA?: number | null
    exportePaie?: boolean
    dateExportPaie?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InscriptionFMPACreateOrConnectWithoutPersonnelInput = {
    where: InscriptionFMPAWhereUniqueInput
    create: XOR<InscriptionFMPACreateWithoutPersonnelInput, InscriptionFMPAUncheckedCreateWithoutPersonnelInput>
  }

  export type InscriptionFMPACreateManyPersonnelInputEnvelope = {
    data: InscriptionFMPACreateManyPersonnelInput | InscriptionFMPACreateManyPersonnelInput[]
    skipDuplicates?: boolean
  }

  export type SessionFMPACreateWithoutFormateurPrincipalInput = {
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    typeFMPA: TypeFMPACreateNestedOneWithoutSessionsInput
    centre?: CentreCreateNestedOneWithoutSessionsInput
    formateursAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutSessionInput
    inscriptions?: InscriptionFMPACreateNestedManyWithoutSessionInput
    signatures?: SignatureFMPACreateNestedManyWithoutSessionInput
    exportsTTA?: ExportTTACreateNestedManyWithoutSessionInput
  }

  export type SessionFMPAUncheckedCreateWithoutFormateurPrincipalInput = {
    id?: number
    typeFMPAId: number
    centreId?: number | null
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    formateursAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutSessionInput
    inscriptions?: InscriptionFMPAUncheckedCreateNestedManyWithoutSessionInput
    signatures?: SignatureFMPAUncheckedCreateNestedManyWithoutSessionInput
    exportsTTA?: ExportTTAUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionFMPACreateOrConnectWithoutFormateurPrincipalInput = {
    where: SessionFMPAWhereUniqueInput
    create: XOR<SessionFMPACreateWithoutFormateurPrincipalInput, SessionFMPAUncheckedCreateWithoutFormateurPrincipalInput>
  }

  export type SessionFMPACreateManyFormateurPrincipalInputEnvelope = {
    data: SessionFMPACreateManyFormateurPrincipalInput | SessionFMPACreateManyFormateurPrincipalInput[]
    skipDuplicates?: boolean
  }

  export type SessionFMPAFormateurCreateWithoutPersonnelInput = {
    session: SessionFMPACreateNestedOneWithoutFormateursAdditionnelsInput
  }

  export type SessionFMPAFormateurUncheckedCreateWithoutPersonnelInput = {
    sessionId: number
  }

  export type SessionFMPAFormateurCreateOrConnectWithoutPersonnelInput = {
    where: SessionFMPAFormateurWhereUniqueInput
    create: XOR<SessionFMPAFormateurCreateWithoutPersonnelInput, SessionFMPAFormateurUncheckedCreateWithoutPersonnelInput>
  }

  export type SessionFMPAFormateurCreateManyPersonnelInputEnvelope = {
    data: SessionFMPAFormateurCreateManyPersonnelInput | SessionFMPAFormateurCreateManyPersonnelInput[]
    skipDuplicates?: boolean
  }

  export type SignatureFMPACreateWithoutPersonnelInput = {
    id?: string
    type: string
    signature: string
    dateSignature?: Date | string
    session: SessionFMPACreateNestedOneWithoutSignaturesInput
  }

  export type SignatureFMPAUncheckedCreateWithoutPersonnelInput = {
    id?: string
    sessionFMPAId: number
    type: string
    signature: string
    dateSignature?: Date | string
  }

  export type SignatureFMPACreateOrConnectWithoutPersonnelInput = {
    where: SignatureFMPAWhereUniqueInput
    create: XOR<SignatureFMPACreateWithoutPersonnelInput, SignatureFMPAUncheckedCreateWithoutPersonnelInput>
  }

  export type SignatureFMPACreateManyPersonnelInputEnvelope = {
    data: SignatureFMPACreateManyPersonnelInput | SignatureFMPACreateManyPersonnelInput[]
    skipDuplicates?: boolean
  }

  export type EPICreateWithoutPersonnelInput = {
    typeEPI: string
    taille?: string | null
    numeroSerie?: string | null
    dateAttribution: Date | string
    datePeremption?: Date | string | null
    etat?: $Enums.EtatEPI
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EPIUncheckedCreateWithoutPersonnelInput = {
    id?: number
    typeEPI: string
    taille?: string | null
    numeroSerie?: string | null
    dateAttribution: Date | string
    datePeremption?: Date | string | null
    etat?: $Enums.EtatEPI
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EPICreateOrConnectWithoutPersonnelInput = {
    where: EPIWhereUniqueInput
    create: XOR<EPICreateWithoutPersonnelInput, EPIUncheckedCreateWithoutPersonnelInput>
  }

  export type EPICreateManyPersonnelInputEnvelope = {
    data: EPICreateManyPersonnelInput | EPICreateManyPersonnelInput[]
    skipDuplicates?: boolean
  }

  export type MaterielCreateWithoutResponsableInput = {
    codeInventaire: string
    libelle: string
    marque?: string | null
    modele?: string | null
    numeroSerie?: string | null
    dateAcquisition?: Date | string | null
    dateMiseService?: Date | string | null
    dateReforme?: Date | string | null
    etat?: $Enums.EtatMateriel
    periodiciteControleJours?: number | null
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    localisation?: string | null
    valeurAchat?: number | null
    fournisseur?: string | null
    numeroMarche?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categorie: CategorieMaterielCreateNestedOneWithoutMaterielsInput
    centre?: CentreCreateNestedOneWithoutMaterielsInput
    incidents?: IncidentMaterielCreateNestedManyWithoutMaterielInput
  }

  export type MaterielUncheckedCreateWithoutResponsableInput = {
    id?: number
    categorieId: number
    centreId?: number | null
    codeInventaire: string
    libelle: string
    marque?: string | null
    modele?: string | null
    numeroSerie?: string | null
    dateAcquisition?: Date | string | null
    dateMiseService?: Date | string | null
    dateReforme?: Date | string | null
    etat?: $Enums.EtatMateriel
    periodiciteControleJours?: number | null
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    localisation?: string | null
    valeurAchat?: number | null
    fournisseur?: string | null
    numeroMarche?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    incidents?: IncidentMaterielUncheckedCreateNestedManyWithoutMaterielInput
  }

  export type MaterielCreateOrConnectWithoutResponsableInput = {
    where: MaterielWhereUniqueInput
    create: XOR<MaterielCreateWithoutResponsableInput, MaterielUncheckedCreateWithoutResponsableInput>
  }

  export type MaterielCreateManyResponsableInputEnvelope = {
    data: MaterielCreateManyResponsableInput | MaterielCreateManyResponsableInput[]
    skipDuplicates?: boolean
  }

  export type IncidentMaterielCreateWithoutSignaleParInput = {
    dateIncident?: Date | string
    typeIncident: $Enums.TypeIncident
    gravite: $Enums.GraviteIncident
    description: string
    photosUrls?: IncidentMaterielCreatephotosUrlsInput | string[]
    statut?: $Enums.StatutIncident
    dateResolution?: Date | string | null
    actionsCorrectives?: string | null
    coutReparation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materiel: MaterielCreateNestedOneWithoutIncidentsInput
    traitePar?: PersonnelCreateNestedOneWithoutIncidentsTraitesInput
  }

  export type IncidentMaterielUncheckedCreateWithoutSignaleParInput = {
    id?: number
    materielId: number
    dateIncident?: Date | string
    typeIncident: $Enums.TypeIncident
    gravite: $Enums.GraviteIncident
    description: string
    photosUrls?: IncidentMaterielCreatephotosUrlsInput | string[]
    statut?: $Enums.StatutIncident
    traiteParId?: number | null
    dateResolution?: Date | string | null
    actionsCorrectives?: string | null
    coutReparation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentMaterielCreateOrConnectWithoutSignaleParInput = {
    where: IncidentMaterielWhereUniqueInput
    create: XOR<IncidentMaterielCreateWithoutSignaleParInput, IncidentMaterielUncheckedCreateWithoutSignaleParInput>
  }

  export type IncidentMaterielCreateManySignaleParInputEnvelope = {
    data: IncidentMaterielCreateManySignaleParInput | IncidentMaterielCreateManySignaleParInput[]
    skipDuplicates?: boolean
  }

  export type IncidentMaterielCreateWithoutTraiteParInput = {
    dateIncident?: Date | string
    typeIncident: $Enums.TypeIncident
    gravite: $Enums.GraviteIncident
    description: string
    photosUrls?: IncidentMaterielCreatephotosUrlsInput | string[]
    statut?: $Enums.StatutIncident
    dateResolution?: Date | string | null
    actionsCorrectives?: string | null
    coutReparation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    materiel: MaterielCreateNestedOneWithoutIncidentsInput
    signalePar: PersonnelCreateNestedOneWithoutIncidentsSignalesInput
  }

  export type IncidentMaterielUncheckedCreateWithoutTraiteParInput = {
    id?: number
    materielId: number
    signaleParId: number
    dateIncident?: Date | string
    typeIncident: $Enums.TypeIncident
    gravite: $Enums.GraviteIncident
    description: string
    photosUrls?: IncidentMaterielCreatephotosUrlsInput | string[]
    statut?: $Enums.StatutIncident
    dateResolution?: Date | string | null
    actionsCorrectives?: string | null
    coutReparation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentMaterielCreateOrConnectWithoutTraiteParInput = {
    where: IncidentMaterielWhereUniqueInput
    create: XOR<IncidentMaterielCreateWithoutTraiteParInput, IncidentMaterielUncheckedCreateWithoutTraiteParInput>
  }

  export type IncidentMaterielCreateManyTraiteParInputEnvelope = {
    data: IncidentMaterielCreateManyTraiteParInput | IncidentMaterielCreateManyTraiteParInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutCreatedByInput = {
    type: $Enums.TypeConversation
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutCreatedByInput = {
    id?: number
    type: $Enums.TypeConversation
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutCreatedByInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput>
  }

  export type ConversationCreateManyCreatedByInputEnvelope = {
    data: ConversationCreateManyCreatedByInput | ConversationCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ConversationParticipantCreateWithoutPersonnelInput = {
    dateAjout?: Date | string
    dateSortie?: Date | string | null
    role?: $Enums.RoleConversation
    notificationsActives?: boolean
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutPersonnelInput = {
    conversationId: number
    dateAjout?: Date | string
    dateSortie?: Date | string | null
    role?: $Enums.RoleConversation
    notificationsActives?: boolean
  }

  export type ConversationParticipantCreateOrConnectWithoutPersonnelInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutPersonnelInput, ConversationParticipantUncheckedCreateWithoutPersonnelInput>
  }

  export type ConversationParticipantCreateManyPersonnelInputEnvelope = {
    data: ConversationParticipantCreateManyPersonnelInput | ConversationParticipantCreateManyPersonnelInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutExpediteurInput = {
    contenu: string
    typeMessage?: $Enums.TypeMessage
    fichierUrl?: string | null
    typeInteractif?: string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    messagesLus?: MessageLuCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutExpediteurInput = {
    id?: number
    conversationId: number
    contenu: string
    typeMessage?: $Enums.TypeMessage
    fichierUrl?: string | null
    typeInteractif?: string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutExpediteurInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutExpediteurInput, MessageUncheckedCreateWithoutExpediteurInput>
  }

  export type MessageCreateManyExpediteurInputEnvelope = {
    data: MessageCreateManyExpediteurInput | MessageCreateManyExpediteurInput[]
    skipDuplicates?: boolean
  }

  export type MessageLuCreateWithoutPersonnelInput = {
    dateLecture?: Date | string
    message: MessageCreateNestedOneWithoutMessagesLusInput
  }

  export type MessageLuUncheckedCreateWithoutPersonnelInput = {
    messageId: number
    dateLecture?: Date | string
  }

  export type MessageLuCreateOrConnectWithoutPersonnelInput = {
    where: MessageLuWhereUniqueInput
    create: XOR<MessageLuCreateWithoutPersonnelInput, MessageLuUncheckedCreateWithoutPersonnelInput>
  }

  export type MessageLuCreateManyPersonnelInputEnvelope = {
    data: MessageLuCreateManyPersonnelInput | MessageLuCreateManyPersonnelInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutDestinataireInput = {
    typeNotification: string
    titre: string
    message: string
    niveau?: $Enums.NiveauNotification
    entiteType?: string | null
    entiteId?: number | null
    donneesSupplementaires?: NullableJsonNullValueInput | InputJsonValue
    lue?: boolean
    dateLecture?: Date | string | null
    envoyeePush?: boolean
    envoyeeEmail?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutDestinataireInput = {
    id?: number
    typeNotification: string
    titre: string
    message: string
    niveau?: $Enums.NiveauNotification
    entiteType?: string | null
    entiteId?: number | null
    donneesSupplementaires?: NullableJsonNullValueInput | InputJsonValue
    lue?: boolean
    dateLecture?: Date | string | null
    envoyeePush?: boolean
    envoyeeEmail?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutDestinataireInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutDestinataireInput, NotificationUncheckedCreateWithoutDestinataireInput>
  }

  export type NotificationCreateManyDestinataireInputEnvelope = {
    data: NotificationCreateManyDestinataireInput | NotificationCreateManyDestinataireInput[]
    skipDuplicates?: boolean
  }

  export type EvenementCreateWithoutCreateurInput = {
    titre: string
    description?: string | null
    lieu?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    journeeEntiere?: boolean
    typeEvenement?: string | null
    visibilite?: $Enums.VisibiliteEvenement
    recurrent?: boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    centre?: CentreCreateNestedOneWithoutEvenementsInput
    participants?: EvenementParticipantCreateNestedManyWithoutEvenementInput
  }

  export type EvenementUncheckedCreateWithoutCreateurInput = {
    id?: number
    centreId?: number | null
    titre: string
    description?: string | null
    lieu?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    journeeEntiere?: boolean
    typeEvenement?: string | null
    visibilite?: $Enums.VisibiliteEvenement
    recurrent?: boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: EvenementParticipantUncheckedCreateNestedManyWithoutEvenementInput
  }

  export type EvenementCreateOrConnectWithoutCreateurInput = {
    where: EvenementWhereUniqueInput
    create: XOR<EvenementCreateWithoutCreateurInput, EvenementUncheckedCreateWithoutCreateurInput>
  }

  export type EvenementCreateManyCreateurInputEnvelope = {
    data: EvenementCreateManyCreateurInput | EvenementCreateManyCreateurInput[]
    skipDuplicates?: boolean
  }

  export type EvenementParticipantCreateWithoutPersonnelInput = {
    statutInvitation?: $Enums.StatutInvitation
    obligatoire?: boolean
    dateReponse?: Date | string | null
    commentaire?: string | null
    evenement: EvenementCreateNestedOneWithoutParticipantsInput
  }

  export type EvenementParticipantUncheckedCreateWithoutPersonnelInput = {
    evenementId: number
    statutInvitation?: $Enums.StatutInvitation
    obligatoire?: boolean
    dateReponse?: Date | string | null
    commentaire?: string | null
  }

  export type EvenementParticipantCreateOrConnectWithoutPersonnelInput = {
    where: EvenementParticipantWhereUniqueInput
    create: XOR<EvenementParticipantCreateWithoutPersonnelInput, EvenementParticipantUncheckedCreateWithoutPersonnelInput>
  }

  export type EvenementParticipantCreateManyPersonnelInputEnvelope = {
    data: EvenementParticipantCreateManyPersonnelInput | EvenementParticipantCreateManyPersonnelInput[]
    skipDuplicates?: boolean
  }

  export type ExportTTACreateWithoutGenereParInput = {
    periodeDebut: Date | string
    periodeFin: Date | string
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
    centre?: CentreCreateNestedOneWithoutExportsTTAInput
    validePar?: PersonnelCreateNestedOneWithoutExportsTTAValidesInput
    session?: SessionFMPACreateNestedOneWithoutExportsTTAInput
  }

  export type ExportTTAUncheckedCreateWithoutGenereParInput = {
    id?: number
    periodeDebut: Date | string
    periodeFin: Date | string
    centreId?: number | null
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    valideParId?: number | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
    sessionId?: number | null
  }

  export type ExportTTACreateOrConnectWithoutGenereParInput = {
    where: ExportTTAWhereUniqueInput
    create: XOR<ExportTTACreateWithoutGenereParInput, ExportTTAUncheckedCreateWithoutGenereParInput>
  }

  export type ExportTTACreateManyGenereParInputEnvelope = {
    data: ExportTTACreateManyGenereParInput | ExportTTACreateManyGenereParInput[]
    skipDuplicates?: boolean
  }

  export type ExportTTACreateWithoutValideParInput = {
    periodeDebut: Date | string
    periodeFin: Date | string
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
    centre?: CentreCreateNestedOneWithoutExportsTTAInput
    generePar: PersonnelCreateNestedOneWithoutExportsTTAGeneresInput
    session?: SessionFMPACreateNestedOneWithoutExportsTTAInput
  }

  export type ExportTTAUncheckedCreateWithoutValideParInput = {
    id?: number
    periodeDebut: Date | string
    periodeFin: Date | string
    centreId?: number | null
    genereParId: number
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
    sessionId?: number | null
  }

  export type ExportTTACreateOrConnectWithoutValideParInput = {
    where: ExportTTAWhereUniqueInput
    create: XOR<ExportTTACreateWithoutValideParInput, ExportTTAUncheckedCreateWithoutValideParInput>
  }

  export type ExportTTACreateManyValideParInputEnvelope = {
    data: ExportTTACreateManyValideParInput | ExportTTACreateManyValideParInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUtilisateurInput = {
    id?: string
    action: string
    entiteType: string
    entiteId?: number | null
    anciennesValeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvellesValeurs?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUtilisateurInput = {
    id?: string
    action: string
    entiteType: string
    entiteId?: number | null
    anciennesValeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvellesValeurs?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUtilisateurInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUtilisateurInput, AuditLogUncheckedCreateWithoutUtilisateurInput>
  }

  export type AuditLogCreateManyUtilisateurInputEnvelope = {
    data: AuditLogCreateManyUtilisateurInput | AuditLogCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type CentreUpsertWithoutPersonnelsInput = {
    update: XOR<CentreUpdateWithoutPersonnelsInput, CentreUncheckedUpdateWithoutPersonnelsInput>
    create: XOR<CentreCreateWithoutPersonnelsInput, CentreUncheckedCreateWithoutPersonnelsInput>
    where?: CentreWhereInput
  }

  export type CentreUpdateToOneWithWhereWithoutPersonnelsInput = {
    where?: CentreWhereInput
    data: XOR<CentreUpdateWithoutPersonnelsInput, CentreUncheckedUpdateWithoutPersonnelsInput>
  }

  export type CentreUpdateWithoutPersonnelsInput = {
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCentreFieldUpdateOperationsInput | $Enums.TypeCentre
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionFMPAUpdateManyWithoutCentreNestedInput
    materiels?: MaterielUpdateManyWithoutCentreNestedInput
    evenements?: EvenementUpdateManyWithoutCentreNestedInput
    exportsTTA?: ExportTTAUpdateManyWithoutCentreNestedInput
  }

  export type CentreUncheckedUpdateWithoutPersonnelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCentreFieldUpdateOperationsInput | $Enums.TypeCentre
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionFMPAUncheckedUpdateManyWithoutCentreNestedInput
    materiels?: MaterielUncheckedUpdateManyWithoutCentreNestedInput
    evenements?: EvenementUncheckedUpdateManyWithoutCentreNestedInput
    exportsTTA?: ExportTTAUncheckedUpdateManyWithoutCentreNestedInput
  }

  export type GradeUpsertWithoutPersonnelsInput = {
    update: XOR<GradeUpdateWithoutPersonnelsInput, GradeUncheckedUpdateWithoutPersonnelsInput>
    create: XOR<GradeCreateWithoutPersonnelsInput, GradeUncheckedCreateWithoutPersonnelsInput>
    where?: GradeWhereInput
  }

  export type GradeUpdateToOneWithWhereWithoutPersonnelsInput = {
    where?: GradeWhereInput
    data: XOR<GradeUpdateWithoutPersonnelsInput, GradeUncheckedUpdateWithoutPersonnelsInput>
  }

  export type GradeUpdateWithoutPersonnelsInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    ordreHierarchique?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GradeUncheckedUpdateWithoutPersonnelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    ordreHierarchique?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersonnelRoleUpsertWithWhereUniqueWithoutPersonnelInput = {
    where: PersonnelRoleWhereUniqueInput
    update: XOR<PersonnelRoleUpdateWithoutPersonnelInput, PersonnelRoleUncheckedUpdateWithoutPersonnelInput>
    create: XOR<PersonnelRoleCreateWithoutPersonnelInput, PersonnelRoleUncheckedCreateWithoutPersonnelInput>
  }

  export type PersonnelRoleUpdateWithWhereUniqueWithoutPersonnelInput = {
    where: PersonnelRoleWhereUniqueInput
    data: XOR<PersonnelRoleUpdateWithoutPersonnelInput, PersonnelRoleUncheckedUpdateWithoutPersonnelInput>
  }

  export type PersonnelRoleUpdateManyWithWhereWithoutPersonnelInput = {
    where: PersonnelRoleScalarWhereInput
    data: XOR<PersonnelRoleUpdateManyMutationInput, PersonnelRoleUncheckedUpdateManyWithoutPersonnelInput>
  }

  export type PersonnelRoleScalarWhereInput = {
    AND?: PersonnelRoleScalarWhereInput | PersonnelRoleScalarWhereInput[]
    OR?: PersonnelRoleScalarWhereInput[]
    NOT?: PersonnelRoleScalarWhereInput | PersonnelRoleScalarWhereInput[]
    personnelId?: IntFilter<"PersonnelRole"> | number
    roleId?: IntFilter<"PersonnelRole"> | number
    dateAttribution?: DateTimeFilter<"PersonnelRole"> | Date | string
    dateFin?: DateTimeNullableFilter<"PersonnelRole"> | Date | string | null
  }

  export type PersonnelCompetenceUpsertWithWhereUniqueWithoutPersonnelInput = {
    where: PersonnelCompetenceWhereUniqueInput
    update: XOR<PersonnelCompetenceUpdateWithoutPersonnelInput, PersonnelCompetenceUncheckedUpdateWithoutPersonnelInput>
    create: XOR<PersonnelCompetenceCreateWithoutPersonnelInput, PersonnelCompetenceUncheckedCreateWithoutPersonnelInput>
  }

  export type PersonnelCompetenceUpdateWithWhereUniqueWithoutPersonnelInput = {
    where: PersonnelCompetenceWhereUniqueInput
    data: XOR<PersonnelCompetenceUpdateWithoutPersonnelInput, PersonnelCompetenceUncheckedUpdateWithoutPersonnelInput>
  }

  export type PersonnelCompetenceUpdateManyWithWhereWithoutPersonnelInput = {
    where: PersonnelCompetenceScalarWhereInput
    data: XOR<PersonnelCompetenceUpdateManyMutationInput, PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelInput>
  }

  export type PersonnelCompetenceScalarWhereInput = {
    AND?: PersonnelCompetenceScalarWhereInput | PersonnelCompetenceScalarWhereInput[]
    OR?: PersonnelCompetenceScalarWhereInput[]
    NOT?: PersonnelCompetenceScalarWhereInput | PersonnelCompetenceScalarWhereInput[]
    id?: IntFilter<"PersonnelCompetence"> | number
    personnelId?: IntFilter<"PersonnelCompetence"> | number
    typeCompetenceId?: IntFilter<"PersonnelCompetence"> | number
    dateObtention?: DateTimeFilter<"PersonnelCompetence"> | Date | string
    dateExpiration?: DateTimeNullableFilter<"PersonnelCompetence"> | Date | string | null
    niveau?: StringNullableFilter<"PersonnelCompetence"> | string | null
    numeroDiplome?: StringNullableFilter<"PersonnelCompetence"> | string | null
    organismeDelivrance?: StringNullableFilter<"PersonnelCompetence"> | string | null
    actif?: BoolFilter<"PersonnelCompetence"> | boolean
    createdAt?: DateTimeFilter<"PersonnelCompetence"> | Date | string
  }

  export type AptitudeMedicaleUpsertWithWhereUniqueWithoutPersonnelInput = {
    where: AptitudeMedicaleWhereUniqueInput
    update: XOR<AptitudeMedicaleUpdateWithoutPersonnelInput, AptitudeMedicaleUncheckedUpdateWithoutPersonnelInput>
    create: XOR<AptitudeMedicaleCreateWithoutPersonnelInput, AptitudeMedicaleUncheckedCreateWithoutPersonnelInput>
  }

  export type AptitudeMedicaleUpdateWithWhereUniqueWithoutPersonnelInput = {
    where: AptitudeMedicaleWhereUniqueInput
    data: XOR<AptitudeMedicaleUpdateWithoutPersonnelInput, AptitudeMedicaleUncheckedUpdateWithoutPersonnelInput>
  }

  export type AptitudeMedicaleUpdateManyWithWhereWithoutPersonnelInput = {
    where: AptitudeMedicaleScalarWhereInput
    data: XOR<AptitudeMedicaleUpdateManyMutationInput, AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelInput>
  }

  export type AptitudeMedicaleScalarWhereInput = {
    AND?: AptitudeMedicaleScalarWhereInput | AptitudeMedicaleScalarWhereInput[]
    OR?: AptitudeMedicaleScalarWhereInput[]
    NOT?: AptitudeMedicaleScalarWhereInput | AptitudeMedicaleScalarWhereInput[]
    id?: IntFilter<"AptitudeMedicale"> | number
    personnelId?: IntFilter<"AptitudeMedicale"> | number
    dateVisite?: DateTimeFilter<"AptitudeMedicale"> | Date | string
    dateProchaineVisite?: DateTimeNullableFilter<"AptitudeMedicale"> | Date | string | null
    aptitude?: EnumStatutAptitudeFilter<"AptitudeMedicale"> | $Enums.StatutAptitude
    restrictions?: StringNullableFilter<"AptitudeMedicale"> | string | null
    medecin?: StringNullableFilter<"AptitudeMedicale"> | string | null
    commentaires?: StringNullableFilter<"AptitudeMedicale"> | string | null
    createdAt?: DateTimeFilter<"AptitudeMedicale"> | Date | string
  }

  export type InscriptionFMPAUpsertWithWhereUniqueWithoutPersonnelInput = {
    where: InscriptionFMPAWhereUniqueInput
    update: XOR<InscriptionFMPAUpdateWithoutPersonnelInput, InscriptionFMPAUncheckedUpdateWithoutPersonnelInput>
    create: XOR<InscriptionFMPACreateWithoutPersonnelInput, InscriptionFMPAUncheckedCreateWithoutPersonnelInput>
  }

  export type InscriptionFMPAUpdateWithWhereUniqueWithoutPersonnelInput = {
    where: InscriptionFMPAWhereUniqueInput
    data: XOR<InscriptionFMPAUpdateWithoutPersonnelInput, InscriptionFMPAUncheckedUpdateWithoutPersonnelInput>
  }

  export type InscriptionFMPAUpdateManyWithWhereWithoutPersonnelInput = {
    where: InscriptionFMPAScalarWhereInput
    data: XOR<InscriptionFMPAUpdateManyMutationInput, InscriptionFMPAUncheckedUpdateManyWithoutPersonnelInput>
  }

  export type InscriptionFMPAScalarWhereInput = {
    AND?: InscriptionFMPAScalarWhereInput | InscriptionFMPAScalarWhereInput[]
    OR?: InscriptionFMPAScalarWhereInput[]
    NOT?: InscriptionFMPAScalarWhereInput | InscriptionFMPAScalarWhereInput[]
    id?: IntFilter<"InscriptionFMPA"> | number
    sessionFMPAId?: IntFilter<"InscriptionFMPA"> | number
    personnelId?: IntFilter<"InscriptionFMPA"> | number
    dateInscription?: DateTimeFilter<"InscriptionFMPA"> | Date | string
    statutInscription?: EnumStatutInscriptionFilter<"InscriptionFMPA"> | $Enums.StatutInscription
    heureArrivee?: DateTimeNullableFilter<"InscriptionFMPA"> | Date | string | null
    heureDepart?: DateTimeNullableFilter<"InscriptionFMPA"> | Date | string | null
    signatureElectronique?: StringNullableFilter<"InscriptionFMPA"> | string | null
    dateSignature?: DateTimeNullableFilter<"InscriptionFMPA"> | Date | string | null
    noteEvaluation?: FloatNullableFilter<"InscriptionFMPA"> | number | null
    acquis?: BoolNullableFilter<"InscriptionFMPA"> | boolean | null
    commentaireFormateur?: StringNullableFilter<"InscriptionFMPA"> | string | null
    heuresValidees?: FloatNullableFilter<"InscriptionFMPA"> | number | null
    montantTTA?: FloatNullableFilter<"InscriptionFMPA"> | number | null
    exportePaie?: BoolFilter<"InscriptionFMPA"> | boolean
    dateExportPaie?: DateTimeNullableFilter<"InscriptionFMPA"> | Date | string | null
    createdAt?: DateTimeFilter<"InscriptionFMPA"> | Date | string
    updatedAt?: DateTimeFilter<"InscriptionFMPA"> | Date | string
  }

  export type SessionFMPAUpsertWithWhereUniqueWithoutFormateurPrincipalInput = {
    where: SessionFMPAWhereUniqueInput
    update: XOR<SessionFMPAUpdateWithoutFormateurPrincipalInput, SessionFMPAUncheckedUpdateWithoutFormateurPrincipalInput>
    create: XOR<SessionFMPACreateWithoutFormateurPrincipalInput, SessionFMPAUncheckedCreateWithoutFormateurPrincipalInput>
  }

  export type SessionFMPAUpdateWithWhereUniqueWithoutFormateurPrincipalInput = {
    where: SessionFMPAWhereUniqueInput
    data: XOR<SessionFMPAUpdateWithoutFormateurPrincipalInput, SessionFMPAUncheckedUpdateWithoutFormateurPrincipalInput>
  }

  export type SessionFMPAUpdateManyWithWhereWithoutFormateurPrincipalInput = {
    where: SessionFMPAScalarWhereInput
    data: XOR<SessionFMPAUpdateManyMutationInput, SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalInput>
  }

  export type SessionFMPAFormateurUpsertWithWhereUniqueWithoutPersonnelInput = {
    where: SessionFMPAFormateurWhereUniqueInput
    update: XOR<SessionFMPAFormateurUpdateWithoutPersonnelInput, SessionFMPAFormateurUncheckedUpdateWithoutPersonnelInput>
    create: XOR<SessionFMPAFormateurCreateWithoutPersonnelInput, SessionFMPAFormateurUncheckedCreateWithoutPersonnelInput>
  }

  export type SessionFMPAFormateurUpdateWithWhereUniqueWithoutPersonnelInput = {
    where: SessionFMPAFormateurWhereUniqueInput
    data: XOR<SessionFMPAFormateurUpdateWithoutPersonnelInput, SessionFMPAFormateurUncheckedUpdateWithoutPersonnelInput>
  }

  export type SessionFMPAFormateurUpdateManyWithWhereWithoutPersonnelInput = {
    where: SessionFMPAFormateurScalarWhereInput
    data: XOR<SessionFMPAFormateurUpdateManyMutationInput, SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelInput>
  }

  export type SessionFMPAFormateurScalarWhereInput = {
    AND?: SessionFMPAFormateurScalarWhereInput | SessionFMPAFormateurScalarWhereInput[]
    OR?: SessionFMPAFormateurScalarWhereInput[]
    NOT?: SessionFMPAFormateurScalarWhereInput | SessionFMPAFormateurScalarWhereInput[]
    sessionId?: IntFilter<"SessionFMPAFormateur"> | number
    personnelId?: IntFilter<"SessionFMPAFormateur"> | number
  }

  export type SignatureFMPAUpsertWithWhereUniqueWithoutPersonnelInput = {
    where: SignatureFMPAWhereUniqueInput
    update: XOR<SignatureFMPAUpdateWithoutPersonnelInput, SignatureFMPAUncheckedUpdateWithoutPersonnelInput>
    create: XOR<SignatureFMPACreateWithoutPersonnelInput, SignatureFMPAUncheckedCreateWithoutPersonnelInput>
  }

  export type SignatureFMPAUpdateWithWhereUniqueWithoutPersonnelInput = {
    where: SignatureFMPAWhereUniqueInput
    data: XOR<SignatureFMPAUpdateWithoutPersonnelInput, SignatureFMPAUncheckedUpdateWithoutPersonnelInput>
  }

  export type SignatureFMPAUpdateManyWithWhereWithoutPersonnelInput = {
    where: SignatureFMPAScalarWhereInput
    data: XOR<SignatureFMPAUpdateManyMutationInput, SignatureFMPAUncheckedUpdateManyWithoutPersonnelInput>
  }

  export type SignatureFMPAScalarWhereInput = {
    AND?: SignatureFMPAScalarWhereInput | SignatureFMPAScalarWhereInput[]
    OR?: SignatureFMPAScalarWhereInput[]
    NOT?: SignatureFMPAScalarWhereInput | SignatureFMPAScalarWhereInput[]
    id?: StringFilter<"SignatureFMPA"> | string
    sessionFMPAId?: IntFilter<"SignatureFMPA"> | number
    personnelId?: IntFilter<"SignatureFMPA"> | number
    type?: StringFilter<"SignatureFMPA"> | string
    signature?: StringFilter<"SignatureFMPA"> | string
    dateSignature?: DateTimeFilter<"SignatureFMPA"> | Date | string
  }

  export type EPIUpsertWithWhereUniqueWithoutPersonnelInput = {
    where: EPIWhereUniqueInput
    update: XOR<EPIUpdateWithoutPersonnelInput, EPIUncheckedUpdateWithoutPersonnelInput>
    create: XOR<EPICreateWithoutPersonnelInput, EPIUncheckedCreateWithoutPersonnelInput>
  }

  export type EPIUpdateWithWhereUniqueWithoutPersonnelInput = {
    where: EPIWhereUniqueInput
    data: XOR<EPIUpdateWithoutPersonnelInput, EPIUncheckedUpdateWithoutPersonnelInput>
  }

  export type EPIUpdateManyWithWhereWithoutPersonnelInput = {
    where: EPIScalarWhereInput
    data: XOR<EPIUpdateManyMutationInput, EPIUncheckedUpdateManyWithoutPersonnelInput>
  }

  export type EPIScalarWhereInput = {
    AND?: EPIScalarWhereInput | EPIScalarWhereInput[]
    OR?: EPIScalarWhereInput[]
    NOT?: EPIScalarWhereInput | EPIScalarWhereInput[]
    id?: IntFilter<"EPI"> | number
    personnelId?: IntFilter<"EPI"> | number
    typeEPI?: StringFilter<"EPI"> | string
    taille?: StringNullableFilter<"EPI"> | string | null
    numeroSerie?: StringNullableFilter<"EPI"> | string | null
    dateAttribution?: DateTimeFilter<"EPI"> | Date | string
    datePeremption?: DateTimeNullableFilter<"EPI"> | Date | string | null
    etat?: EnumEtatEPIFilter<"EPI"> | $Enums.EtatEPI
    dateDernierControle?: DateTimeNullableFilter<"EPI"> | Date | string | null
    dateProchainControle?: DateTimeNullableFilter<"EPI"> | Date | string | null
    actif?: BoolFilter<"EPI"> | boolean
    createdAt?: DateTimeFilter<"EPI"> | Date | string
    updatedAt?: DateTimeFilter<"EPI"> | Date | string
  }

  export type MaterielUpsertWithWhereUniqueWithoutResponsableInput = {
    where: MaterielWhereUniqueInput
    update: XOR<MaterielUpdateWithoutResponsableInput, MaterielUncheckedUpdateWithoutResponsableInput>
    create: XOR<MaterielCreateWithoutResponsableInput, MaterielUncheckedCreateWithoutResponsableInput>
  }

  export type MaterielUpdateWithWhereUniqueWithoutResponsableInput = {
    where: MaterielWhereUniqueInput
    data: XOR<MaterielUpdateWithoutResponsableInput, MaterielUncheckedUpdateWithoutResponsableInput>
  }

  export type MaterielUpdateManyWithWhereWithoutResponsableInput = {
    where: MaterielScalarWhereInput
    data: XOR<MaterielUpdateManyMutationInput, MaterielUncheckedUpdateManyWithoutResponsableInput>
  }

  export type IncidentMaterielUpsertWithWhereUniqueWithoutSignaleParInput = {
    where: IncidentMaterielWhereUniqueInput
    update: XOR<IncidentMaterielUpdateWithoutSignaleParInput, IncidentMaterielUncheckedUpdateWithoutSignaleParInput>
    create: XOR<IncidentMaterielCreateWithoutSignaleParInput, IncidentMaterielUncheckedCreateWithoutSignaleParInput>
  }

  export type IncidentMaterielUpdateWithWhereUniqueWithoutSignaleParInput = {
    where: IncidentMaterielWhereUniqueInput
    data: XOR<IncidentMaterielUpdateWithoutSignaleParInput, IncidentMaterielUncheckedUpdateWithoutSignaleParInput>
  }

  export type IncidentMaterielUpdateManyWithWhereWithoutSignaleParInput = {
    where: IncidentMaterielScalarWhereInput
    data: XOR<IncidentMaterielUpdateManyMutationInput, IncidentMaterielUncheckedUpdateManyWithoutSignaleParInput>
  }

  export type IncidentMaterielScalarWhereInput = {
    AND?: IncidentMaterielScalarWhereInput | IncidentMaterielScalarWhereInput[]
    OR?: IncidentMaterielScalarWhereInput[]
    NOT?: IncidentMaterielScalarWhereInput | IncidentMaterielScalarWhereInput[]
    id?: IntFilter<"IncidentMateriel"> | number
    materielId?: IntFilter<"IncidentMateriel"> | number
    signaleParId?: IntFilter<"IncidentMateriel"> | number
    dateIncident?: DateTimeFilter<"IncidentMateriel"> | Date | string
    typeIncident?: EnumTypeIncidentFilter<"IncidentMateriel"> | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFilter<"IncidentMateriel"> | $Enums.GraviteIncident
    description?: StringFilter<"IncidentMateriel"> | string
    photosUrls?: StringNullableListFilter<"IncidentMateriel">
    statut?: EnumStatutIncidentFilter<"IncidentMateriel"> | $Enums.StatutIncident
    traiteParId?: IntNullableFilter<"IncidentMateriel"> | number | null
    dateResolution?: DateTimeNullableFilter<"IncidentMateriel"> | Date | string | null
    actionsCorrectives?: StringNullableFilter<"IncidentMateriel"> | string | null
    coutReparation?: FloatNullableFilter<"IncidentMateriel"> | number | null
    createdAt?: DateTimeFilter<"IncidentMateriel"> | Date | string
    updatedAt?: DateTimeFilter<"IncidentMateriel"> | Date | string
  }

  export type IncidentMaterielUpsertWithWhereUniqueWithoutTraiteParInput = {
    where: IncidentMaterielWhereUniqueInput
    update: XOR<IncidentMaterielUpdateWithoutTraiteParInput, IncidentMaterielUncheckedUpdateWithoutTraiteParInput>
    create: XOR<IncidentMaterielCreateWithoutTraiteParInput, IncidentMaterielUncheckedCreateWithoutTraiteParInput>
  }

  export type IncidentMaterielUpdateWithWhereUniqueWithoutTraiteParInput = {
    where: IncidentMaterielWhereUniqueInput
    data: XOR<IncidentMaterielUpdateWithoutTraiteParInput, IncidentMaterielUncheckedUpdateWithoutTraiteParInput>
  }

  export type IncidentMaterielUpdateManyWithWhereWithoutTraiteParInput = {
    where: IncidentMaterielScalarWhereInput
    data: XOR<IncidentMaterielUpdateManyMutationInput, IncidentMaterielUncheckedUpdateManyWithoutTraiteParInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutCreatedByInput, ConversationUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutCreatedByInput, ConversationUncheckedUpdateWithoutCreatedByInput>
  }

  export type ConversationUpdateManyWithWhereWithoutCreatedByInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: IntFilter<"Conversation"> | number
    type?: EnumTypeConversationFilter<"Conversation"> | $Enums.TypeConversation
    nom?: StringNullableFilter<"Conversation"> | string | null
    createdById?: IntFilter<"Conversation"> | number
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutPersonnelInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutPersonnelInput, ConversationParticipantUncheckedUpdateWithoutPersonnelInput>
    create: XOR<ConversationParticipantCreateWithoutPersonnelInput, ConversationParticipantUncheckedCreateWithoutPersonnelInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutPersonnelInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutPersonnelInput, ConversationParticipantUncheckedUpdateWithoutPersonnelInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutPersonnelInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutPersonnelInput>
  }

  export type ConversationParticipantScalarWhereInput = {
    AND?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    OR?: ConversationParticipantScalarWhereInput[]
    NOT?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    conversationId?: IntFilter<"ConversationParticipant"> | number
    personnelId?: IntFilter<"ConversationParticipant"> | number
    dateAjout?: DateTimeFilter<"ConversationParticipant"> | Date | string
    dateSortie?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
    role?: EnumRoleConversationFilter<"ConversationParticipant"> | $Enums.RoleConversation
    notificationsActives?: BoolFilter<"ConversationParticipant"> | boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutExpediteurInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutExpediteurInput, MessageUncheckedUpdateWithoutExpediteurInput>
    create: XOR<MessageCreateWithoutExpediteurInput, MessageUncheckedCreateWithoutExpediteurInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutExpediteurInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutExpediteurInput, MessageUncheckedUpdateWithoutExpediteurInput>
  }

  export type MessageUpdateManyWithWhereWithoutExpediteurInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutExpediteurInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: IntFilter<"Message"> | number
    conversationId?: IntFilter<"Message"> | number
    expediteurId?: IntFilter<"Message"> | number
    contenu?: StringFilter<"Message"> | string
    typeMessage?: EnumTypeMessageFilter<"Message"> | $Enums.TypeMessage
    fichierUrl?: StringNullableFilter<"Message"> | string | null
    typeInteractif?: StringNullableFilter<"Message"> | string | null
    donneesInteractives?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    editedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
  }

  export type MessageLuUpsertWithWhereUniqueWithoutPersonnelInput = {
    where: MessageLuWhereUniqueInput
    update: XOR<MessageLuUpdateWithoutPersonnelInput, MessageLuUncheckedUpdateWithoutPersonnelInput>
    create: XOR<MessageLuCreateWithoutPersonnelInput, MessageLuUncheckedCreateWithoutPersonnelInput>
  }

  export type MessageLuUpdateWithWhereUniqueWithoutPersonnelInput = {
    where: MessageLuWhereUniqueInput
    data: XOR<MessageLuUpdateWithoutPersonnelInput, MessageLuUncheckedUpdateWithoutPersonnelInput>
  }

  export type MessageLuUpdateManyWithWhereWithoutPersonnelInput = {
    where: MessageLuScalarWhereInput
    data: XOR<MessageLuUpdateManyMutationInput, MessageLuUncheckedUpdateManyWithoutPersonnelInput>
  }

  export type MessageLuScalarWhereInput = {
    AND?: MessageLuScalarWhereInput | MessageLuScalarWhereInput[]
    OR?: MessageLuScalarWhereInput[]
    NOT?: MessageLuScalarWhereInput | MessageLuScalarWhereInput[]
    messageId?: IntFilter<"MessageLu"> | number
    personnelId?: IntFilter<"MessageLu"> | number
    dateLecture?: DateTimeFilter<"MessageLu"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutDestinataireInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutDestinataireInput, NotificationUncheckedUpdateWithoutDestinataireInput>
    create: XOR<NotificationCreateWithoutDestinataireInput, NotificationUncheckedCreateWithoutDestinataireInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutDestinataireInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutDestinataireInput, NotificationUncheckedUpdateWithoutDestinataireInput>
  }

  export type NotificationUpdateManyWithWhereWithoutDestinataireInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutDestinataireInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    destinataireId?: IntFilter<"Notification"> | number
    typeNotification?: StringFilter<"Notification"> | string
    titre?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    niveau?: EnumNiveauNotificationFilter<"Notification"> | $Enums.NiveauNotification
    entiteType?: StringNullableFilter<"Notification"> | string | null
    entiteId?: IntNullableFilter<"Notification"> | number | null
    donneesSupplementaires?: JsonNullableFilter<"Notification">
    lue?: BoolFilter<"Notification"> | boolean
    dateLecture?: DateTimeNullableFilter<"Notification"> | Date | string | null
    envoyeePush?: BoolFilter<"Notification"> | boolean
    envoyeeEmail?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type EvenementUpsertWithWhereUniqueWithoutCreateurInput = {
    where: EvenementWhereUniqueInput
    update: XOR<EvenementUpdateWithoutCreateurInput, EvenementUncheckedUpdateWithoutCreateurInput>
    create: XOR<EvenementCreateWithoutCreateurInput, EvenementUncheckedCreateWithoutCreateurInput>
  }

  export type EvenementUpdateWithWhereUniqueWithoutCreateurInput = {
    where: EvenementWhereUniqueInput
    data: XOR<EvenementUpdateWithoutCreateurInput, EvenementUncheckedUpdateWithoutCreateurInput>
  }

  export type EvenementUpdateManyWithWhereWithoutCreateurInput = {
    where: EvenementScalarWhereInput
    data: XOR<EvenementUpdateManyMutationInput, EvenementUncheckedUpdateManyWithoutCreateurInput>
  }

  export type EvenementParticipantUpsertWithWhereUniqueWithoutPersonnelInput = {
    where: EvenementParticipantWhereUniqueInput
    update: XOR<EvenementParticipantUpdateWithoutPersonnelInput, EvenementParticipantUncheckedUpdateWithoutPersonnelInput>
    create: XOR<EvenementParticipantCreateWithoutPersonnelInput, EvenementParticipantUncheckedCreateWithoutPersonnelInput>
  }

  export type EvenementParticipantUpdateWithWhereUniqueWithoutPersonnelInput = {
    where: EvenementParticipantWhereUniqueInput
    data: XOR<EvenementParticipantUpdateWithoutPersonnelInput, EvenementParticipantUncheckedUpdateWithoutPersonnelInput>
  }

  export type EvenementParticipantUpdateManyWithWhereWithoutPersonnelInput = {
    where: EvenementParticipantScalarWhereInput
    data: XOR<EvenementParticipantUpdateManyMutationInput, EvenementParticipantUncheckedUpdateManyWithoutPersonnelInput>
  }

  export type EvenementParticipantScalarWhereInput = {
    AND?: EvenementParticipantScalarWhereInput | EvenementParticipantScalarWhereInput[]
    OR?: EvenementParticipantScalarWhereInput[]
    NOT?: EvenementParticipantScalarWhereInput | EvenementParticipantScalarWhereInput[]
    evenementId?: IntFilter<"EvenementParticipant"> | number
    personnelId?: IntFilter<"EvenementParticipant"> | number
    statutInvitation?: EnumStatutInvitationFilter<"EvenementParticipant"> | $Enums.StatutInvitation
    obligatoire?: BoolFilter<"EvenementParticipant"> | boolean
    dateReponse?: DateTimeNullableFilter<"EvenementParticipant"> | Date | string | null
    commentaire?: StringNullableFilter<"EvenementParticipant"> | string | null
  }

  export type ExportTTAUpsertWithWhereUniqueWithoutGenereParInput = {
    where: ExportTTAWhereUniqueInput
    update: XOR<ExportTTAUpdateWithoutGenereParInput, ExportTTAUncheckedUpdateWithoutGenereParInput>
    create: XOR<ExportTTACreateWithoutGenereParInput, ExportTTAUncheckedCreateWithoutGenereParInput>
  }

  export type ExportTTAUpdateWithWhereUniqueWithoutGenereParInput = {
    where: ExportTTAWhereUniqueInput
    data: XOR<ExportTTAUpdateWithoutGenereParInput, ExportTTAUncheckedUpdateWithoutGenereParInput>
  }

  export type ExportTTAUpdateManyWithWhereWithoutGenereParInput = {
    where: ExportTTAScalarWhereInput
    data: XOR<ExportTTAUpdateManyMutationInput, ExportTTAUncheckedUpdateManyWithoutGenereParInput>
  }

  export type ExportTTAUpsertWithWhereUniqueWithoutValideParInput = {
    where: ExportTTAWhereUniqueInput
    update: XOR<ExportTTAUpdateWithoutValideParInput, ExportTTAUncheckedUpdateWithoutValideParInput>
    create: XOR<ExportTTACreateWithoutValideParInput, ExportTTAUncheckedCreateWithoutValideParInput>
  }

  export type ExportTTAUpdateWithWhereUniqueWithoutValideParInput = {
    where: ExportTTAWhereUniqueInput
    data: XOR<ExportTTAUpdateWithoutValideParInput, ExportTTAUncheckedUpdateWithoutValideParInput>
  }

  export type ExportTTAUpdateManyWithWhereWithoutValideParInput = {
    where: ExportTTAScalarWhereInput
    data: XOR<ExportTTAUpdateManyMutationInput, ExportTTAUncheckedUpdateManyWithoutValideParInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUtilisateurInput, AuditLogUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<AuditLogCreateWithoutUtilisateurInput, AuditLogUncheckedCreateWithoutUtilisateurInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUtilisateurInput, AuditLogUncheckedUpdateWithoutUtilisateurInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUtilisateurInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    utilisateurId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    entiteType?: StringFilter<"AuditLog"> | string
    entiteId?: IntNullableFilter<"AuditLog"> | number | null
    anciennesValeurs?: JsonNullableFilter<"AuditLog">
    nouvellesValeurs?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type PersonnelRoleCreateWithoutRoleInput = {
    dateAttribution?: Date | string
    dateFin?: Date | string | null
    personnel: PersonnelCreateNestedOneWithoutPersonnelRolesInput
  }

  export type PersonnelRoleUncheckedCreateWithoutRoleInput = {
    personnelId: number
    dateAttribution?: Date | string
    dateFin?: Date | string | null
  }

  export type PersonnelRoleCreateOrConnectWithoutRoleInput = {
    where: PersonnelRoleWhereUniqueInput
    create: XOR<PersonnelRoleCreateWithoutRoleInput, PersonnelRoleUncheckedCreateWithoutRoleInput>
  }

  export type PersonnelRoleCreateManyRoleInputEnvelope = {
    data: PersonnelRoleCreateManyRoleInput | PersonnelRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type PersonnelRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: PersonnelRoleWhereUniqueInput
    update: XOR<PersonnelRoleUpdateWithoutRoleInput, PersonnelRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<PersonnelRoleCreateWithoutRoleInput, PersonnelRoleUncheckedCreateWithoutRoleInput>
  }

  export type PersonnelRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: PersonnelRoleWhereUniqueInput
    data: XOR<PersonnelRoleUpdateWithoutRoleInput, PersonnelRoleUncheckedUpdateWithoutRoleInput>
  }

  export type PersonnelRoleUpdateManyWithWhereWithoutRoleInput = {
    where: PersonnelRoleScalarWhereInput
    data: XOR<PersonnelRoleUpdateManyMutationInput, PersonnelRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type PersonnelCreateWithoutPersonnelRolesInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutPersonnelRolesInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutPersonnelRolesInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutPersonnelRolesInput, PersonnelUncheckedCreateWithoutPersonnelRolesInput>
  }

  export type RoleCreateWithoutPersonnelsInput = {
    code: string
    libelle: string
    description?: string | null
    permissions?: JsonNullValueInput | InputJsonValue
    actif?: boolean
  }

  export type RoleUncheckedCreateWithoutPersonnelsInput = {
    id?: number
    code: string
    libelle: string
    description?: string | null
    permissions?: JsonNullValueInput | InputJsonValue
    actif?: boolean
  }

  export type RoleCreateOrConnectWithoutPersonnelsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPersonnelsInput, RoleUncheckedCreateWithoutPersonnelsInput>
  }

  export type PersonnelUpsertWithoutPersonnelRolesInput = {
    update: XOR<PersonnelUpdateWithoutPersonnelRolesInput, PersonnelUncheckedUpdateWithoutPersonnelRolesInput>
    create: XOR<PersonnelCreateWithoutPersonnelRolesInput, PersonnelUncheckedCreateWithoutPersonnelRolesInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutPersonnelRolesInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutPersonnelRolesInput, PersonnelUncheckedUpdateWithoutPersonnelRolesInput>
  }

  export type PersonnelUpdateWithoutPersonnelRolesInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutPersonnelRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type RoleUpsertWithoutPersonnelsInput = {
    update: XOR<RoleUpdateWithoutPersonnelsInput, RoleUncheckedUpdateWithoutPersonnelsInput>
    create: XOR<RoleCreateWithoutPersonnelsInput, RoleUncheckedCreateWithoutPersonnelsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPersonnelsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPersonnelsInput, RoleUncheckedUpdateWithoutPersonnelsInput>
  }

  export type RoleUpdateWithoutPersonnelsInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleUncheckedUpdateWithoutPersonnelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersonnelCompetenceCreateWithoutTypeCompetenceInput = {
    dateObtention: Date | string
    dateExpiration?: Date | string | null
    niveau?: string | null
    numeroDiplome?: string | null
    organismeDelivrance?: string | null
    actif?: boolean
    createdAt?: Date | string
    personnel: PersonnelCreateNestedOneWithoutCompetencesInput
  }

  export type PersonnelCompetenceUncheckedCreateWithoutTypeCompetenceInput = {
    id?: number
    personnelId: number
    dateObtention: Date | string
    dateExpiration?: Date | string | null
    niveau?: string | null
    numeroDiplome?: string | null
    organismeDelivrance?: string | null
    actif?: boolean
    createdAt?: Date | string
  }

  export type PersonnelCompetenceCreateOrConnectWithoutTypeCompetenceInput = {
    where: PersonnelCompetenceWhereUniqueInput
    create: XOR<PersonnelCompetenceCreateWithoutTypeCompetenceInput, PersonnelCompetenceUncheckedCreateWithoutTypeCompetenceInput>
  }

  export type PersonnelCompetenceCreateManyTypeCompetenceInputEnvelope = {
    data: PersonnelCompetenceCreateManyTypeCompetenceInput | PersonnelCompetenceCreateManyTypeCompetenceInput[]
    skipDuplicates?: boolean
  }

  export type PersonnelCompetenceUpsertWithWhereUniqueWithoutTypeCompetenceInput = {
    where: PersonnelCompetenceWhereUniqueInput
    update: XOR<PersonnelCompetenceUpdateWithoutTypeCompetenceInput, PersonnelCompetenceUncheckedUpdateWithoutTypeCompetenceInput>
    create: XOR<PersonnelCompetenceCreateWithoutTypeCompetenceInput, PersonnelCompetenceUncheckedCreateWithoutTypeCompetenceInput>
  }

  export type PersonnelCompetenceUpdateWithWhereUniqueWithoutTypeCompetenceInput = {
    where: PersonnelCompetenceWhereUniqueInput
    data: XOR<PersonnelCompetenceUpdateWithoutTypeCompetenceInput, PersonnelCompetenceUncheckedUpdateWithoutTypeCompetenceInput>
  }

  export type PersonnelCompetenceUpdateManyWithWhereWithoutTypeCompetenceInput = {
    where: PersonnelCompetenceScalarWhereInput
    data: XOR<PersonnelCompetenceUpdateManyMutationInput, PersonnelCompetenceUncheckedUpdateManyWithoutTypeCompetenceInput>
  }

  export type PersonnelCreateWithoutCompetencesInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutCompetencesInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutCompetencesInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutCompetencesInput, PersonnelUncheckedCreateWithoutCompetencesInput>
  }

  export type TypeCompetenceCreateWithoutCompetencesInput = {
    code: string
    libelle: string
    description?: string | null
    dureeValiditeMois?: number | null
    actif?: boolean
  }

  export type TypeCompetenceUncheckedCreateWithoutCompetencesInput = {
    id?: number
    code: string
    libelle: string
    description?: string | null
    dureeValiditeMois?: number | null
    actif?: boolean
  }

  export type TypeCompetenceCreateOrConnectWithoutCompetencesInput = {
    where: TypeCompetenceWhereUniqueInput
    create: XOR<TypeCompetenceCreateWithoutCompetencesInput, TypeCompetenceUncheckedCreateWithoutCompetencesInput>
  }

  export type PersonnelUpsertWithoutCompetencesInput = {
    update: XOR<PersonnelUpdateWithoutCompetencesInput, PersonnelUncheckedUpdateWithoutCompetencesInput>
    create: XOR<PersonnelCreateWithoutCompetencesInput, PersonnelUncheckedCreateWithoutCompetencesInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutCompetencesInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutCompetencesInput, PersonnelUncheckedUpdateWithoutCompetencesInput>
  }

  export type PersonnelUpdateWithoutCompetencesInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutCompetencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type TypeCompetenceUpsertWithoutCompetencesInput = {
    update: XOR<TypeCompetenceUpdateWithoutCompetencesInput, TypeCompetenceUncheckedUpdateWithoutCompetencesInput>
    create: XOR<TypeCompetenceCreateWithoutCompetencesInput, TypeCompetenceUncheckedCreateWithoutCompetencesInput>
    where?: TypeCompetenceWhereInput
  }

  export type TypeCompetenceUpdateToOneWithWhereWithoutCompetencesInput = {
    where?: TypeCompetenceWhereInput
    data: XOR<TypeCompetenceUpdateWithoutCompetencesInput, TypeCompetenceUncheckedUpdateWithoutCompetencesInput>
  }

  export type TypeCompetenceUpdateWithoutCompetencesInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dureeValiditeMois?: NullableIntFieldUpdateOperationsInput | number | null
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TypeCompetenceUncheckedUpdateWithoutCompetencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dureeValiditeMois?: NullableIntFieldUpdateOperationsInput | number | null
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersonnelCreateWithoutAptitudesMedicalesInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutAptitudesMedicalesInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutAptitudesMedicalesInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutAptitudesMedicalesInput, PersonnelUncheckedCreateWithoutAptitudesMedicalesInput>
  }

  export type PersonnelUpsertWithoutAptitudesMedicalesInput = {
    update: XOR<PersonnelUpdateWithoutAptitudesMedicalesInput, PersonnelUncheckedUpdateWithoutAptitudesMedicalesInput>
    create: XOR<PersonnelCreateWithoutAptitudesMedicalesInput, PersonnelUncheckedCreateWithoutAptitudesMedicalesInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutAptitudesMedicalesInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutAptitudesMedicalesInput, PersonnelUncheckedUpdateWithoutAptitudesMedicalesInput>
  }

  export type PersonnelUpdateWithoutAptitudesMedicalesInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutAptitudesMedicalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type SessionFMPACreateWithoutTypeFMPAInput = {
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    centre?: CentreCreateNestedOneWithoutSessionsInput
    formateurPrincipal: PersonnelCreateNestedOneWithoutSessionsFMPAFormateurInput
    formateursAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutSessionInput
    inscriptions?: InscriptionFMPACreateNestedManyWithoutSessionInput
    signatures?: SignatureFMPACreateNestedManyWithoutSessionInput
    exportsTTA?: ExportTTACreateNestedManyWithoutSessionInput
  }

  export type SessionFMPAUncheckedCreateWithoutTypeFMPAInput = {
    id?: number
    centreId?: number | null
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    formateurPrincipalId: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    formateursAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutSessionInput
    inscriptions?: InscriptionFMPAUncheckedCreateNestedManyWithoutSessionInput
    signatures?: SignatureFMPAUncheckedCreateNestedManyWithoutSessionInput
    exportsTTA?: ExportTTAUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionFMPACreateOrConnectWithoutTypeFMPAInput = {
    where: SessionFMPAWhereUniqueInput
    create: XOR<SessionFMPACreateWithoutTypeFMPAInput, SessionFMPAUncheckedCreateWithoutTypeFMPAInput>
  }

  export type SessionFMPACreateManyTypeFMPAInputEnvelope = {
    data: SessionFMPACreateManyTypeFMPAInput | SessionFMPACreateManyTypeFMPAInput[]
    skipDuplicates?: boolean
  }

  export type SessionFMPAUpsertWithWhereUniqueWithoutTypeFMPAInput = {
    where: SessionFMPAWhereUniqueInput
    update: XOR<SessionFMPAUpdateWithoutTypeFMPAInput, SessionFMPAUncheckedUpdateWithoutTypeFMPAInput>
    create: XOR<SessionFMPACreateWithoutTypeFMPAInput, SessionFMPAUncheckedCreateWithoutTypeFMPAInput>
  }

  export type SessionFMPAUpdateWithWhereUniqueWithoutTypeFMPAInput = {
    where: SessionFMPAWhereUniqueInput
    data: XOR<SessionFMPAUpdateWithoutTypeFMPAInput, SessionFMPAUncheckedUpdateWithoutTypeFMPAInput>
  }

  export type SessionFMPAUpdateManyWithWhereWithoutTypeFMPAInput = {
    where: SessionFMPAScalarWhereInput
    data: XOR<SessionFMPAUpdateManyMutationInput, SessionFMPAUncheckedUpdateManyWithoutTypeFMPAInput>
  }

  export type TypeFMPACreateWithoutSessionsInput = {
    code: string
    libelle: string
    dureeHeures: number
    obligatoire?: boolean
    periodiciteMois?: number | null
    description?: string | null
    actif?: boolean
  }

  export type TypeFMPAUncheckedCreateWithoutSessionsInput = {
    id?: number
    code: string
    libelle: string
    dureeHeures: number
    obligatoire?: boolean
    periodiciteMois?: number | null
    description?: string | null
    actif?: boolean
  }

  export type TypeFMPACreateOrConnectWithoutSessionsInput = {
    where: TypeFMPAWhereUniqueInput
    create: XOR<TypeFMPACreateWithoutSessionsInput, TypeFMPAUncheckedCreateWithoutSessionsInput>
  }

  export type CentreCreateWithoutSessionsInput = {
    code: string
    nom: string
    type: $Enums.TypeCentre
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    telephone?: string | null
    email?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personnels?: PersonnelCreateNestedManyWithoutCentreInput
    materiels?: MaterielCreateNestedManyWithoutCentreInput
    evenements?: EvenementCreateNestedManyWithoutCentreInput
    exportsTTA?: ExportTTACreateNestedManyWithoutCentreInput
  }

  export type CentreUncheckedCreateWithoutSessionsInput = {
    id?: number
    code: string
    nom: string
    type: $Enums.TypeCentre
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    telephone?: string | null
    email?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personnels?: PersonnelUncheckedCreateNestedManyWithoutCentreInput
    materiels?: MaterielUncheckedCreateNestedManyWithoutCentreInput
    evenements?: EvenementUncheckedCreateNestedManyWithoutCentreInput
    exportsTTA?: ExportTTAUncheckedCreateNestedManyWithoutCentreInput
  }

  export type CentreCreateOrConnectWithoutSessionsInput = {
    where: CentreWhereUniqueInput
    create: XOR<CentreCreateWithoutSessionsInput, CentreUncheckedCreateWithoutSessionsInput>
  }

  export type PersonnelCreateWithoutSessionsFMPAFormateurInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutSessionsFMPAFormateurInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutSessionsFMPAFormateurInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutSessionsFMPAFormateurInput, PersonnelUncheckedCreateWithoutSessionsFMPAFormateurInput>
  }

  export type SessionFMPAFormateurCreateWithoutSessionInput = {
    personnel: PersonnelCreateNestedOneWithoutSessionsFMPAAdditionnelsInput
  }

  export type SessionFMPAFormateurUncheckedCreateWithoutSessionInput = {
    personnelId: number
  }

  export type SessionFMPAFormateurCreateOrConnectWithoutSessionInput = {
    where: SessionFMPAFormateurWhereUniqueInput
    create: XOR<SessionFMPAFormateurCreateWithoutSessionInput, SessionFMPAFormateurUncheckedCreateWithoutSessionInput>
  }

  export type SessionFMPAFormateurCreateManySessionInputEnvelope = {
    data: SessionFMPAFormateurCreateManySessionInput | SessionFMPAFormateurCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type InscriptionFMPACreateWithoutSessionInput = {
    dateInscription?: Date | string
    statutInscription?: $Enums.StatutInscription
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    signatureElectronique?: string | null
    dateSignature?: Date | string | null
    noteEvaluation?: number | null
    acquis?: boolean | null
    commentaireFormateur?: string | null
    heuresValidees?: number | null
    montantTTA?: number | null
    exportePaie?: boolean
    dateExportPaie?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personnel: PersonnelCreateNestedOneWithoutInscriptionsFMPAInput
  }

  export type InscriptionFMPAUncheckedCreateWithoutSessionInput = {
    id?: number
    personnelId: number
    dateInscription?: Date | string
    statutInscription?: $Enums.StatutInscription
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    signatureElectronique?: string | null
    dateSignature?: Date | string | null
    noteEvaluation?: number | null
    acquis?: boolean | null
    commentaireFormateur?: string | null
    heuresValidees?: number | null
    montantTTA?: number | null
    exportePaie?: boolean
    dateExportPaie?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InscriptionFMPACreateOrConnectWithoutSessionInput = {
    where: InscriptionFMPAWhereUniqueInput
    create: XOR<InscriptionFMPACreateWithoutSessionInput, InscriptionFMPAUncheckedCreateWithoutSessionInput>
  }

  export type InscriptionFMPACreateManySessionInputEnvelope = {
    data: InscriptionFMPACreateManySessionInput | InscriptionFMPACreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type SignatureFMPACreateWithoutSessionInput = {
    id?: string
    type: string
    signature: string
    dateSignature?: Date | string
    personnel: PersonnelCreateNestedOneWithoutSignaturesFMPAInput
  }

  export type SignatureFMPAUncheckedCreateWithoutSessionInput = {
    id?: string
    personnelId: number
    type: string
    signature: string
    dateSignature?: Date | string
  }

  export type SignatureFMPACreateOrConnectWithoutSessionInput = {
    where: SignatureFMPAWhereUniqueInput
    create: XOR<SignatureFMPACreateWithoutSessionInput, SignatureFMPAUncheckedCreateWithoutSessionInput>
  }

  export type SignatureFMPACreateManySessionInputEnvelope = {
    data: SignatureFMPACreateManySessionInput | SignatureFMPACreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ExportTTACreateWithoutSessionInput = {
    periodeDebut: Date | string
    periodeFin: Date | string
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
    centre?: CentreCreateNestedOneWithoutExportsTTAInput
    generePar: PersonnelCreateNestedOneWithoutExportsTTAGeneresInput
    validePar?: PersonnelCreateNestedOneWithoutExportsTTAValidesInput
  }

  export type ExportTTAUncheckedCreateWithoutSessionInput = {
    id?: number
    periodeDebut: Date | string
    periodeFin: Date | string
    centreId?: number | null
    genereParId: number
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    valideParId?: number | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
  }

  export type ExportTTACreateOrConnectWithoutSessionInput = {
    where: ExportTTAWhereUniqueInput
    create: XOR<ExportTTACreateWithoutSessionInput, ExportTTAUncheckedCreateWithoutSessionInput>
  }

  export type ExportTTACreateManySessionInputEnvelope = {
    data: ExportTTACreateManySessionInput | ExportTTACreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type TypeFMPAUpsertWithoutSessionsInput = {
    update: XOR<TypeFMPAUpdateWithoutSessionsInput, TypeFMPAUncheckedUpdateWithoutSessionsInput>
    create: XOR<TypeFMPACreateWithoutSessionsInput, TypeFMPAUncheckedCreateWithoutSessionsInput>
    where?: TypeFMPAWhereInput
  }

  export type TypeFMPAUpdateToOneWithWhereWithoutSessionsInput = {
    where?: TypeFMPAWhereInput
    data: XOR<TypeFMPAUpdateWithoutSessionsInput, TypeFMPAUncheckedUpdateWithoutSessionsInput>
  }

  export type TypeFMPAUpdateWithoutSessionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    dureeHeures?: FloatFieldUpdateOperationsInput | number
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    periodiciteMois?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TypeFMPAUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    dureeHeures?: FloatFieldUpdateOperationsInput | number
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    periodiciteMois?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CentreUpsertWithoutSessionsInput = {
    update: XOR<CentreUpdateWithoutSessionsInput, CentreUncheckedUpdateWithoutSessionsInput>
    create: XOR<CentreCreateWithoutSessionsInput, CentreUncheckedCreateWithoutSessionsInput>
    where?: CentreWhereInput
  }

  export type CentreUpdateToOneWithWhereWithoutSessionsInput = {
    where?: CentreWhereInput
    data: XOR<CentreUpdateWithoutSessionsInput, CentreUncheckedUpdateWithoutSessionsInput>
  }

  export type CentreUpdateWithoutSessionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCentreFieldUpdateOperationsInput | $Enums.TypeCentre
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnels?: PersonnelUpdateManyWithoutCentreNestedInput
    materiels?: MaterielUpdateManyWithoutCentreNestedInput
    evenements?: EvenementUpdateManyWithoutCentreNestedInput
    exportsTTA?: ExportTTAUpdateManyWithoutCentreNestedInput
  }

  export type CentreUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCentreFieldUpdateOperationsInput | $Enums.TypeCentre
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnels?: PersonnelUncheckedUpdateManyWithoutCentreNestedInput
    materiels?: MaterielUncheckedUpdateManyWithoutCentreNestedInput
    evenements?: EvenementUncheckedUpdateManyWithoutCentreNestedInput
    exportsTTA?: ExportTTAUncheckedUpdateManyWithoutCentreNestedInput
  }

  export type PersonnelUpsertWithoutSessionsFMPAFormateurInput = {
    update: XOR<PersonnelUpdateWithoutSessionsFMPAFormateurInput, PersonnelUncheckedUpdateWithoutSessionsFMPAFormateurInput>
    create: XOR<PersonnelCreateWithoutSessionsFMPAFormateurInput, PersonnelUncheckedCreateWithoutSessionsFMPAFormateurInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutSessionsFMPAFormateurInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutSessionsFMPAFormateurInput, PersonnelUncheckedUpdateWithoutSessionsFMPAFormateurInput>
  }

  export type PersonnelUpdateWithoutSessionsFMPAFormateurInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutSessionsFMPAFormateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type SessionFMPAFormateurUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionFMPAFormateurWhereUniqueInput
    update: XOR<SessionFMPAFormateurUpdateWithoutSessionInput, SessionFMPAFormateurUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionFMPAFormateurCreateWithoutSessionInput, SessionFMPAFormateurUncheckedCreateWithoutSessionInput>
  }

  export type SessionFMPAFormateurUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionFMPAFormateurWhereUniqueInput
    data: XOR<SessionFMPAFormateurUpdateWithoutSessionInput, SessionFMPAFormateurUncheckedUpdateWithoutSessionInput>
  }

  export type SessionFMPAFormateurUpdateManyWithWhereWithoutSessionInput = {
    where: SessionFMPAFormateurScalarWhereInput
    data: XOR<SessionFMPAFormateurUpdateManyMutationInput, SessionFMPAFormateurUncheckedUpdateManyWithoutSessionInput>
  }

  export type InscriptionFMPAUpsertWithWhereUniqueWithoutSessionInput = {
    where: InscriptionFMPAWhereUniqueInput
    update: XOR<InscriptionFMPAUpdateWithoutSessionInput, InscriptionFMPAUncheckedUpdateWithoutSessionInput>
    create: XOR<InscriptionFMPACreateWithoutSessionInput, InscriptionFMPAUncheckedCreateWithoutSessionInput>
  }

  export type InscriptionFMPAUpdateWithWhereUniqueWithoutSessionInput = {
    where: InscriptionFMPAWhereUniqueInput
    data: XOR<InscriptionFMPAUpdateWithoutSessionInput, InscriptionFMPAUncheckedUpdateWithoutSessionInput>
  }

  export type InscriptionFMPAUpdateManyWithWhereWithoutSessionInput = {
    where: InscriptionFMPAScalarWhereInput
    data: XOR<InscriptionFMPAUpdateManyMutationInput, InscriptionFMPAUncheckedUpdateManyWithoutSessionInput>
  }

  export type SignatureFMPAUpsertWithWhereUniqueWithoutSessionInput = {
    where: SignatureFMPAWhereUniqueInput
    update: XOR<SignatureFMPAUpdateWithoutSessionInput, SignatureFMPAUncheckedUpdateWithoutSessionInput>
    create: XOR<SignatureFMPACreateWithoutSessionInput, SignatureFMPAUncheckedCreateWithoutSessionInput>
  }

  export type SignatureFMPAUpdateWithWhereUniqueWithoutSessionInput = {
    where: SignatureFMPAWhereUniqueInput
    data: XOR<SignatureFMPAUpdateWithoutSessionInput, SignatureFMPAUncheckedUpdateWithoutSessionInput>
  }

  export type SignatureFMPAUpdateManyWithWhereWithoutSessionInput = {
    where: SignatureFMPAScalarWhereInput
    data: XOR<SignatureFMPAUpdateManyMutationInput, SignatureFMPAUncheckedUpdateManyWithoutSessionInput>
  }

  export type ExportTTAUpsertWithWhereUniqueWithoutSessionInput = {
    where: ExportTTAWhereUniqueInput
    update: XOR<ExportTTAUpdateWithoutSessionInput, ExportTTAUncheckedUpdateWithoutSessionInput>
    create: XOR<ExportTTACreateWithoutSessionInput, ExportTTAUncheckedCreateWithoutSessionInput>
  }

  export type ExportTTAUpdateWithWhereUniqueWithoutSessionInput = {
    where: ExportTTAWhereUniqueInput
    data: XOR<ExportTTAUpdateWithoutSessionInput, ExportTTAUncheckedUpdateWithoutSessionInput>
  }

  export type ExportTTAUpdateManyWithWhereWithoutSessionInput = {
    where: ExportTTAScalarWhereInput
    data: XOR<ExportTTAUpdateManyMutationInput, ExportTTAUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionFMPACreateWithoutFormateursAdditionnelsInput = {
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    typeFMPA: TypeFMPACreateNestedOneWithoutSessionsInput
    centre?: CentreCreateNestedOneWithoutSessionsInput
    formateurPrincipal: PersonnelCreateNestedOneWithoutSessionsFMPAFormateurInput
    inscriptions?: InscriptionFMPACreateNestedManyWithoutSessionInput
    signatures?: SignatureFMPACreateNestedManyWithoutSessionInput
    exportsTTA?: ExportTTACreateNestedManyWithoutSessionInput
  }

  export type SessionFMPAUncheckedCreateWithoutFormateursAdditionnelsInput = {
    id?: number
    typeFMPAId: number
    centreId?: number | null
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    formateurPrincipalId: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inscriptions?: InscriptionFMPAUncheckedCreateNestedManyWithoutSessionInput
    signatures?: SignatureFMPAUncheckedCreateNestedManyWithoutSessionInput
    exportsTTA?: ExportTTAUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionFMPACreateOrConnectWithoutFormateursAdditionnelsInput = {
    where: SessionFMPAWhereUniqueInput
    create: XOR<SessionFMPACreateWithoutFormateursAdditionnelsInput, SessionFMPAUncheckedCreateWithoutFormateursAdditionnelsInput>
  }

  export type PersonnelCreateWithoutSessionsFMPAAdditionnelsInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutSessionsFMPAAdditionnelsInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutSessionsFMPAAdditionnelsInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutSessionsFMPAAdditionnelsInput, PersonnelUncheckedCreateWithoutSessionsFMPAAdditionnelsInput>
  }

  export type SessionFMPAUpsertWithoutFormateursAdditionnelsInput = {
    update: XOR<SessionFMPAUpdateWithoutFormateursAdditionnelsInput, SessionFMPAUncheckedUpdateWithoutFormateursAdditionnelsInput>
    create: XOR<SessionFMPACreateWithoutFormateursAdditionnelsInput, SessionFMPAUncheckedCreateWithoutFormateursAdditionnelsInput>
    where?: SessionFMPAWhereInput
  }

  export type SessionFMPAUpdateToOneWithWhereWithoutFormateursAdditionnelsInput = {
    where?: SessionFMPAWhereInput
    data: XOR<SessionFMPAUpdateWithoutFormateursAdditionnelsInput, SessionFMPAUncheckedUpdateWithoutFormateursAdditionnelsInput>
  }

  export type SessionFMPAUpdateWithoutFormateursAdditionnelsInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeFMPA?: TypeFMPAUpdateOneRequiredWithoutSessionsNestedInput
    centre?: CentreUpdateOneWithoutSessionsNestedInput
    formateurPrincipal?: PersonnelUpdateOneRequiredWithoutSessionsFMPAFormateurNestedInput
    inscriptions?: InscriptionFMPAUpdateManyWithoutSessionNestedInput
    signatures?: SignatureFMPAUpdateManyWithoutSessionNestedInput
    exportsTTA?: ExportTTAUpdateManyWithoutSessionNestedInput
  }

  export type SessionFMPAUncheckedUpdateWithoutFormateursAdditionnelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeFMPAId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    formateurPrincipalId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inscriptions?: InscriptionFMPAUncheckedUpdateManyWithoutSessionNestedInput
    signatures?: SignatureFMPAUncheckedUpdateManyWithoutSessionNestedInput
    exportsTTA?: ExportTTAUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type PersonnelUpsertWithoutSessionsFMPAAdditionnelsInput = {
    update: XOR<PersonnelUpdateWithoutSessionsFMPAAdditionnelsInput, PersonnelUncheckedUpdateWithoutSessionsFMPAAdditionnelsInput>
    create: XOR<PersonnelCreateWithoutSessionsFMPAAdditionnelsInput, PersonnelUncheckedCreateWithoutSessionsFMPAAdditionnelsInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutSessionsFMPAAdditionnelsInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutSessionsFMPAAdditionnelsInput, PersonnelUncheckedUpdateWithoutSessionsFMPAAdditionnelsInput>
  }

  export type PersonnelUpdateWithoutSessionsFMPAAdditionnelsInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutSessionsFMPAAdditionnelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type SessionFMPACreateWithoutInscriptionsInput = {
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    typeFMPA: TypeFMPACreateNestedOneWithoutSessionsInput
    centre?: CentreCreateNestedOneWithoutSessionsInput
    formateurPrincipal: PersonnelCreateNestedOneWithoutSessionsFMPAFormateurInput
    formateursAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutSessionInput
    signatures?: SignatureFMPACreateNestedManyWithoutSessionInput
    exportsTTA?: ExportTTACreateNestedManyWithoutSessionInput
  }

  export type SessionFMPAUncheckedCreateWithoutInscriptionsInput = {
    id?: number
    typeFMPAId: number
    centreId?: number | null
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    formateurPrincipalId: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    formateursAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutSessionInput
    signatures?: SignatureFMPAUncheckedCreateNestedManyWithoutSessionInput
    exportsTTA?: ExportTTAUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionFMPACreateOrConnectWithoutInscriptionsInput = {
    where: SessionFMPAWhereUniqueInput
    create: XOR<SessionFMPACreateWithoutInscriptionsInput, SessionFMPAUncheckedCreateWithoutInscriptionsInput>
  }

  export type PersonnelCreateWithoutInscriptionsFMPAInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutInscriptionsFMPAInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutInscriptionsFMPAInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutInscriptionsFMPAInput, PersonnelUncheckedCreateWithoutInscriptionsFMPAInput>
  }

  export type SessionFMPAUpsertWithoutInscriptionsInput = {
    update: XOR<SessionFMPAUpdateWithoutInscriptionsInput, SessionFMPAUncheckedUpdateWithoutInscriptionsInput>
    create: XOR<SessionFMPACreateWithoutInscriptionsInput, SessionFMPAUncheckedCreateWithoutInscriptionsInput>
    where?: SessionFMPAWhereInput
  }

  export type SessionFMPAUpdateToOneWithWhereWithoutInscriptionsInput = {
    where?: SessionFMPAWhereInput
    data: XOR<SessionFMPAUpdateWithoutInscriptionsInput, SessionFMPAUncheckedUpdateWithoutInscriptionsInput>
  }

  export type SessionFMPAUpdateWithoutInscriptionsInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeFMPA?: TypeFMPAUpdateOneRequiredWithoutSessionsNestedInput
    centre?: CentreUpdateOneWithoutSessionsNestedInput
    formateurPrincipal?: PersonnelUpdateOneRequiredWithoutSessionsFMPAFormateurNestedInput
    formateursAdditionnels?: SessionFMPAFormateurUpdateManyWithoutSessionNestedInput
    signatures?: SignatureFMPAUpdateManyWithoutSessionNestedInput
    exportsTTA?: ExportTTAUpdateManyWithoutSessionNestedInput
  }

  export type SessionFMPAUncheckedUpdateWithoutInscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeFMPAId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    formateurPrincipalId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formateursAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutSessionNestedInput
    signatures?: SignatureFMPAUncheckedUpdateManyWithoutSessionNestedInput
    exportsTTA?: ExportTTAUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type PersonnelUpsertWithoutInscriptionsFMPAInput = {
    update: XOR<PersonnelUpdateWithoutInscriptionsFMPAInput, PersonnelUncheckedUpdateWithoutInscriptionsFMPAInput>
    create: XOR<PersonnelCreateWithoutInscriptionsFMPAInput, PersonnelUncheckedCreateWithoutInscriptionsFMPAInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutInscriptionsFMPAInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutInscriptionsFMPAInput, PersonnelUncheckedUpdateWithoutInscriptionsFMPAInput>
  }

  export type PersonnelUpdateWithoutInscriptionsFMPAInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutInscriptionsFMPAInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type SessionFMPACreateWithoutSignaturesInput = {
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    typeFMPA: TypeFMPACreateNestedOneWithoutSessionsInput
    centre?: CentreCreateNestedOneWithoutSessionsInput
    formateurPrincipal: PersonnelCreateNestedOneWithoutSessionsFMPAFormateurInput
    formateursAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutSessionInput
    inscriptions?: InscriptionFMPACreateNestedManyWithoutSessionInput
    exportsTTA?: ExportTTACreateNestedManyWithoutSessionInput
  }

  export type SessionFMPAUncheckedCreateWithoutSignaturesInput = {
    id?: number
    typeFMPAId: number
    centreId?: number | null
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    formateurPrincipalId: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    formateursAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutSessionInput
    inscriptions?: InscriptionFMPAUncheckedCreateNestedManyWithoutSessionInput
    exportsTTA?: ExportTTAUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionFMPACreateOrConnectWithoutSignaturesInput = {
    where: SessionFMPAWhereUniqueInput
    create: XOR<SessionFMPACreateWithoutSignaturesInput, SessionFMPAUncheckedCreateWithoutSignaturesInput>
  }

  export type PersonnelCreateWithoutSignaturesFMPAInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutSignaturesFMPAInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutSignaturesFMPAInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutSignaturesFMPAInput, PersonnelUncheckedCreateWithoutSignaturesFMPAInput>
  }

  export type SessionFMPAUpsertWithoutSignaturesInput = {
    update: XOR<SessionFMPAUpdateWithoutSignaturesInput, SessionFMPAUncheckedUpdateWithoutSignaturesInput>
    create: XOR<SessionFMPACreateWithoutSignaturesInput, SessionFMPAUncheckedCreateWithoutSignaturesInput>
    where?: SessionFMPAWhereInput
  }

  export type SessionFMPAUpdateToOneWithWhereWithoutSignaturesInput = {
    where?: SessionFMPAWhereInput
    data: XOR<SessionFMPAUpdateWithoutSignaturesInput, SessionFMPAUncheckedUpdateWithoutSignaturesInput>
  }

  export type SessionFMPAUpdateWithoutSignaturesInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeFMPA?: TypeFMPAUpdateOneRequiredWithoutSessionsNestedInput
    centre?: CentreUpdateOneWithoutSessionsNestedInput
    formateurPrincipal?: PersonnelUpdateOneRequiredWithoutSessionsFMPAFormateurNestedInput
    formateursAdditionnels?: SessionFMPAFormateurUpdateManyWithoutSessionNestedInput
    inscriptions?: InscriptionFMPAUpdateManyWithoutSessionNestedInput
    exportsTTA?: ExportTTAUpdateManyWithoutSessionNestedInput
  }

  export type SessionFMPAUncheckedUpdateWithoutSignaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeFMPAId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    formateurPrincipalId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formateursAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutSessionNestedInput
    inscriptions?: InscriptionFMPAUncheckedUpdateManyWithoutSessionNestedInput
    exportsTTA?: ExportTTAUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type PersonnelUpsertWithoutSignaturesFMPAInput = {
    update: XOR<PersonnelUpdateWithoutSignaturesFMPAInput, PersonnelUncheckedUpdateWithoutSignaturesFMPAInput>
    create: XOR<PersonnelCreateWithoutSignaturesFMPAInput, PersonnelUncheckedCreateWithoutSignaturesFMPAInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutSignaturesFMPAInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutSignaturesFMPAInput, PersonnelUncheckedUpdateWithoutSignaturesFMPAInput>
  }

  export type PersonnelUpdateWithoutSignaturesFMPAInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutSignaturesFMPAInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type MaterielCreateWithoutCategorieInput = {
    codeInventaire: string
    libelle: string
    marque?: string | null
    modele?: string | null
    numeroSerie?: string | null
    dateAcquisition?: Date | string | null
    dateMiseService?: Date | string | null
    dateReforme?: Date | string | null
    etat?: $Enums.EtatMateriel
    periodiciteControleJours?: number | null
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    localisation?: string | null
    valeurAchat?: number | null
    fournisseur?: string | null
    numeroMarche?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    centre?: CentreCreateNestedOneWithoutMaterielsInput
    responsable?: PersonnelCreateNestedOneWithoutMaterielsResponsableInput
    incidents?: IncidentMaterielCreateNestedManyWithoutMaterielInput
  }

  export type MaterielUncheckedCreateWithoutCategorieInput = {
    id?: number
    centreId?: number | null
    codeInventaire: string
    libelle: string
    marque?: string | null
    modele?: string | null
    numeroSerie?: string | null
    dateAcquisition?: Date | string | null
    dateMiseService?: Date | string | null
    dateReforme?: Date | string | null
    etat?: $Enums.EtatMateriel
    periodiciteControleJours?: number | null
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    localisation?: string | null
    responsableId?: number | null
    valeurAchat?: number | null
    fournisseur?: string | null
    numeroMarche?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    incidents?: IncidentMaterielUncheckedCreateNestedManyWithoutMaterielInput
  }

  export type MaterielCreateOrConnectWithoutCategorieInput = {
    where: MaterielWhereUniqueInput
    create: XOR<MaterielCreateWithoutCategorieInput, MaterielUncheckedCreateWithoutCategorieInput>
  }

  export type MaterielCreateManyCategorieInputEnvelope = {
    data: MaterielCreateManyCategorieInput | MaterielCreateManyCategorieInput[]
    skipDuplicates?: boolean
  }

  export type MaterielUpsertWithWhereUniqueWithoutCategorieInput = {
    where: MaterielWhereUniqueInput
    update: XOR<MaterielUpdateWithoutCategorieInput, MaterielUncheckedUpdateWithoutCategorieInput>
    create: XOR<MaterielCreateWithoutCategorieInput, MaterielUncheckedCreateWithoutCategorieInput>
  }

  export type MaterielUpdateWithWhereUniqueWithoutCategorieInput = {
    where: MaterielWhereUniqueInput
    data: XOR<MaterielUpdateWithoutCategorieInput, MaterielUncheckedUpdateWithoutCategorieInput>
  }

  export type MaterielUpdateManyWithWhereWithoutCategorieInput = {
    where: MaterielScalarWhereInput
    data: XOR<MaterielUpdateManyMutationInput, MaterielUncheckedUpdateManyWithoutCategorieInput>
  }

  export type CategorieMaterielCreateWithoutMaterielsInput = {
    code: string
    libelle: string
    description?: string | null
    actif?: boolean
  }

  export type CategorieMaterielUncheckedCreateWithoutMaterielsInput = {
    id?: number
    code: string
    libelle: string
    description?: string | null
    actif?: boolean
  }

  export type CategorieMaterielCreateOrConnectWithoutMaterielsInput = {
    where: CategorieMaterielWhereUniqueInput
    create: XOR<CategorieMaterielCreateWithoutMaterielsInput, CategorieMaterielUncheckedCreateWithoutMaterielsInput>
  }

  export type CentreCreateWithoutMaterielsInput = {
    code: string
    nom: string
    type: $Enums.TypeCentre
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    telephone?: string | null
    email?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personnels?: PersonnelCreateNestedManyWithoutCentreInput
    sessions?: SessionFMPACreateNestedManyWithoutCentreInput
    evenements?: EvenementCreateNestedManyWithoutCentreInput
    exportsTTA?: ExportTTACreateNestedManyWithoutCentreInput
  }

  export type CentreUncheckedCreateWithoutMaterielsInput = {
    id?: number
    code: string
    nom: string
    type: $Enums.TypeCentre
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    telephone?: string | null
    email?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personnels?: PersonnelUncheckedCreateNestedManyWithoutCentreInput
    sessions?: SessionFMPAUncheckedCreateNestedManyWithoutCentreInput
    evenements?: EvenementUncheckedCreateNestedManyWithoutCentreInput
    exportsTTA?: ExportTTAUncheckedCreateNestedManyWithoutCentreInput
  }

  export type CentreCreateOrConnectWithoutMaterielsInput = {
    where: CentreWhereUniqueInput
    create: XOR<CentreCreateWithoutMaterielsInput, CentreUncheckedCreateWithoutMaterielsInput>
  }

  export type PersonnelCreateWithoutMaterielsResponsableInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutMaterielsResponsableInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutMaterielsResponsableInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutMaterielsResponsableInput, PersonnelUncheckedCreateWithoutMaterielsResponsableInput>
  }

  export type IncidentMaterielCreateWithoutMaterielInput = {
    dateIncident?: Date | string
    typeIncident: $Enums.TypeIncident
    gravite: $Enums.GraviteIncident
    description: string
    photosUrls?: IncidentMaterielCreatephotosUrlsInput | string[]
    statut?: $Enums.StatutIncident
    dateResolution?: Date | string | null
    actionsCorrectives?: string | null
    coutReparation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signalePar: PersonnelCreateNestedOneWithoutIncidentsSignalesInput
    traitePar?: PersonnelCreateNestedOneWithoutIncidentsTraitesInput
  }

  export type IncidentMaterielUncheckedCreateWithoutMaterielInput = {
    id?: number
    signaleParId: number
    dateIncident?: Date | string
    typeIncident: $Enums.TypeIncident
    gravite: $Enums.GraviteIncident
    description: string
    photosUrls?: IncidentMaterielCreatephotosUrlsInput | string[]
    statut?: $Enums.StatutIncident
    traiteParId?: number | null
    dateResolution?: Date | string | null
    actionsCorrectives?: string | null
    coutReparation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentMaterielCreateOrConnectWithoutMaterielInput = {
    where: IncidentMaterielWhereUniqueInput
    create: XOR<IncidentMaterielCreateWithoutMaterielInput, IncidentMaterielUncheckedCreateWithoutMaterielInput>
  }

  export type IncidentMaterielCreateManyMaterielInputEnvelope = {
    data: IncidentMaterielCreateManyMaterielInput | IncidentMaterielCreateManyMaterielInput[]
    skipDuplicates?: boolean
  }

  export type CategorieMaterielUpsertWithoutMaterielsInput = {
    update: XOR<CategorieMaterielUpdateWithoutMaterielsInput, CategorieMaterielUncheckedUpdateWithoutMaterielsInput>
    create: XOR<CategorieMaterielCreateWithoutMaterielsInput, CategorieMaterielUncheckedCreateWithoutMaterielsInput>
    where?: CategorieMaterielWhereInput
  }

  export type CategorieMaterielUpdateToOneWithWhereWithoutMaterielsInput = {
    where?: CategorieMaterielWhereInput
    data: XOR<CategorieMaterielUpdateWithoutMaterielsInput, CategorieMaterielUncheckedUpdateWithoutMaterielsInput>
  }

  export type CategorieMaterielUpdateWithoutMaterielsInput = {
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CategorieMaterielUncheckedUpdateWithoutMaterielsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CentreUpsertWithoutMaterielsInput = {
    update: XOR<CentreUpdateWithoutMaterielsInput, CentreUncheckedUpdateWithoutMaterielsInput>
    create: XOR<CentreCreateWithoutMaterielsInput, CentreUncheckedCreateWithoutMaterielsInput>
    where?: CentreWhereInput
  }

  export type CentreUpdateToOneWithWhereWithoutMaterielsInput = {
    where?: CentreWhereInput
    data: XOR<CentreUpdateWithoutMaterielsInput, CentreUncheckedUpdateWithoutMaterielsInput>
  }

  export type CentreUpdateWithoutMaterielsInput = {
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCentreFieldUpdateOperationsInput | $Enums.TypeCentre
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnels?: PersonnelUpdateManyWithoutCentreNestedInput
    sessions?: SessionFMPAUpdateManyWithoutCentreNestedInput
    evenements?: EvenementUpdateManyWithoutCentreNestedInput
    exportsTTA?: ExportTTAUpdateManyWithoutCentreNestedInput
  }

  export type CentreUncheckedUpdateWithoutMaterielsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCentreFieldUpdateOperationsInput | $Enums.TypeCentre
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnels?: PersonnelUncheckedUpdateManyWithoutCentreNestedInput
    sessions?: SessionFMPAUncheckedUpdateManyWithoutCentreNestedInput
    evenements?: EvenementUncheckedUpdateManyWithoutCentreNestedInput
    exportsTTA?: ExportTTAUncheckedUpdateManyWithoutCentreNestedInput
  }

  export type PersonnelUpsertWithoutMaterielsResponsableInput = {
    update: XOR<PersonnelUpdateWithoutMaterielsResponsableInput, PersonnelUncheckedUpdateWithoutMaterielsResponsableInput>
    create: XOR<PersonnelCreateWithoutMaterielsResponsableInput, PersonnelUncheckedCreateWithoutMaterielsResponsableInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutMaterielsResponsableInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutMaterielsResponsableInput, PersonnelUncheckedUpdateWithoutMaterielsResponsableInput>
  }

  export type PersonnelUpdateWithoutMaterielsResponsableInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutMaterielsResponsableInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type IncidentMaterielUpsertWithWhereUniqueWithoutMaterielInput = {
    where: IncidentMaterielWhereUniqueInput
    update: XOR<IncidentMaterielUpdateWithoutMaterielInput, IncidentMaterielUncheckedUpdateWithoutMaterielInput>
    create: XOR<IncidentMaterielCreateWithoutMaterielInput, IncidentMaterielUncheckedCreateWithoutMaterielInput>
  }

  export type IncidentMaterielUpdateWithWhereUniqueWithoutMaterielInput = {
    where: IncidentMaterielWhereUniqueInput
    data: XOR<IncidentMaterielUpdateWithoutMaterielInput, IncidentMaterielUncheckedUpdateWithoutMaterielInput>
  }

  export type IncidentMaterielUpdateManyWithWhereWithoutMaterielInput = {
    where: IncidentMaterielScalarWhereInput
    data: XOR<IncidentMaterielUpdateManyMutationInput, IncidentMaterielUncheckedUpdateManyWithoutMaterielInput>
  }

  export type MaterielCreateWithoutIncidentsInput = {
    codeInventaire: string
    libelle: string
    marque?: string | null
    modele?: string | null
    numeroSerie?: string | null
    dateAcquisition?: Date | string | null
    dateMiseService?: Date | string | null
    dateReforme?: Date | string | null
    etat?: $Enums.EtatMateriel
    periodiciteControleJours?: number | null
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    localisation?: string | null
    valeurAchat?: number | null
    fournisseur?: string | null
    numeroMarche?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categorie: CategorieMaterielCreateNestedOneWithoutMaterielsInput
    centre?: CentreCreateNestedOneWithoutMaterielsInput
    responsable?: PersonnelCreateNestedOneWithoutMaterielsResponsableInput
  }

  export type MaterielUncheckedCreateWithoutIncidentsInput = {
    id?: number
    categorieId: number
    centreId?: number | null
    codeInventaire: string
    libelle: string
    marque?: string | null
    modele?: string | null
    numeroSerie?: string | null
    dateAcquisition?: Date | string | null
    dateMiseService?: Date | string | null
    dateReforme?: Date | string | null
    etat?: $Enums.EtatMateriel
    periodiciteControleJours?: number | null
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    localisation?: string | null
    responsableId?: number | null
    valeurAchat?: number | null
    fournisseur?: string | null
    numeroMarche?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterielCreateOrConnectWithoutIncidentsInput = {
    where: MaterielWhereUniqueInput
    create: XOR<MaterielCreateWithoutIncidentsInput, MaterielUncheckedCreateWithoutIncidentsInput>
  }

  export type PersonnelCreateWithoutIncidentsSignalesInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutIncidentsSignalesInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutIncidentsSignalesInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutIncidentsSignalesInput, PersonnelUncheckedCreateWithoutIncidentsSignalesInput>
  }

  export type PersonnelCreateWithoutIncidentsTraitesInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutIncidentsTraitesInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutIncidentsTraitesInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutIncidentsTraitesInput, PersonnelUncheckedCreateWithoutIncidentsTraitesInput>
  }

  export type MaterielUpsertWithoutIncidentsInput = {
    update: XOR<MaterielUpdateWithoutIncidentsInput, MaterielUncheckedUpdateWithoutIncidentsInput>
    create: XOR<MaterielCreateWithoutIncidentsInput, MaterielUncheckedCreateWithoutIncidentsInput>
    where?: MaterielWhereInput
  }

  export type MaterielUpdateToOneWithWhereWithoutIncidentsInput = {
    where?: MaterielWhereInput
    data: XOR<MaterielUpdateWithoutIncidentsInput, MaterielUncheckedUpdateWithoutIncidentsInput>
  }

  export type MaterielUpdateWithoutIncidentsInput = {
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categorie?: CategorieMaterielUpdateOneRequiredWithoutMaterielsNestedInput
    centre?: CentreUpdateOneWithoutMaterielsNestedInput
    responsable?: PersonnelUpdateOneWithoutMaterielsResponsableNestedInput
  }

  export type MaterielUncheckedUpdateWithoutIncidentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    categorieId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    responsableId?: NullableIntFieldUpdateOperationsInput | number | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonnelUpsertWithoutIncidentsSignalesInput = {
    update: XOR<PersonnelUpdateWithoutIncidentsSignalesInput, PersonnelUncheckedUpdateWithoutIncidentsSignalesInput>
    create: XOR<PersonnelCreateWithoutIncidentsSignalesInput, PersonnelUncheckedCreateWithoutIncidentsSignalesInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutIncidentsSignalesInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutIncidentsSignalesInput, PersonnelUncheckedUpdateWithoutIncidentsSignalesInput>
  }

  export type PersonnelUpdateWithoutIncidentsSignalesInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutIncidentsSignalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUpsertWithoutIncidentsTraitesInput = {
    update: XOR<PersonnelUpdateWithoutIncidentsTraitesInput, PersonnelUncheckedUpdateWithoutIncidentsTraitesInput>
    create: XOR<PersonnelCreateWithoutIncidentsTraitesInput, PersonnelUncheckedCreateWithoutIncidentsTraitesInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutIncidentsTraitesInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutIncidentsTraitesInput, PersonnelUncheckedUpdateWithoutIncidentsTraitesInput>
  }

  export type PersonnelUpdateWithoutIncidentsTraitesInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutIncidentsTraitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelCreateWithoutEpiInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutEpiInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutEpiInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutEpiInput, PersonnelUncheckedCreateWithoutEpiInput>
  }

  export type PersonnelUpsertWithoutEpiInput = {
    update: XOR<PersonnelUpdateWithoutEpiInput, PersonnelUncheckedUpdateWithoutEpiInput>
    create: XOR<PersonnelCreateWithoutEpiInput, PersonnelUncheckedCreateWithoutEpiInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutEpiInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutEpiInput, PersonnelUncheckedUpdateWithoutEpiInput>
  }

  export type PersonnelUpdateWithoutEpiInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutEpiInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelCreateWithoutConversationsCreeesInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutConversationsCreeesInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutConversationsCreeesInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutConversationsCreeesInput, PersonnelUncheckedCreateWithoutConversationsCreeesInput>
  }

  export type ConversationParticipantCreateWithoutConversationInput = {
    dateAjout?: Date | string
    dateSortie?: Date | string | null
    role?: $Enums.RoleConversation
    notificationsActives?: boolean
    personnel: PersonnelCreateNestedOneWithoutParticipationsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutConversationInput = {
    personnelId: number
    dateAjout?: Date | string
    dateSortie?: Date | string | null
    role?: $Enums.RoleConversation
    notificationsActives?: boolean
  }

  export type ConversationParticipantCreateOrConnectWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantCreateManyConversationInputEnvelope = {
    data: ConversationParticipantCreateManyConversationInput | ConversationParticipantCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutConversationInput = {
    contenu: string
    typeMessage?: $Enums.TypeMessage
    fichierUrl?: string | null
    typeInteractif?: string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    expediteur: PersonnelCreateNestedOneWithoutMessagesEnvoyesInput
    messagesLus?: MessageLuCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: number
    expediteurId: number
    contenu: string
    typeMessage?: $Enums.TypeMessage
    fichierUrl?: string | null
    typeInteractif?: string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type PersonnelUpsertWithoutConversationsCreeesInput = {
    update: XOR<PersonnelUpdateWithoutConversationsCreeesInput, PersonnelUncheckedUpdateWithoutConversationsCreeesInput>
    create: XOR<PersonnelCreateWithoutConversationsCreeesInput, PersonnelUncheckedCreateWithoutConversationsCreeesInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutConversationsCreeesInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutConversationsCreeesInput, PersonnelUncheckedUpdateWithoutConversationsCreeesInput>
  }

  export type PersonnelUpdateWithoutConversationsCreeesInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutConversationsCreeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutParticipantsInput = {
    type: $Enums.TypeConversation
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: PersonnelCreateNestedOneWithoutConversationsCreeesInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutParticipantsInput = {
    id?: number
    type: $Enums.TypeConversation
    nom?: string | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutParticipantsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
  }

  export type PersonnelCreateWithoutParticipationsInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutParticipationsInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutParticipationsInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutParticipationsInput, PersonnelUncheckedCreateWithoutParticipationsInput>
  }

  export type ConversationUpsertWithoutParticipantsInput = {
    update: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type ConversationUpdateWithoutParticipantsInput = {
    type?: EnumTypeConversationFieldUpdateOperationsInput | $Enums.TypeConversation
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: PersonnelUpdateOneRequiredWithoutConversationsCreeesNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutParticipantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTypeConversationFieldUpdateOperationsInput | $Enums.TypeConversation
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type PersonnelUpsertWithoutParticipationsInput = {
    update: XOR<PersonnelUpdateWithoutParticipationsInput, PersonnelUncheckedUpdateWithoutParticipationsInput>
    create: XOR<PersonnelCreateWithoutParticipationsInput, PersonnelUncheckedCreateWithoutParticipationsInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutParticipationsInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutParticipationsInput, PersonnelUncheckedUpdateWithoutParticipationsInput>
  }

  export type PersonnelUpdateWithoutParticipationsInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutParticipationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    type: $Enums.TypeConversation
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: PersonnelCreateNestedOneWithoutConversationsCreeesInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: number
    type: $Enums.TypeConversation
    nom?: string | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type PersonnelCreateWithoutMessagesEnvoyesInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutMessagesEnvoyesInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutMessagesEnvoyesInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutMessagesEnvoyesInput, PersonnelUncheckedCreateWithoutMessagesEnvoyesInput>
  }

  export type MessageLuCreateWithoutMessageInput = {
    dateLecture?: Date | string
    personnel: PersonnelCreateNestedOneWithoutMessagesLusInput
  }

  export type MessageLuUncheckedCreateWithoutMessageInput = {
    personnelId: number
    dateLecture?: Date | string
  }

  export type MessageLuCreateOrConnectWithoutMessageInput = {
    where: MessageLuWhereUniqueInput
    create: XOR<MessageLuCreateWithoutMessageInput, MessageLuUncheckedCreateWithoutMessageInput>
  }

  export type MessageLuCreateManyMessageInputEnvelope = {
    data: MessageLuCreateManyMessageInput | MessageLuCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    type?: EnumTypeConversationFieldUpdateOperationsInput | $Enums.TypeConversation
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: PersonnelUpdateOneRequiredWithoutConversationsCreeesNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTypeConversationFieldUpdateOperationsInput | $Enums.TypeConversation
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type PersonnelUpsertWithoutMessagesEnvoyesInput = {
    update: XOR<PersonnelUpdateWithoutMessagesEnvoyesInput, PersonnelUncheckedUpdateWithoutMessagesEnvoyesInput>
    create: XOR<PersonnelCreateWithoutMessagesEnvoyesInput, PersonnelUncheckedCreateWithoutMessagesEnvoyesInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutMessagesEnvoyesInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutMessagesEnvoyesInput, PersonnelUncheckedUpdateWithoutMessagesEnvoyesInput>
  }

  export type PersonnelUpdateWithoutMessagesEnvoyesInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutMessagesEnvoyesInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type MessageLuUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageLuWhereUniqueInput
    update: XOR<MessageLuUpdateWithoutMessageInput, MessageLuUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageLuCreateWithoutMessageInput, MessageLuUncheckedCreateWithoutMessageInput>
  }

  export type MessageLuUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageLuWhereUniqueInput
    data: XOR<MessageLuUpdateWithoutMessageInput, MessageLuUncheckedUpdateWithoutMessageInput>
  }

  export type MessageLuUpdateManyWithWhereWithoutMessageInput = {
    where: MessageLuScalarWhereInput
    data: XOR<MessageLuUpdateManyMutationInput, MessageLuUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageCreateWithoutMessagesLusInput = {
    contenu: string
    typeMessage?: $Enums.TypeMessage
    fichierUrl?: string | null
    typeInteractif?: string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    expediteur: PersonnelCreateNestedOneWithoutMessagesEnvoyesInput
  }

  export type MessageUncheckedCreateWithoutMessagesLusInput = {
    id?: number
    conversationId: number
    expediteurId: number
    contenu: string
    typeMessage?: $Enums.TypeMessage
    fichierUrl?: string | null
    typeInteractif?: string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type MessageCreateOrConnectWithoutMessagesLusInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutMessagesLusInput, MessageUncheckedCreateWithoutMessagesLusInput>
  }

  export type PersonnelCreateWithoutMessagesLusInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutMessagesLusInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutMessagesLusInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutMessagesLusInput, PersonnelUncheckedCreateWithoutMessagesLusInput>
  }

  export type MessageUpsertWithoutMessagesLusInput = {
    update: XOR<MessageUpdateWithoutMessagesLusInput, MessageUncheckedUpdateWithoutMessagesLusInput>
    create: XOR<MessageCreateWithoutMessagesLusInput, MessageUncheckedCreateWithoutMessagesLusInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutMessagesLusInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutMessagesLusInput, MessageUncheckedUpdateWithoutMessagesLusInput>
  }

  export type MessageUpdateWithoutMessagesLusInput = {
    contenu?: StringFieldUpdateOperationsInput | string
    typeMessage?: EnumTypeMessageFieldUpdateOperationsInput | $Enums.TypeMessage
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeInteractif?: NullableStringFieldUpdateOperationsInput | string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    expediteur?: PersonnelUpdateOneRequiredWithoutMessagesEnvoyesNestedInput
  }

  export type MessageUncheckedUpdateWithoutMessagesLusInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversationId?: IntFieldUpdateOperationsInput | number
    expediteurId?: IntFieldUpdateOperationsInput | number
    contenu?: StringFieldUpdateOperationsInput | string
    typeMessage?: EnumTypeMessageFieldUpdateOperationsInput | $Enums.TypeMessage
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeInteractif?: NullableStringFieldUpdateOperationsInput | string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonnelUpsertWithoutMessagesLusInput = {
    update: XOR<PersonnelUpdateWithoutMessagesLusInput, PersonnelUncheckedUpdateWithoutMessagesLusInput>
    create: XOR<PersonnelCreateWithoutMessagesLusInput, PersonnelUncheckedCreateWithoutMessagesLusInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutMessagesLusInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutMessagesLusInput, PersonnelUncheckedUpdateWithoutMessagesLusInput>
  }

  export type PersonnelUpdateWithoutMessagesLusInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutMessagesLusInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelCreateWithoutNotificationsInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutNotificationsInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutNotificationsInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutNotificationsInput, PersonnelUncheckedCreateWithoutNotificationsInput>
  }

  export type PersonnelUpsertWithoutNotificationsInput = {
    update: XOR<PersonnelUpdateWithoutNotificationsInput, PersonnelUncheckedUpdateWithoutNotificationsInput>
    create: XOR<PersonnelCreateWithoutNotificationsInput, PersonnelUncheckedCreateWithoutNotificationsInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutNotificationsInput, PersonnelUncheckedUpdateWithoutNotificationsInput>
  }

  export type PersonnelUpdateWithoutNotificationsInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelCreateWithoutEvenementsCreeesInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutEvenementsCreeesInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutEvenementsCreeesInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutEvenementsCreeesInput, PersonnelUncheckedCreateWithoutEvenementsCreeesInput>
  }

  export type CentreCreateWithoutEvenementsInput = {
    code: string
    nom: string
    type: $Enums.TypeCentre
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    telephone?: string | null
    email?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personnels?: PersonnelCreateNestedManyWithoutCentreInput
    sessions?: SessionFMPACreateNestedManyWithoutCentreInput
    materiels?: MaterielCreateNestedManyWithoutCentreInput
    exportsTTA?: ExportTTACreateNestedManyWithoutCentreInput
  }

  export type CentreUncheckedCreateWithoutEvenementsInput = {
    id?: number
    code: string
    nom: string
    type: $Enums.TypeCentre
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    telephone?: string | null
    email?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personnels?: PersonnelUncheckedCreateNestedManyWithoutCentreInput
    sessions?: SessionFMPAUncheckedCreateNestedManyWithoutCentreInput
    materiels?: MaterielUncheckedCreateNestedManyWithoutCentreInput
    exportsTTA?: ExportTTAUncheckedCreateNestedManyWithoutCentreInput
  }

  export type CentreCreateOrConnectWithoutEvenementsInput = {
    where: CentreWhereUniqueInput
    create: XOR<CentreCreateWithoutEvenementsInput, CentreUncheckedCreateWithoutEvenementsInput>
  }

  export type EvenementParticipantCreateWithoutEvenementInput = {
    statutInvitation?: $Enums.StatutInvitation
    obligatoire?: boolean
    dateReponse?: Date | string | null
    commentaire?: string | null
    personnel: PersonnelCreateNestedOneWithoutParticipationsEvenementsInput
  }

  export type EvenementParticipantUncheckedCreateWithoutEvenementInput = {
    personnelId: number
    statutInvitation?: $Enums.StatutInvitation
    obligatoire?: boolean
    dateReponse?: Date | string | null
    commentaire?: string | null
  }

  export type EvenementParticipantCreateOrConnectWithoutEvenementInput = {
    where: EvenementParticipantWhereUniqueInput
    create: XOR<EvenementParticipantCreateWithoutEvenementInput, EvenementParticipantUncheckedCreateWithoutEvenementInput>
  }

  export type EvenementParticipantCreateManyEvenementInputEnvelope = {
    data: EvenementParticipantCreateManyEvenementInput | EvenementParticipantCreateManyEvenementInput[]
    skipDuplicates?: boolean
  }

  export type PersonnelUpsertWithoutEvenementsCreeesInput = {
    update: XOR<PersonnelUpdateWithoutEvenementsCreeesInput, PersonnelUncheckedUpdateWithoutEvenementsCreeesInput>
    create: XOR<PersonnelCreateWithoutEvenementsCreeesInput, PersonnelUncheckedCreateWithoutEvenementsCreeesInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutEvenementsCreeesInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutEvenementsCreeesInput, PersonnelUncheckedUpdateWithoutEvenementsCreeesInput>
  }

  export type PersonnelUpdateWithoutEvenementsCreeesInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutEvenementsCreeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type CentreUpsertWithoutEvenementsInput = {
    update: XOR<CentreUpdateWithoutEvenementsInput, CentreUncheckedUpdateWithoutEvenementsInput>
    create: XOR<CentreCreateWithoutEvenementsInput, CentreUncheckedCreateWithoutEvenementsInput>
    where?: CentreWhereInput
  }

  export type CentreUpdateToOneWithWhereWithoutEvenementsInput = {
    where?: CentreWhereInput
    data: XOR<CentreUpdateWithoutEvenementsInput, CentreUncheckedUpdateWithoutEvenementsInput>
  }

  export type CentreUpdateWithoutEvenementsInput = {
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCentreFieldUpdateOperationsInput | $Enums.TypeCentre
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnels?: PersonnelUpdateManyWithoutCentreNestedInput
    sessions?: SessionFMPAUpdateManyWithoutCentreNestedInput
    materiels?: MaterielUpdateManyWithoutCentreNestedInput
    exportsTTA?: ExportTTAUpdateManyWithoutCentreNestedInput
  }

  export type CentreUncheckedUpdateWithoutEvenementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCentreFieldUpdateOperationsInput | $Enums.TypeCentre
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnels?: PersonnelUncheckedUpdateManyWithoutCentreNestedInput
    sessions?: SessionFMPAUncheckedUpdateManyWithoutCentreNestedInput
    materiels?: MaterielUncheckedUpdateManyWithoutCentreNestedInput
    exportsTTA?: ExportTTAUncheckedUpdateManyWithoutCentreNestedInput
  }

  export type EvenementParticipantUpsertWithWhereUniqueWithoutEvenementInput = {
    where: EvenementParticipantWhereUniqueInput
    update: XOR<EvenementParticipantUpdateWithoutEvenementInput, EvenementParticipantUncheckedUpdateWithoutEvenementInput>
    create: XOR<EvenementParticipantCreateWithoutEvenementInput, EvenementParticipantUncheckedCreateWithoutEvenementInput>
  }

  export type EvenementParticipantUpdateWithWhereUniqueWithoutEvenementInput = {
    where: EvenementParticipantWhereUniqueInput
    data: XOR<EvenementParticipantUpdateWithoutEvenementInput, EvenementParticipantUncheckedUpdateWithoutEvenementInput>
  }

  export type EvenementParticipantUpdateManyWithWhereWithoutEvenementInput = {
    where: EvenementParticipantScalarWhereInput
    data: XOR<EvenementParticipantUpdateManyMutationInput, EvenementParticipantUncheckedUpdateManyWithoutEvenementInput>
  }

  export type EvenementCreateWithoutParticipantsInput = {
    titre: string
    description?: string | null
    lieu?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    journeeEntiere?: boolean
    typeEvenement?: string | null
    visibilite?: $Enums.VisibiliteEvenement
    recurrent?: boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createur: PersonnelCreateNestedOneWithoutEvenementsCreeesInput
    centre?: CentreCreateNestedOneWithoutEvenementsInput
  }

  export type EvenementUncheckedCreateWithoutParticipantsInput = {
    id?: number
    createurId: number
    centreId?: number | null
    titre: string
    description?: string | null
    lieu?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    journeeEntiere?: boolean
    typeEvenement?: string | null
    visibilite?: $Enums.VisibiliteEvenement
    recurrent?: boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvenementCreateOrConnectWithoutParticipantsInput = {
    where: EvenementWhereUniqueInput
    create: XOR<EvenementCreateWithoutParticipantsInput, EvenementUncheckedCreateWithoutParticipantsInput>
  }

  export type PersonnelCreateWithoutParticipationsEvenementsInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutParticipationsEvenementsInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutParticipationsEvenementsInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutParticipationsEvenementsInput, PersonnelUncheckedCreateWithoutParticipationsEvenementsInput>
  }

  export type EvenementUpsertWithoutParticipantsInput = {
    update: XOR<EvenementUpdateWithoutParticipantsInput, EvenementUncheckedUpdateWithoutParticipantsInput>
    create: XOR<EvenementCreateWithoutParticipantsInput, EvenementUncheckedCreateWithoutParticipantsInput>
    where?: EvenementWhereInput
  }

  export type EvenementUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: EvenementWhereInput
    data: XOR<EvenementUpdateWithoutParticipantsInput, EvenementUncheckedUpdateWithoutParticipantsInput>
  }

  export type EvenementUpdateWithoutParticipantsInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    journeeEntiere?: BoolFieldUpdateOperationsInput | boolean
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: EnumVisibiliteEvenementFieldUpdateOperationsInput | $Enums.VisibiliteEvenement
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: NullableStringFieldUpdateOperationsInput | string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createur?: PersonnelUpdateOneRequiredWithoutEvenementsCreeesNestedInput
    centre?: CentreUpdateOneWithoutEvenementsNestedInput
  }

  export type EvenementUncheckedUpdateWithoutParticipantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createurId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    journeeEntiere?: BoolFieldUpdateOperationsInput | boolean
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: EnumVisibiliteEvenementFieldUpdateOperationsInput | $Enums.VisibiliteEvenement
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: NullableStringFieldUpdateOperationsInput | string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonnelUpsertWithoutParticipationsEvenementsInput = {
    update: XOR<PersonnelUpdateWithoutParticipationsEvenementsInput, PersonnelUncheckedUpdateWithoutParticipationsEvenementsInput>
    create: XOR<PersonnelCreateWithoutParticipationsEvenementsInput, PersonnelUncheckedCreateWithoutParticipationsEvenementsInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutParticipationsEvenementsInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutParticipationsEvenementsInput, PersonnelUncheckedUpdateWithoutParticipationsEvenementsInput>
  }

  export type PersonnelUpdateWithoutParticipationsEvenementsInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutParticipationsEvenementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type CentreCreateWithoutExportsTTAInput = {
    code: string
    nom: string
    type: $Enums.TypeCentre
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    telephone?: string | null
    email?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personnels?: PersonnelCreateNestedManyWithoutCentreInput
    sessions?: SessionFMPACreateNestedManyWithoutCentreInput
    materiels?: MaterielCreateNestedManyWithoutCentreInput
    evenements?: EvenementCreateNestedManyWithoutCentreInput
  }

  export type CentreUncheckedCreateWithoutExportsTTAInput = {
    id?: number
    code: string
    nom: string
    type: $Enums.TypeCentre
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    telephone?: string | null
    email?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    personnels?: PersonnelUncheckedCreateNestedManyWithoutCentreInput
    sessions?: SessionFMPAUncheckedCreateNestedManyWithoutCentreInput
    materiels?: MaterielUncheckedCreateNestedManyWithoutCentreInput
    evenements?: EvenementUncheckedCreateNestedManyWithoutCentreInput
  }

  export type CentreCreateOrConnectWithoutExportsTTAInput = {
    where: CentreWhereUniqueInput
    create: XOR<CentreCreateWithoutExportsTTAInput, CentreUncheckedCreateWithoutExportsTTAInput>
  }

  export type PersonnelCreateWithoutExportsTTAGeneresInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutExportsTTAGeneresInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutExportsTTAGeneresInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutExportsTTAGeneresInput, PersonnelUncheckedCreateWithoutExportsTTAGeneresInput>
  }

  export type PersonnelCreateWithoutExportsTTAValidesInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    auditLogs?: AuditLogCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelUncheckedCreateWithoutExportsTTAValidesInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type PersonnelCreateOrConnectWithoutExportsTTAValidesInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutExportsTTAValidesInput, PersonnelUncheckedCreateWithoutExportsTTAValidesInput>
  }

  export type SessionFMPACreateWithoutExportsTTAInput = {
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    typeFMPA: TypeFMPACreateNestedOneWithoutSessionsInput
    centre?: CentreCreateNestedOneWithoutSessionsInput
    formateurPrincipal: PersonnelCreateNestedOneWithoutSessionsFMPAFormateurInput
    formateursAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutSessionInput
    inscriptions?: InscriptionFMPACreateNestedManyWithoutSessionInput
    signatures?: SignatureFMPACreateNestedManyWithoutSessionInput
  }

  export type SessionFMPAUncheckedCreateWithoutExportsTTAInput = {
    id?: number
    typeFMPAId: number
    centreId?: number | null
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    formateurPrincipalId: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    formateursAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutSessionInput
    inscriptions?: InscriptionFMPAUncheckedCreateNestedManyWithoutSessionInput
    signatures?: SignatureFMPAUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionFMPACreateOrConnectWithoutExportsTTAInput = {
    where: SessionFMPAWhereUniqueInput
    create: XOR<SessionFMPACreateWithoutExportsTTAInput, SessionFMPAUncheckedCreateWithoutExportsTTAInput>
  }

  export type CentreUpsertWithoutExportsTTAInput = {
    update: XOR<CentreUpdateWithoutExportsTTAInput, CentreUncheckedUpdateWithoutExportsTTAInput>
    create: XOR<CentreCreateWithoutExportsTTAInput, CentreUncheckedCreateWithoutExportsTTAInput>
    where?: CentreWhereInput
  }

  export type CentreUpdateToOneWithWhereWithoutExportsTTAInput = {
    where?: CentreWhereInput
    data: XOR<CentreUpdateWithoutExportsTTAInput, CentreUncheckedUpdateWithoutExportsTTAInput>
  }

  export type CentreUpdateWithoutExportsTTAInput = {
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCentreFieldUpdateOperationsInput | $Enums.TypeCentre
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnels?: PersonnelUpdateManyWithoutCentreNestedInput
    sessions?: SessionFMPAUpdateManyWithoutCentreNestedInput
    materiels?: MaterielUpdateManyWithoutCentreNestedInput
    evenements?: EvenementUpdateManyWithoutCentreNestedInput
  }

  export type CentreUncheckedUpdateWithoutExportsTTAInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCentreFieldUpdateOperationsInput | $Enums.TypeCentre
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnels?: PersonnelUncheckedUpdateManyWithoutCentreNestedInput
    sessions?: SessionFMPAUncheckedUpdateManyWithoutCentreNestedInput
    materiels?: MaterielUncheckedUpdateManyWithoutCentreNestedInput
    evenements?: EvenementUncheckedUpdateManyWithoutCentreNestedInput
  }

  export type PersonnelUpsertWithoutExportsTTAGeneresInput = {
    update: XOR<PersonnelUpdateWithoutExportsTTAGeneresInput, PersonnelUncheckedUpdateWithoutExportsTTAGeneresInput>
    create: XOR<PersonnelCreateWithoutExportsTTAGeneresInput, PersonnelUncheckedCreateWithoutExportsTTAGeneresInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutExportsTTAGeneresInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutExportsTTAGeneresInput, PersonnelUncheckedUpdateWithoutExportsTTAGeneresInput>
  }

  export type PersonnelUpdateWithoutExportsTTAGeneresInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutExportsTTAGeneresInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUpsertWithoutExportsTTAValidesInput = {
    update: XOR<PersonnelUpdateWithoutExportsTTAValidesInput, PersonnelUncheckedUpdateWithoutExportsTTAValidesInput>
    create: XOR<PersonnelCreateWithoutExportsTTAValidesInput, PersonnelUncheckedCreateWithoutExportsTTAValidesInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutExportsTTAValidesInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutExportsTTAValidesInput, PersonnelUncheckedUpdateWithoutExportsTTAValidesInput>
  }

  export type PersonnelUpdateWithoutExportsTTAValidesInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutExportsTTAValidesInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type SessionFMPAUpsertWithoutExportsTTAInput = {
    update: XOR<SessionFMPAUpdateWithoutExportsTTAInput, SessionFMPAUncheckedUpdateWithoutExportsTTAInput>
    create: XOR<SessionFMPACreateWithoutExportsTTAInput, SessionFMPAUncheckedCreateWithoutExportsTTAInput>
    where?: SessionFMPAWhereInput
  }

  export type SessionFMPAUpdateToOneWithWhereWithoutExportsTTAInput = {
    where?: SessionFMPAWhereInput
    data: XOR<SessionFMPAUpdateWithoutExportsTTAInput, SessionFMPAUncheckedUpdateWithoutExportsTTAInput>
  }

  export type SessionFMPAUpdateWithoutExportsTTAInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeFMPA?: TypeFMPAUpdateOneRequiredWithoutSessionsNestedInput
    centre?: CentreUpdateOneWithoutSessionsNestedInput
    formateurPrincipal?: PersonnelUpdateOneRequiredWithoutSessionsFMPAFormateurNestedInput
    formateursAdditionnels?: SessionFMPAFormateurUpdateManyWithoutSessionNestedInput
    inscriptions?: InscriptionFMPAUpdateManyWithoutSessionNestedInput
    signatures?: SignatureFMPAUpdateManyWithoutSessionNestedInput
  }

  export type SessionFMPAUncheckedUpdateWithoutExportsTTAInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeFMPAId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    formateurPrincipalId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formateursAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutSessionNestedInput
    inscriptions?: InscriptionFMPAUncheckedUpdateManyWithoutSessionNestedInput
    signatures?: SignatureFMPAUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type PersonnelCreateWithoutAuditLogsInput = {
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    centre?: CentreCreateNestedOneWithoutPersonnelsInput
    grade?: GradeCreateNestedOneWithoutPersonnelsInput
    personnelRoles?: PersonnelRoleCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPACreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPACreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPACreateNestedManyWithoutPersonnelInput
    epi?: EPICreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTACreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTACreateNestedManyWithoutValideParInput
  }

  export type PersonnelUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personnelRoles?: PersonnelRoleUncheckedCreateNestedManyWithoutPersonnelInput
    competences?: PersonnelCompetenceUncheckedCreateNestedManyWithoutPersonnelInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedCreateNestedManyWithoutPersonnelInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedCreateNestedManyWithoutFormateurPrincipalInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedCreateNestedManyWithoutPersonnelInput
    signaturesFMPA?: SignatureFMPAUncheckedCreateNestedManyWithoutPersonnelInput
    epi?: EPIUncheckedCreateNestedManyWithoutPersonnelInput
    materielsResponsable?: MaterielUncheckedCreateNestedManyWithoutResponsableInput
    incidentsSignales?: IncidentMaterielUncheckedCreateNestedManyWithoutSignaleParInput
    incidentsTraites?: IncidentMaterielUncheckedCreateNestedManyWithoutTraiteParInput
    conversationsCreees?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    participations?: ConversationParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    messagesEnvoyes?: MessageUncheckedCreateNestedManyWithoutExpediteurInput
    messagesLus?: MessageLuUncheckedCreateNestedManyWithoutPersonnelInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutDestinataireInput
    evenementsCreees?: EvenementUncheckedCreateNestedManyWithoutCreateurInput
    participationsEvenements?: EvenementParticipantUncheckedCreateNestedManyWithoutPersonnelInput
    exportsTTAGeneres?: ExportTTAUncheckedCreateNestedManyWithoutGenereParInput
    exportsTTAValides?: ExportTTAUncheckedCreateNestedManyWithoutValideParInput
  }

  export type PersonnelCreateOrConnectWithoutAuditLogsInput = {
    where: PersonnelWhereUniqueInput
    create: XOR<PersonnelCreateWithoutAuditLogsInput, PersonnelUncheckedCreateWithoutAuditLogsInput>
  }

  export type PersonnelUpsertWithoutAuditLogsInput = {
    update: XOR<PersonnelUpdateWithoutAuditLogsInput, PersonnelUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<PersonnelCreateWithoutAuditLogsInput, PersonnelUncheckedCreateWithoutAuditLogsInput>
    where?: PersonnelWhereInput
  }

  export type PersonnelUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: PersonnelWhereInput
    data: XOR<PersonnelUpdateWithoutAuditLogsInput, PersonnelUncheckedUpdateWithoutAuditLogsInput>
  }

  export type PersonnelUpdateWithoutAuditLogsInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
  }

  export type PersonnelCreateManyGradeInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    centreId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PersonnelUpdateWithoutGradeInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centre?: CentreUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutGradeInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateManyWithoutGradeInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonnelCreateManyCentreInput = {
    id?: number
    matricule: string
    nom: string
    prenom: string
    dateNaissance?: Date | string | null
    sexe?: $Enums.Sexe | null
    email?: string | null
    telephoneMobile?: string | null
    telephoneFixe?: string | null
    adresse?: string | null
    ville?: string | null
    codePostal?: string | null
    gradeId?: number | null
    categorie: $Enums.Categorie
    dateEngagement?: Date | string | null
    dateFinEngagement?: Date | string | null
    statut?: $Enums.StatutPersonnel
    password: string
    refreshToken?: string | null
    lastLogin?: Date | string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SessionFMPACreateManyCentreInput = {
    id?: number
    typeFMPAId: number
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    formateurPrincipalId: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterielCreateManyCentreInput = {
    id?: number
    categorieId: number
    codeInventaire: string
    libelle: string
    marque?: string | null
    modele?: string | null
    numeroSerie?: string | null
    dateAcquisition?: Date | string | null
    dateMiseService?: Date | string | null
    dateReforme?: Date | string | null
    etat?: $Enums.EtatMateriel
    periodiciteControleJours?: number | null
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    localisation?: string | null
    responsableId?: number | null
    valeurAchat?: number | null
    fournisseur?: string | null
    numeroMarche?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvenementCreateManyCentreInput = {
    id?: number
    createurId: number
    titre: string
    description?: string | null
    lieu?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    journeeEntiere?: boolean
    typeEvenement?: string | null
    visibilite?: $Enums.VisibiliteEvenement
    recurrent?: boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExportTTACreateManyCentreInput = {
    id?: number
    periodeDebut: Date | string
    periodeFin: Date | string
    genereParId: number
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    valideParId?: number | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
    sessionId?: number | null
  }

  export type PersonnelUpdateWithoutCentreInput = {
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: GradeUpdateOneWithoutPersonnelsNestedInput
    personnelRoles?: PersonnelRoleUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateWithoutCentreInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnelRoles?: PersonnelRoleUncheckedUpdateManyWithoutPersonnelNestedInput
    competences?: PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelNestedInput
    aptitudesMedicales?: AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelNestedInput
    inscriptionsFMPA?: InscriptionFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    sessionsFMPAFormateur?: SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalNestedInput
    sessionsFMPAAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelNestedInput
    signaturesFMPA?: SignatureFMPAUncheckedUpdateManyWithoutPersonnelNestedInput
    epi?: EPIUncheckedUpdateManyWithoutPersonnelNestedInput
    materielsResponsable?: MaterielUncheckedUpdateManyWithoutResponsableNestedInput
    incidentsSignales?: IncidentMaterielUncheckedUpdateManyWithoutSignaleParNestedInput
    incidentsTraites?: IncidentMaterielUncheckedUpdateManyWithoutTraiteParNestedInput
    conversationsCreees?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    participations?: ConversationParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    messagesEnvoyes?: MessageUncheckedUpdateManyWithoutExpediteurNestedInput
    messagesLus?: MessageLuUncheckedUpdateManyWithoutPersonnelNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutDestinataireNestedInput
    evenementsCreees?: EvenementUncheckedUpdateManyWithoutCreateurNestedInput
    participationsEvenements?: EvenementParticipantUncheckedUpdateManyWithoutPersonnelNestedInput
    exportsTTAGeneres?: ExportTTAUncheckedUpdateManyWithoutGenereParNestedInput
    exportsTTAValides?: ExportTTAUncheckedUpdateManyWithoutValideParNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type PersonnelUncheckedUpdateManyWithoutCentreInput = {
    id?: IntFieldUpdateOperationsInput | number
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneMobile?: NullableStringFieldUpdateOperationsInput | string | null
    telephoneFixe?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    codePostal?: NullableStringFieldUpdateOperationsInput | string | null
    gradeId?: NullableIntFieldUpdateOperationsInput | number | null
    categorie?: EnumCategorieFieldUpdateOperationsInput | $Enums.Categorie
    dateEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFinEngagement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPersonnelFieldUpdateOperationsInput | $Enums.StatutPersonnel
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionFMPAUpdateWithoutCentreInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeFMPA?: TypeFMPAUpdateOneRequiredWithoutSessionsNestedInput
    formateurPrincipal?: PersonnelUpdateOneRequiredWithoutSessionsFMPAFormateurNestedInput
    formateursAdditionnels?: SessionFMPAFormateurUpdateManyWithoutSessionNestedInput
    inscriptions?: InscriptionFMPAUpdateManyWithoutSessionNestedInput
    signatures?: SignatureFMPAUpdateManyWithoutSessionNestedInput
    exportsTTA?: ExportTTAUpdateManyWithoutSessionNestedInput
  }

  export type SessionFMPAUncheckedUpdateWithoutCentreInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeFMPAId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    formateurPrincipalId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formateursAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutSessionNestedInput
    inscriptions?: InscriptionFMPAUncheckedUpdateManyWithoutSessionNestedInput
    signatures?: SignatureFMPAUncheckedUpdateManyWithoutSessionNestedInput
    exportsTTA?: ExportTTAUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionFMPAUncheckedUpdateManyWithoutCentreInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeFMPAId?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    formateurPrincipalId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterielUpdateWithoutCentreInput = {
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categorie?: CategorieMaterielUpdateOneRequiredWithoutMaterielsNestedInput
    responsable?: PersonnelUpdateOneWithoutMaterielsResponsableNestedInput
    incidents?: IncidentMaterielUpdateManyWithoutMaterielNestedInput
  }

  export type MaterielUncheckedUpdateWithoutCentreInput = {
    id?: IntFieldUpdateOperationsInput | number
    categorieId?: IntFieldUpdateOperationsInput | number
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    responsableId?: NullableIntFieldUpdateOperationsInput | number | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incidents?: IncidentMaterielUncheckedUpdateManyWithoutMaterielNestedInput
  }

  export type MaterielUncheckedUpdateManyWithoutCentreInput = {
    id?: IntFieldUpdateOperationsInput | number
    categorieId?: IntFieldUpdateOperationsInput | number
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    responsableId?: NullableIntFieldUpdateOperationsInput | number | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvenementUpdateWithoutCentreInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    journeeEntiere?: BoolFieldUpdateOperationsInput | boolean
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: EnumVisibiliteEvenementFieldUpdateOperationsInput | $Enums.VisibiliteEvenement
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: NullableStringFieldUpdateOperationsInput | string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createur?: PersonnelUpdateOneRequiredWithoutEvenementsCreeesNestedInput
    participants?: EvenementParticipantUpdateManyWithoutEvenementNestedInput
  }

  export type EvenementUncheckedUpdateWithoutCentreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createurId?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    journeeEntiere?: BoolFieldUpdateOperationsInput | boolean
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: EnumVisibiliteEvenementFieldUpdateOperationsInput | $Enums.VisibiliteEvenement
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: NullableStringFieldUpdateOperationsInput | string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: EvenementParticipantUncheckedUpdateManyWithoutEvenementNestedInput
  }

  export type EvenementUncheckedUpdateManyWithoutCentreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createurId?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    journeeEntiere?: BoolFieldUpdateOperationsInput | boolean
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: EnumVisibiliteEvenementFieldUpdateOperationsInput | $Enums.VisibiliteEvenement
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: NullableStringFieldUpdateOperationsInput | string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportTTAUpdateWithoutCentreInput = {
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    generePar?: PersonnelUpdateOneRequiredWithoutExportsTTAGeneresNestedInput
    validePar?: PersonnelUpdateOneWithoutExportsTTAValidesNestedInput
    session?: SessionFMPAUpdateOneWithoutExportsTTANestedInput
  }

  export type ExportTTAUncheckedUpdateWithoutCentreInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    genereParId?: IntFieldUpdateOperationsInput | number
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valideParId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExportTTAUncheckedUpdateManyWithoutCentreInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    genereParId?: IntFieldUpdateOperationsInput | number
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valideParId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PersonnelRoleCreateManyPersonnelInput = {
    roleId: number
    dateAttribution?: Date | string
    dateFin?: Date | string | null
  }

  export type PersonnelCompetenceCreateManyPersonnelInput = {
    id?: number
    typeCompetenceId: number
    dateObtention: Date | string
    dateExpiration?: Date | string | null
    niveau?: string | null
    numeroDiplome?: string | null
    organismeDelivrance?: string | null
    actif?: boolean
    createdAt?: Date | string
  }

  export type AptitudeMedicaleCreateManyPersonnelInput = {
    id?: number
    dateVisite: Date | string
    dateProchaineVisite?: Date | string | null
    aptitude: $Enums.StatutAptitude
    restrictions?: string | null
    medecin?: string | null
    commentaires?: string | null
    createdAt?: Date | string
  }

  export type InscriptionFMPACreateManyPersonnelInput = {
    id?: number
    sessionFMPAId: number
    dateInscription?: Date | string
    statutInscription?: $Enums.StatutInscription
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    signatureElectronique?: string | null
    dateSignature?: Date | string | null
    noteEvaluation?: number | null
    acquis?: boolean | null
    commentaireFormateur?: string | null
    heuresValidees?: number | null
    montantTTA?: number | null
    exportePaie?: boolean
    dateExportPaie?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionFMPACreateManyFormateurPrincipalInput = {
    id?: number
    typeFMPAId: number
    centreId?: number | null
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionFMPAFormateurCreateManyPersonnelInput = {
    sessionId: number
  }

  export type SignatureFMPACreateManyPersonnelInput = {
    id?: string
    sessionFMPAId: number
    type: string
    signature: string
    dateSignature?: Date | string
  }

  export type EPICreateManyPersonnelInput = {
    id?: number
    typeEPI: string
    taille?: string | null
    numeroSerie?: string | null
    dateAttribution: Date | string
    datePeremption?: Date | string | null
    etat?: $Enums.EtatEPI
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterielCreateManyResponsableInput = {
    id?: number
    categorieId: number
    centreId?: number | null
    codeInventaire: string
    libelle: string
    marque?: string | null
    modele?: string | null
    numeroSerie?: string | null
    dateAcquisition?: Date | string | null
    dateMiseService?: Date | string | null
    dateReforme?: Date | string | null
    etat?: $Enums.EtatMateriel
    periodiciteControleJours?: number | null
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    localisation?: string | null
    valeurAchat?: number | null
    fournisseur?: string | null
    numeroMarche?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentMaterielCreateManySignaleParInput = {
    id?: number
    materielId: number
    dateIncident?: Date | string
    typeIncident: $Enums.TypeIncident
    gravite: $Enums.GraviteIncident
    description: string
    photosUrls?: IncidentMaterielCreatephotosUrlsInput | string[]
    statut?: $Enums.StatutIncident
    traiteParId?: number | null
    dateResolution?: Date | string | null
    actionsCorrectives?: string | null
    coutReparation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentMaterielCreateManyTraiteParInput = {
    id?: number
    materielId: number
    signaleParId: number
    dateIncident?: Date | string
    typeIncident: $Enums.TypeIncident
    gravite: $Enums.GraviteIncident
    description: string
    photosUrls?: IncidentMaterielCreatephotosUrlsInput | string[]
    statut?: $Enums.StatutIncident
    dateResolution?: Date | string | null
    actionsCorrectives?: string | null
    coutReparation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyCreatedByInput = {
    id?: number
    type: $Enums.TypeConversation
    nom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationParticipantCreateManyPersonnelInput = {
    conversationId: number
    dateAjout?: Date | string
    dateSortie?: Date | string | null
    role?: $Enums.RoleConversation
    notificationsActives?: boolean
  }

  export type MessageCreateManyExpediteurInput = {
    id?: number
    conversationId: number
    contenu: string
    typeMessage?: $Enums.TypeMessage
    fichierUrl?: string | null
    typeInteractif?: string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type MessageLuCreateManyPersonnelInput = {
    messageId: number
    dateLecture?: Date | string
  }

  export type NotificationCreateManyDestinataireInput = {
    id?: number
    typeNotification: string
    titre: string
    message: string
    niveau?: $Enums.NiveauNotification
    entiteType?: string | null
    entiteId?: number | null
    donneesSupplementaires?: NullableJsonNullValueInput | InputJsonValue
    lue?: boolean
    dateLecture?: Date | string | null
    envoyeePush?: boolean
    envoyeeEmail?: boolean
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type EvenementCreateManyCreateurInput = {
    id?: number
    centreId?: number | null
    titre: string
    description?: string | null
    lieu?: string | null
    dateDebut: Date | string
    dateFin: Date | string
    journeeEntiere?: boolean
    typeEvenement?: string | null
    visibilite?: $Enums.VisibiliteEvenement
    recurrent?: boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvenementParticipantCreateManyPersonnelInput = {
    evenementId: number
    statutInvitation?: $Enums.StatutInvitation
    obligatoire?: boolean
    dateReponse?: Date | string | null
    commentaire?: string | null
  }

  export type ExportTTACreateManyGenereParInput = {
    id?: number
    periodeDebut: Date | string
    periodeFin: Date | string
    centreId?: number | null
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    valideParId?: number | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
    sessionId?: number | null
  }

  export type ExportTTACreateManyValideParInput = {
    id?: number
    periodeDebut: Date | string
    periodeFin: Date | string
    centreId?: number | null
    genereParId: number
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
    sessionId?: number | null
  }

  export type AuditLogCreateManyUtilisateurInput = {
    id?: string
    action: string
    entiteType: string
    entiteId?: number | null
    anciennesValeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvellesValeurs?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PersonnelRoleUpdateWithoutPersonnelInput = {
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: RoleUpdateOneRequiredWithoutPersonnelsNestedInput
  }

  export type PersonnelRoleUncheckedUpdateWithoutPersonnelInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonnelRoleUncheckedUpdateManyWithoutPersonnelInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonnelCompetenceUpdateWithoutPersonnelInput = {
    dateObtention?: DateTimeFieldUpdateOperationsInput | Date | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    numeroDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    organismeDelivrance?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeCompetence?: TypeCompetenceUpdateOneRequiredWithoutCompetencesNestedInput
  }

  export type PersonnelCompetenceUncheckedUpdateWithoutPersonnelInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeCompetenceId?: IntFieldUpdateOperationsInput | number
    dateObtention?: DateTimeFieldUpdateOperationsInput | Date | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    numeroDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    organismeDelivrance?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonnelCompetenceUncheckedUpdateManyWithoutPersonnelInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeCompetenceId?: IntFieldUpdateOperationsInput | number
    dateObtention?: DateTimeFieldUpdateOperationsInput | Date | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    numeroDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    organismeDelivrance?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AptitudeMedicaleUpdateWithoutPersonnelInput = {
    dateVisite?: DateTimeFieldUpdateOperationsInput | Date | string
    dateProchaineVisite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aptitude?: EnumStatutAptitudeFieldUpdateOperationsInput | $Enums.StatutAptitude
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    medecin?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AptitudeMedicaleUncheckedUpdateWithoutPersonnelInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateVisite?: DateTimeFieldUpdateOperationsInput | Date | string
    dateProchaineVisite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aptitude?: EnumStatutAptitudeFieldUpdateOperationsInput | $Enums.StatutAptitude
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    medecin?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AptitudeMedicaleUncheckedUpdateManyWithoutPersonnelInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateVisite?: DateTimeFieldUpdateOperationsInput | Date | string
    dateProchaineVisite?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aptitude?: EnumStatutAptitudeFieldUpdateOperationsInput | $Enums.StatutAptitude
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    medecin?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InscriptionFMPAUpdateWithoutPersonnelInput = {
    dateInscription?: DateTimeFieldUpdateOperationsInput | Date | string
    statutInscription?: EnumStatutInscriptionFieldUpdateOperationsInput | $Enums.StatutInscription
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureElectronique?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteEvaluation?: NullableFloatFieldUpdateOperationsInput | number | null
    acquis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commentaireFormateur?: NullableStringFieldUpdateOperationsInput | string | null
    heuresValidees?: NullableFloatFieldUpdateOperationsInput | number | null
    montantTTA?: NullableFloatFieldUpdateOperationsInput | number | null
    exportePaie?: BoolFieldUpdateOperationsInput | boolean
    dateExportPaie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionFMPAUpdateOneRequiredWithoutInscriptionsNestedInput
  }

  export type InscriptionFMPAUncheckedUpdateWithoutPersonnelInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionFMPAId?: IntFieldUpdateOperationsInput | number
    dateInscription?: DateTimeFieldUpdateOperationsInput | Date | string
    statutInscription?: EnumStatutInscriptionFieldUpdateOperationsInput | $Enums.StatutInscription
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureElectronique?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteEvaluation?: NullableFloatFieldUpdateOperationsInput | number | null
    acquis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commentaireFormateur?: NullableStringFieldUpdateOperationsInput | string | null
    heuresValidees?: NullableFloatFieldUpdateOperationsInput | number | null
    montantTTA?: NullableFloatFieldUpdateOperationsInput | number | null
    exportePaie?: BoolFieldUpdateOperationsInput | boolean
    dateExportPaie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InscriptionFMPAUncheckedUpdateManyWithoutPersonnelInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionFMPAId?: IntFieldUpdateOperationsInput | number
    dateInscription?: DateTimeFieldUpdateOperationsInput | Date | string
    statutInscription?: EnumStatutInscriptionFieldUpdateOperationsInput | $Enums.StatutInscription
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureElectronique?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteEvaluation?: NullableFloatFieldUpdateOperationsInput | number | null
    acquis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commentaireFormateur?: NullableStringFieldUpdateOperationsInput | string | null
    heuresValidees?: NullableFloatFieldUpdateOperationsInput | number | null
    montantTTA?: NullableFloatFieldUpdateOperationsInput | number | null
    exportePaie?: BoolFieldUpdateOperationsInput | boolean
    dateExportPaie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionFMPAUpdateWithoutFormateurPrincipalInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    typeFMPA?: TypeFMPAUpdateOneRequiredWithoutSessionsNestedInput
    centre?: CentreUpdateOneWithoutSessionsNestedInput
    formateursAdditionnels?: SessionFMPAFormateurUpdateManyWithoutSessionNestedInput
    inscriptions?: InscriptionFMPAUpdateManyWithoutSessionNestedInput
    signatures?: SignatureFMPAUpdateManyWithoutSessionNestedInput
    exportsTTA?: ExportTTAUpdateManyWithoutSessionNestedInput
  }

  export type SessionFMPAUncheckedUpdateWithoutFormateurPrincipalInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeFMPAId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formateursAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutSessionNestedInput
    inscriptions?: InscriptionFMPAUncheckedUpdateManyWithoutSessionNestedInput
    signatures?: SignatureFMPAUncheckedUpdateManyWithoutSessionNestedInput
    exportsTTA?: ExportTTAUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionFMPAUncheckedUpdateManyWithoutFormateurPrincipalInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeFMPAId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionFMPAFormateurUpdateWithoutPersonnelInput = {
    session?: SessionFMPAUpdateOneRequiredWithoutFormateursAdditionnelsNestedInput
  }

  export type SessionFMPAFormateurUncheckedUpdateWithoutPersonnelInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionFMPAFormateurUncheckedUpdateManyWithoutPersonnelInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SignatureFMPAUpdateWithoutPersonnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionFMPAUpdateOneRequiredWithoutSignaturesNestedInput
  }

  export type SignatureFMPAUncheckedUpdateWithoutPersonnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionFMPAId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureFMPAUncheckedUpdateManyWithoutPersonnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionFMPAId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EPIUpdateWithoutPersonnelInput = {
    typeEPI?: StringFieldUpdateOperationsInput | string
    taille?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    datePeremption?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatEPIFieldUpdateOperationsInput | $Enums.EtatEPI
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EPIUncheckedUpdateWithoutPersonnelInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeEPI?: StringFieldUpdateOperationsInput | string
    taille?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    datePeremption?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatEPIFieldUpdateOperationsInput | $Enums.EtatEPI
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EPIUncheckedUpdateManyWithoutPersonnelInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeEPI?: StringFieldUpdateOperationsInput | string
    taille?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    datePeremption?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatEPIFieldUpdateOperationsInput | $Enums.EtatEPI
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterielUpdateWithoutResponsableInput = {
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categorie?: CategorieMaterielUpdateOneRequiredWithoutMaterielsNestedInput
    centre?: CentreUpdateOneWithoutMaterielsNestedInput
    incidents?: IncidentMaterielUpdateManyWithoutMaterielNestedInput
  }

  export type MaterielUncheckedUpdateWithoutResponsableInput = {
    id?: IntFieldUpdateOperationsInput | number
    categorieId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incidents?: IncidentMaterielUncheckedUpdateManyWithoutMaterielNestedInput
  }

  export type MaterielUncheckedUpdateManyWithoutResponsableInput = {
    id?: IntFieldUpdateOperationsInput | number
    categorieId?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentMaterielUpdateWithoutSignaleParInput = {
    dateIncident?: DateTimeFieldUpdateOperationsInput | Date | string
    typeIncident?: EnumTypeIncidentFieldUpdateOperationsInput | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFieldUpdateOperationsInput | $Enums.GraviteIncident
    description?: StringFieldUpdateOperationsInput | string
    photosUrls?: IncidentMaterielUpdatephotosUrlsInput | string[]
    statut?: EnumStatutIncidentFieldUpdateOperationsInput | $Enums.StatutIncident
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionsCorrectives?: NullableStringFieldUpdateOperationsInput | string | null
    coutReparation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materiel?: MaterielUpdateOneRequiredWithoutIncidentsNestedInput
    traitePar?: PersonnelUpdateOneWithoutIncidentsTraitesNestedInput
  }

  export type IncidentMaterielUncheckedUpdateWithoutSignaleParInput = {
    id?: IntFieldUpdateOperationsInput | number
    materielId?: IntFieldUpdateOperationsInput | number
    dateIncident?: DateTimeFieldUpdateOperationsInput | Date | string
    typeIncident?: EnumTypeIncidentFieldUpdateOperationsInput | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFieldUpdateOperationsInput | $Enums.GraviteIncident
    description?: StringFieldUpdateOperationsInput | string
    photosUrls?: IncidentMaterielUpdatephotosUrlsInput | string[]
    statut?: EnumStatutIncidentFieldUpdateOperationsInput | $Enums.StatutIncident
    traiteParId?: NullableIntFieldUpdateOperationsInput | number | null
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionsCorrectives?: NullableStringFieldUpdateOperationsInput | string | null
    coutReparation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentMaterielUncheckedUpdateManyWithoutSignaleParInput = {
    id?: IntFieldUpdateOperationsInput | number
    materielId?: IntFieldUpdateOperationsInput | number
    dateIncident?: DateTimeFieldUpdateOperationsInput | Date | string
    typeIncident?: EnumTypeIncidentFieldUpdateOperationsInput | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFieldUpdateOperationsInput | $Enums.GraviteIncident
    description?: StringFieldUpdateOperationsInput | string
    photosUrls?: IncidentMaterielUpdatephotosUrlsInput | string[]
    statut?: EnumStatutIncidentFieldUpdateOperationsInput | $Enums.StatutIncident
    traiteParId?: NullableIntFieldUpdateOperationsInput | number | null
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionsCorrectives?: NullableStringFieldUpdateOperationsInput | string | null
    coutReparation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentMaterielUpdateWithoutTraiteParInput = {
    dateIncident?: DateTimeFieldUpdateOperationsInput | Date | string
    typeIncident?: EnumTypeIncidentFieldUpdateOperationsInput | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFieldUpdateOperationsInput | $Enums.GraviteIncident
    description?: StringFieldUpdateOperationsInput | string
    photosUrls?: IncidentMaterielUpdatephotosUrlsInput | string[]
    statut?: EnumStatutIncidentFieldUpdateOperationsInput | $Enums.StatutIncident
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionsCorrectives?: NullableStringFieldUpdateOperationsInput | string | null
    coutReparation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materiel?: MaterielUpdateOneRequiredWithoutIncidentsNestedInput
    signalePar?: PersonnelUpdateOneRequiredWithoutIncidentsSignalesNestedInput
  }

  export type IncidentMaterielUncheckedUpdateWithoutTraiteParInput = {
    id?: IntFieldUpdateOperationsInput | number
    materielId?: IntFieldUpdateOperationsInput | number
    signaleParId?: IntFieldUpdateOperationsInput | number
    dateIncident?: DateTimeFieldUpdateOperationsInput | Date | string
    typeIncident?: EnumTypeIncidentFieldUpdateOperationsInput | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFieldUpdateOperationsInput | $Enums.GraviteIncident
    description?: StringFieldUpdateOperationsInput | string
    photosUrls?: IncidentMaterielUpdatephotosUrlsInput | string[]
    statut?: EnumStatutIncidentFieldUpdateOperationsInput | $Enums.StatutIncident
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionsCorrectives?: NullableStringFieldUpdateOperationsInput | string | null
    coutReparation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentMaterielUncheckedUpdateManyWithoutTraiteParInput = {
    id?: IntFieldUpdateOperationsInput | number
    materielId?: IntFieldUpdateOperationsInput | number
    signaleParId?: IntFieldUpdateOperationsInput | number
    dateIncident?: DateTimeFieldUpdateOperationsInput | Date | string
    typeIncident?: EnumTypeIncidentFieldUpdateOperationsInput | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFieldUpdateOperationsInput | $Enums.GraviteIncident
    description?: StringFieldUpdateOperationsInput | string
    photosUrls?: IncidentMaterielUpdatephotosUrlsInput | string[]
    statut?: EnumStatutIncidentFieldUpdateOperationsInput | $Enums.StatutIncident
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionsCorrectives?: NullableStringFieldUpdateOperationsInput | string | null
    coutReparation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutCreatedByInput = {
    type?: EnumTypeConversationFieldUpdateOperationsInput | $Enums.TypeConversation
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTypeConversationFieldUpdateOperationsInput | $Enums.TypeConversation
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTypeConversationFieldUpdateOperationsInput | $Enums.TypeConversation
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUpdateWithoutPersonnelInput = {
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleConversationFieldUpdateOperationsInput | $Enums.RoleConversation
    notificationsActives?: BoolFieldUpdateOperationsInput | boolean
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutPersonnelInput = {
    conversationId?: IntFieldUpdateOperationsInput | number
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleConversationFieldUpdateOperationsInput | $Enums.RoleConversation
    notificationsActives?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutPersonnelInput = {
    conversationId?: IntFieldUpdateOperationsInput | number
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleConversationFieldUpdateOperationsInput | $Enums.RoleConversation
    notificationsActives?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUpdateWithoutExpediteurInput = {
    contenu?: StringFieldUpdateOperationsInput | string
    typeMessage?: EnumTypeMessageFieldUpdateOperationsInput | $Enums.TypeMessage
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeInteractif?: NullableStringFieldUpdateOperationsInput | string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    messagesLus?: MessageLuUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutExpediteurInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversationId?: IntFieldUpdateOperationsInput | number
    contenu?: StringFieldUpdateOperationsInput | string
    typeMessage?: EnumTypeMessageFieldUpdateOperationsInput | $Enums.TypeMessage
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeInteractif?: NullableStringFieldUpdateOperationsInput | string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messagesLus?: MessageLuUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutExpediteurInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversationId?: IntFieldUpdateOperationsInput | number
    contenu?: StringFieldUpdateOperationsInput | string
    typeMessage?: EnumTypeMessageFieldUpdateOperationsInput | $Enums.TypeMessage
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeInteractif?: NullableStringFieldUpdateOperationsInput | string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageLuUpdateWithoutPersonnelInput = {
    dateLecture?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutMessagesLusNestedInput
  }

  export type MessageLuUncheckedUpdateWithoutPersonnelInput = {
    messageId?: IntFieldUpdateOperationsInput | number
    dateLecture?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLuUncheckedUpdateManyWithoutPersonnelInput = {
    messageId?: IntFieldUpdateOperationsInput | number
    dateLecture?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutDestinataireInput = {
    typeNotification?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    niveau?: EnumNiveauNotificationFieldUpdateOperationsInput | $Enums.NiveauNotification
    entiteType?: NullableStringFieldUpdateOperationsInput | string | null
    entiteId?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSupplementaires?: NullableJsonNullValueInput | InputJsonValue
    lue?: BoolFieldUpdateOperationsInput | boolean
    dateLecture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    envoyeePush?: BoolFieldUpdateOperationsInput | boolean
    envoyeeEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutDestinataireInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeNotification?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    niveau?: EnumNiveauNotificationFieldUpdateOperationsInput | $Enums.NiveauNotification
    entiteType?: NullableStringFieldUpdateOperationsInput | string | null
    entiteId?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSupplementaires?: NullableJsonNullValueInput | InputJsonValue
    lue?: BoolFieldUpdateOperationsInput | boolean
    dateLecture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    envoyeePush?: BoolFieldUpdateOperationsInput | boolean
    envoyeeEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutDestinataireInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeNotification?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    niveau?: EnumNiveauNotificationFieldUpdateOperationsInput | $Enums.NiveauNotification
    entiteType?: NullableStringFieldUpdateOperationsInput | string | null
    entiteId?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSupplementaires?: NullableJsonNullValueInput | InputJsonValue
    lue?: BoolFieldUpdateOperationsInput | boolean
    dateLecture?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    envoyeePush?: BoolFieldUpdateOperationsInput | boolean
    envoyeeEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvenementUpdateWithoutCreateurInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    journeeEntiere?: BoolFieldUpdateOperationsInput | boolean
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: EnumVisibiliteEvenementFieldUpdateOperationsInput | $Enums.VisibiliteEvenement
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: NullableStringFieldUpdateOperationsInput | string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    centre?: CentreUpdateOneWithoutEvenementsNestedInput
    participants?: EvenementParticipantUpdateManyWithoutEvenementNestedInput
  }

  export type EvenementUncheckedUpdateWithoutCreateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    journeeEntiere?: BoolFieldUpdateOperationsInput | boolean
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: EnumVisibiliteEvenementFieldUpdateOperationsInput | $Enums.VisibiliteEvenement
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: NullableStringFieldUpdateOperationsInput | string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: EvenementParticipantUncheckedUpdateManyWithoutEvenementNestedInput
  }

  export type EvenementUncheckedUpdateManyWithoutCreateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    journeeEntiere?: BoolFieldUpdateOperationsInput | boolean
    typeEvenement?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: EnumVisibiliteEvenementFieldUpdateOperationsInput | $Enums.VisibiliteEvenement
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    patternRecurrence?: NullableJsonNullValueInput | InputJsonValue
    couleur?: NullableStringFieldUpdateOperationsInput | string | null
    rappels?: JsonNullValueInput | InputJsonValue
    annule?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvenementParticipantUpdateWithoutPersonnelInput = {
    statutInvitation?: EnumStatutInvitationFieldUpdateOperationsInput | $Enums.StatutInvitation
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    dateReponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    evenement?: EvenementUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type EvenementParticipantUncheckedUpdateWithoutPersonnelInput = {
    evenementId?: IntFieldUpdateOperationsInput | number
    statutInvitation?: EnumStatutInvitationFieldUpdateOperationsInput | $Enums.StatutInvitation
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    dateReponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvenementParticipantUncheckedUpdateManyWithoutPersonnelInput = {
    evenementId?: IntFieldUpdateOperationsInput | number
    statutInvitation?: EnumStatutInvitationFieldUpdateOperationsInput | $Enums.StatutInvitation
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    dateReponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExportTTAUpdateWithoutGenereParInput = {
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    centre?: CentreUpdateOneWithoutExportsTTANestedInput
    validePar?: PersonnelUpdateOneWithoutExportsTTAValidesNestedInput
    session?: SessionFMPAUpdateOneWithoutExportsTTANestedInput
  }

  export type ExportTTAUncheckedUpdateWithoutGenereParInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valideParId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExportTTAUncheckedUpdateManyWithoutGenereParInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valideParId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExportTTAUpdateWithoutValideParInput = {
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    centre?: CentreUpdateOneWithoutExportsTTANestedInput
    generePar?: PersonnelUpdateOneRequiredWithoutExportsTTAGeneresNestedInput
    session?: SessionFMPAUpdateOneWithoutExportsTTANestedInput
  }

  export type ExportTTAUncheckedUpdateWithoutValideParInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    genereParId?: IntFieldUpdateOperationsInput | number
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExportTTAUncheckedUpdateManyWithoutValideParInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    genereParId?: IntFieldUpdateOperationsInput | number
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AuditLogUpdateWithoutUtilisateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entiteType?: StringFieldUpdateOperationsInput | string
    entiteId?: NullableIntFieldUpdateOperationsInput | number | null
    anciennesValeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvellesValeurs?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUtilisateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entiteType?: StringFieldUpdateOperationsInput | string
    entiteId?: NullableIntFieldUpdateOperationsInput | number | null
    anciennesValeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvellesValeurs?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entiteType?: StringFieldUpdateOperationsInput | string
    entiteId?: NullableIntFieldUpdateOperationsInput | number | null
    anciennesValeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvellesValeurs?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonnelRoleCreateManyRoleInput = {
    personnelId: number
    dateAttribution?: Date | string
    dateFin?: Date | string | null
  }

  export type PersonnelRoleUpdateWithoutRoleInput = {
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personnel?: PersonnelUpdateOneRequiredWithoutPersonnelRolesNestedInput
  }

  export type PersonnelRoleUncheckedUpdateWithoutRoleInput = {
    personnelId?: IntFieldUpdateOperationsInput | number
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonnelRoleUncheckedUpdateManyWithoutRoleInput = {
    personnelId?: IntFieldUpdateOperationsInput | number
    dateAttribution?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonnelCompetenceCreateManyTypeCompetenceInput = {
    id?: number
    personnelId: number
    dateObtention: Date | string
    dateExpiration?: Date | string | null
    niveau?: string | null
    numeroDiplome?: string | null
    organismeDelivrance?: string | null
    actif?: boolean
    createdAt?: Date | string
  }

  export type PersonnelCompetenceUpdateWithoutTypeCompetenceInput = {
    dateObtention?: DateTimeFieldUpdateOperationsInput | Date | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    numeroDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    organismeDelivrance?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnel?: PersonnelUpdateOneRequiredWithoutCompetencesNestedInput
  }

  export type PersonnelCompetenceUncheckedUpdateWithoutTypeCompetenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    dateObtention?: DateTimeFieldUpdateOperationsInput | Date | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    numeroDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    organismeDelivrance?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonnelCompetenceUncheckedUpdateManyWithoutTypeCompetenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    dateObtention?: DateTimeFieldUpdateOperationsInput | Date | string
    dateExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    niveau?: NullableStringFieldUpdateOperationsInput | string | null
    numeroDiplome?: NullableStringFieldUpdateOperationsInput | string | null
    organismeDelivrance?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionFMPACreateManyTypeFMPAInput = {
    id?: number
    centreId?: number | null
    dateDebut: Date | string
    dateFin: Date | string
    lieu?: string | null
    nombrePlacesMax?: number | null
    nombreInscrits?: number
    formateurPrincipalId: number
    statut?: $Enums.StatutSession
    codeTTA?: string | null
    tauxHoraire?: number | null
    commentaires?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionFMPAUpdateWithoutTypeFMPAInput = {
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    centre?: CentreUpdateOneWithoutSessionsNestedInput
    formateurPrincipal?: PersonnelUpdateOneRequiredWithoutSessionsFMPAFormateurNestedInput
    formateursAdditionnels?: SessionFMPAFormateurUpdateManyWithoutSessionNestedInput
    inscriptions?: InscriptionFMPAUpdateManyWithoutSessionNestedInput
    signatures?: SignatureFMPAUpdateManyWithoutSessionNestedInput
    exportsTTA?: ExportTTAUpdateManyWithoutSessionNestedInput
  }

  export type SessionFMPAUncheckedUpdateWithoutTypeFMPAInput = {
    id?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    formateurPrincipalId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formateursAdditionnels?: SessionFMPAFormateurUncheckedUpdateManyWithoutSessionNestedInput
    inscriptions?: InscriptionFMPAUncheckedUpdateManyWithoutSessionNestedInput
    signatures?: SignatureFMPAUncheckedUpdateManyWithoutSessionNestedInput
    exportsTTA?: ExportTTAUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionFMPAUncheckedUpdateManyWithoutTypeFMPAInput = {
    id?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    lieu?: NullableStringFieldUpdateOperationsInput | string | null
    nombrePlacesMax?: NullableIntFieldUpdateOperationsInput | number | null
    nombreInscrits?: IntFieldUpdateOperationsInput | number
    formateurPrincipalId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutSessionFieldUpdateOperationsInput | $Enums.StatutSession
    codeTTA?: NullableStringFieldUpdateOperationsInput | string | null
    tauxHoraire?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionFMPAFormateurCreateManySessionInput = {
    personnelId: number
  }

  export type InscriptionFMPACreateManySessionInput = {
    id?: number
    personnelId: number
    dateInscription?: Date | string
    statutInscription?: $Enums.StatutInscription
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    signatureElectronique?: string | null
    dateSignature?: Date | string | null
    noteEvaluation?: number | null
    acquis?: boolean | null
    commentaireFormateur?: string | null
    heuresValidees?: number | null
    montantTTA?: number | null
    exportePaie?: boolean
    dateExportPaie?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SignatureFMPACreateManySessionInput = {
    id?: string
    personnelId: number
    type: string
    signature: string
    dateSignature?: Date | string
  }

  export type ExportTTACreateManySessionInput = {
    id?: number
    periodeDebut: Date | string
    periodeFin: Date | string
    centreId?: number | null
    genereParId: number
    dateGeneration?: Date | string
    nombreLignes?: number | null
    montantTotal?: number | null
    fichierUrl?: string | null
    formatExport: $Enums.FormatExport
    statut?: $Enums.StatutExport
    dateValidation?: Date | string | null
    valideParId?: number | null
    dateTransmission?: Date | string | null
    numeroBordereau?: string | null
    commentaires?: string | null
  }

  export type SessionFMPAFormateurUpdateWithoutSessionInput = {
    personnel?: PersonnelUpdateOneRequiredWithoutSessionsFMPAAdditionnelsNestedInput
  }

  export type SessionFMPAFormateurUncheckedUpdateWithoutSessionInput = {
    personnelId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionFMPAFormateurUncheckedUpdateManyWithoutSessionInput = {
    personnelId?: IntFieldUpdateOperationsInput | number
  }

  export type InscriptionFMPAUpdateWithoutSessionInput = {
    dateInscription?: DateTimeFieldUpdateOperationsInput | Date | string
    statutInscription?: EnumStatutInscriptionFieldUpdateOperationsInput | $Enums.StatutInscription
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureElectronique?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteEvaluation?: NullableFloatFieldUpdateOperationsInput | number | null
    acquis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commentaireFormateur?: NullableStringFieldUpdateOperationsInput | string | null
    heuresValidees?: NullableFloatFieldUpdateOperationsInput | number | null
    montantTTA?: NullableFloatFieldUpdateOperationsInput | number | null
    exportePaie?: BoolFieldUpdateOperationsInput | boolean
    dateExportPaie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personnel?: PersonnelUpdateOneRequiredWithoutInscriptionsFMPANestedInput
  }

  export type InscriptionFMPAUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    dateInscription?: DateTimeFieldUpdateOperationsInput | Date | string
    statutInscription?: EnumStatutInscriptionFieldUpdateOperationsInput | $Enums.StatutInscription
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureElectronique?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteEvaluation?: NullableFloatFieldUpdateOperationsInput | number | null
    acquis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commentaireFormateur?: NullableStringFieldUpdateOperationsInput | string | null
    heuresValidees?: NullableFloatFieldUpdateOperationsInput | number | null
    montantTTA?: NullableFloatFieldUpdateOperationsInput | number | null
    exportePaie?: BoolFieldUpdateOperationsInput | boolean
    dateExportPaie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InscriptionFMPAUncheckedUpdateManyWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    personnelId?: IntFieldUpdateOperationsInput | number
    dateInscription?: DateTimeFieldUpdateOperationsInput | Date | string
    statutInscription?: EnumStatutInscriptionFieldUpdateOperationsInput | $Enums.StatutInscription
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureElectronique?: NullableStringFieldUpdateOperationsInput | string | null
    dateSignature?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteEvaluation?: NullableFloatFieldUpdateOperationsInput | number | null
    acquis?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commentaireFormateur?: NullableStringFieldUpdateOperationsInput | string | null
    heuresValidees?: NullableFloatFieldUpdateOperationsInput | number | null
    montantTTA?: NullableFloatFieldUpdateOperationsInput | number | null
    exportePaie?: BoolFieldUpdateOperationsInput | boolean
    dateExportPaie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureFMPAUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
    personnel?: PersonnelUpdateOneRequiredWithoutSignaturesFMPANestedInput
  }

  export type SignatureFMPAUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    personnelId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureFMPAUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    personnelId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    dateSignature?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportTTAUpdateWithoutSessionInput = {
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    centre?: CentreUpdateOneWithoutExportsTTANestedInput
    generePar?: PersonnelUpdateOneRequiredWithoutExportsTTAGeneresNestedInput
    validePar?: PersonnelUpdateOneWithoutExportsTTAValidesNestedInput
  }

  export type ExportTTAUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    genereParId?: IntFieldUpdateOperationsInput | number
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valideParId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExportTTAUncheckedUpdateManyWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodeDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    periodeFin?: DateTimeFieldUpdateOperationsInput | Date | string
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    genereParId?: IntFieldUpdateOperationsInput | number
    dateGeneration?: DateTimeFieldUpdateOperationsInput | Date | string
    nombreLignes?: NullableIntFieldUpdateOperationsInput | number | null
    montantTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    formatExport?: EnumFormatExportFieldUpdateOperationsInput | $Enums.FormatExport
    statut?: EnumStatutExportFieldUpdateOperationsInput | $Enums.StatutExport
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valideParId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTransmission?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numeroBordereau?: NullableStringFieldUpdateOperationsInput | string | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterielCreateManyCategorieInput = {
    id?: number
    centreId?: number | null
    codeInventaire: string
    libelle: string
    marque?: string | null
    modele?: string | null
    numeroSerie?: string | null
    dateAcquisition?: Date | string | null
    dateMiseService?: Date | string | null
    dateReforme?: Date | string | null
    etat?: $Enums.EtatMateriel
    periodiciteControleJours?: number | null
    dateDernierControle?: Date | string | null
    dateProchainControle?: Date | string | null
    localisation?: string | null
    responsableId?: number | null
    valeurAchat?: number | null
    fournisseur?: string | null
    numeroMarche?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterielUpdateWithoutCategorieInput = {
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    centre?: CentreUpdateOneWithoutMaterielsNestedInput
    responsable?: PersonnelUpdateOneWithoutMaterielsResponsableNestedInput
    incidents?: IncidentMaterielUpdateManyWithoutMaterielNestedInput
  }

  export type MaterielUncheckedUpdateWithoutCategorieInput = {
    id?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    responsableId?: NullableIntFieldUpdateOperationsInput | number | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incidents?: IncidentMaterielUncheckedUpdateManyWithoutMaterielNestedInput
  }

  export type MaterielUncheckedUpdateManyWithoutCategorieInput = {
    id?: IntFieldUpdateOperationsInput | number
    centreId?: NullableIntFieldUpdateOperationsInput | number | null
    codeInventaire?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    numeroSerie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAcquisition?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateMiseService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReforme?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    etat?: EnumEtatMaterielFieldUpdateOperationsInput | $Enums.EtatMateriel
    periodiciteControleJours?: NullableIntFieldUpdateOperationsInput | number | null
    dateDernierControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchainControle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    responsableId?: NullableIntFieldUpdateOperationsInput | number | null
    valeurAchat?: NullableFloatFieldUpdateOperationsInput | number | null
    fournisseur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroMarche?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentMaterielCreateManyMaterielInput = {
    id?: number
    signaleParId: number
    dateIncident?: Date | string
    typeIncident: $Enums.TypeIncident
    gravite: $Enums.GraviteIncident
    description: string
    photosUrls?: IncidentMaterielCreatephotosUrlsInput | string[]
    statut?: $Enums.StatutIncident
    traiteParId?: number | null
    dateResolution?: Date | string | null
    actionsCorrectives?: string | null
    coutReparation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentMaterielUpdateWithoutMaterielInput = {
    dateIncident?: DateTimeFieldUpdateOperationsInput | Date | string
    typeIncident?: EnumTypeIncidentFieldUpdateOperationsInput | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFieldUpdateOperationsInput | $Enums.GraviteIncident
    description?: StringFieldUpdateOperationsInput | string
    photosUrls?: IncidentMaterielUpdatephotosUrlsInput | string[]
    statut?: EnumStatutIncidentFieldUpdateOperationsInput | $Enums.StatutIncident
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionsCorrectives?: NullableStringFieldUpdateOperationsInput | string | null
    coutReparation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signalePar?: PersonnelUpdateOneRequiredWithoutIncidentsSignalesNestedInput
    traitePar?: PersonnelUpdateOneWithoutIncidentsTraitesNestedInput
  }

  export type IncidentMaterielUncheckedUpdateWithoutMaterielInput = {
    id?: IntFieldUpdateOperationsInput | number
    signaleParId?: IntFieldUpdateOperationsInput | number
    dateIncident?: DateTimeFieldUpdateOperationsInput | Date | string
    typeIncident?: EnumTypeIncidentFieldUpdateOperationsInput | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFieldUpdateOperationsInput | $Enums.GraviteIncident
    description?: StringFieldUpdateOperationsInput | string
    photosUrls?: IncidentMaterielUpdatephotosUrlsInput | string[]
    statut?: EnumStatutIncidentFieldUpdateOperationsInput | $Enums.StatutIncident
    traiteParId?: NullableIntFieldUpdateOperationsInput | number | null
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionsCorrectives?: NullableStringFieldUpdateOperationsInput | string | null
    coutReparation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentMaterielUncheckedUpdateManyWithoutMaterielInput = {
    id?: IntFieldUpdateOperationsInput | number
    signaleParId?: IntFieldUpdateOperationsInput | number
    dateIncident?: DateTimeFieldUpdateOperationsInput | Date | string
    typeIncident?: EnumTypeIncidentFieldUpdateOperationsInput | $Enums.TypeIncident
    gravite?: EnumGraviteIncidentFieldUpdateOperationsInput | $Enums.GraviteIncident
    description?: StringFieldUpdateOperationsInput | string
    photosUrls?: IncidentMaterielUpdatephotosUrlsInput | string[]
    statut?: EnumStatutIncidentFieldUpdateOperationsInput | $Enums.StatutIncident
    traiteParId?: NullableIntFieldUpdateOperationsInput | number | null
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionsCorrectives?: NullableStringFieldUpdateOperationsInput | string | null
    coutReparation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateManyConversationInput = {
    personnelId: number
    dateAjout?: Date | string
    dateSortie?: Date | string | null
    role?: $Enums.RoleConversation
    notificationsActives?: boolean
  }

  export type MessageCreateManyConversationInput = {
    id?: number
    expediteurId: number
    contenu: string
    typeMessage?: $Enums.TypeMessage
    fichierUrl?: string | null
    typeInteractif?: string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ConversationParticipantUpdateWithoutConversationInput = {
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleConversationFieldUpdateOperationsInput | $Enums.RoleConversation
    notificationsActives?: BoolFieldUpdateOperationsInput | boolean
    personnel?: PersonnelUpdateOneRequiredWithoutParticipationsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutConversationInput = {
    personnelId?: IntFieldUpdateOperationsInput | number
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleConversationFieldUpdateOperationsInput | $Enums.RoleConversation
    notificationsActives?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationInput = {
    personnelId?: IntFieldUpdateOperationsInput | number
    dateAjout?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleConversationFieldUpdateOperationsInput | $Enums.RoleConversation
    notificationsActives?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUpdateWithoutConversationInput = {
    contenu?: StringFieldUpdateOperationsInput | string
    typeMessage?: EnumTypeMessageFieldUpdateOperationsInput | $Enums.TypeMessage
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeInteractif?: NullableStringFieldUpdateOperationsInput | string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expediteur?: PersonnelUpdateOneRequiredWithoutMessagesEnvoyesNestedInput
    messagesLus?: MessageLuUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: IntFieldUpdateOperationsInput | number
    expediteurId?: IntFieldUpdateOperationsInput | number
    contenu?: StringFieldUpdateOperationsInput | string
    typeMessage?: EnumTypeMessageFieldUpdateOperationsInput | $Enums.TypeMessage
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeInteractif?: NullableStringFieldUpdateOperationsInput | string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messagesLus?: MessageLuUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: IntFieldUpdateOperationsInput | number
    expediteurId?: IntFieldUpdateOperationsInput | number
    contenu?: StringFieldUpdateOperationsInput | string
    typeMessage?: EnumTypeMessageFieldUpdateOperationsInput | $Enums.TypeMessage
    fichierUrl?: NullableStringFieldUpdateOperationsInput | string | null
    typeInteractif?: NullableStringFieldUpdateOperationsInput | string | null
    donneesInteractives?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageLuCreateManyMessageInput = {
    personnelId: number
    dateLecture?: Date | string
  }

  export type MessageLuUpdateWithoutMessageInput = {
    dateLecture?: DateTimeFieldUpdateOperationsInput | Date | string
    personnel?: PersonnelUpdateOneRequiredWithoutMessagesLusNestedInput
  }

  export type MessageLuUncheckedUpdateWithoutMessageInput = {
    personnelId?: IntFieldUpdateOperationsInput | number
    dateLecture?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLuUncheckedUpdateManyWithoutMessageInput = {
    personnelId?: IntFieldUpdateOperationsInput | number
    dateLecture?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvenementParticipantCreateManyEvenementInput = {
    personnelId: number
    statutInvitation?: $Enums.StatutInvitation
    obligatoire?: boolean
    dateReponse?: Date | string | null
    commentaire?: string | null
  }

  export type EvenementParticipantUpdateWithoutEvenementInput = {
    statutInvitation?: EnumStatutInvitationFieldUpdateOperationsInput | $Enums.StatutInvitation
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    dateReponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    personnel?: PersonnelUpdateOneRequiredWithoutParticipationsEvenementsNestedInput
  }

  export type EvenementParticipantUncheckedUpdateWithoutEvenementInput = {
    personnelId?: IntFieldUpdateOperationsInput | number
    statutInvitation?: EnumStatutInvitationFieldUpdateOperationsInput | $Enums.StatutInvitation
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    dateReponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvenementParticipantUncheckedUpdateManyWithoutEvenementInput = {
    personnelId?: IntFieldUpdateOperationsInput | number
    statutInvitation?: EnumStatutInvitationFieldUpdateOperationsInput | $Enums.StatutInvitation
    obligatoire?: BoolFieldUpdateOperationsInput | boolean
    dateReponse?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use GradeCountOutputTypeDefaultArgs instead
     */
    export type GradeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GradeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CentreCountOutputTypeDefaultArgs instead
     */
    export type CentreCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CentreCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonnelCountOutputTypeDefaultArgs instead
     */
    export type PersonnelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonnelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TypeCompetenceCountOutputTypeDefaultArgs instead
     */
    export type TypeCompetenceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TypeCompetenceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TypeFMPACountOutputTypeDefaultArgs instead
     */
    export type TypeFMPACountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TypeFMPACountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionFMPACountOutputTypeDefaultArgs instead
     */
    export type SessionFMPACountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionFMPACountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategorieMaterielCountOutputTypeDefaultArgs instead
     */
    export type CategorieMaterielCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategorieMaterielCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterielCountOutputTypeDefaultArgs instead
     */
    export type MaterielCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterielCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationCountOutputTypeDefaultArgs instead
     */
    export type ConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageCountOutputTypeDefaultArgs instead
     */
    export type MessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvenementCountOutputTypeDefaultArgs instead
     */
    export type EvenementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvenementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GradeDefaultArgs instead
     */
    export type GradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GradeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CentreDefaultArgs instead
     */
    export type CentreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CentreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonnelDefaultArgs instead
     */
    export type PersonnelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonnelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonnelRoleDefaultArgs instead
     */
    export type PersonnelRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonnelRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TypeCompetenceDefaultArgs instead
     */
    export type TypeCompetenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TypeCompetenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonnelCompetenceDefaultArgs instead
     */
    export type PersonnelCompetenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonnelCompetenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AptitudeMedicaleDefaultArgs instead
     */
    export type AptitudeMedicaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AptitudeMedicaleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TypeFMPADefaultArgs instead
     */
    export type TypeFMPAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TypeFMPADefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionFMPADefaultArgs instead
     */
    export type SessionFMPAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionFMPADefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionFMPAFormateurDefaultArgs instead
     */
    export type SessionFMPAFormateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionFMPAFormateurDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InscriptionFMPADefaultArgs instead
     */
    export type InscriptionFMPAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InscriptionFMPADefaultArgs<ExtArgs>
    /**
     * @deprecated Use SignatureFMPADefaultArgs instead
     */
    export type SignatureFMPAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SignatureFMPADefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategorieMaterielDefaultArgs instead
     */
    export type CategorieMaterielArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategorieMaterielDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterielDefaultArgs instead
     */
    export type MaterielArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterielDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncidentMaterielDefaultArgs instead
     */
    export type IncidentMaterielArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncidentMaterielDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EPIDefaultArgs instead
     */
    export type EPIArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EPIDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationDefaultArgs instead
     */
    export type ConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationParticipantDefaultArgs instead
     */
    export type ConversationParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageLuDefaultArgs instead
     */
    export type MessageLuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageLuDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvenementDefaultArgs instead
     */
    export type EvenementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvenementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvenementParticipantDefaultArgs instead
     */
    export type EvenementParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvenementParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExportTTADefaultArgs instead
     */
    export type ExportTTAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExportTTADefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}